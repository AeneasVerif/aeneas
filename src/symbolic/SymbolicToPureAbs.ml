open Pure
open PureUtils
open TypesAnalysis
open InterpreterUtils
open SymbolicToPureCore
open SymbolicToPureTypes
open SymbolicToPureValues
module NormSymbProjMap = InterpreterBorrowsCore.NormSymbProjMap

(** The local logger *)
let log = Logging.symbolic_to_pure_abs_log

(** Explore an abstraction value and compute the type of the value consumed upon
    ending the loans. *)
let rec tavalue_to_consumed_ty_aux ~(filter : bool) (ctx : bs_ctx)
    (abs_regions : T.RegionId.Set.t) (av : V.tavalue) : ty option =
  match av.value with
  | AAdt adt_v -> adt_avalue_to_consumed_ty_aux ~filter ctx abs_regions av adt_v
  | ABottom -> [%craise] ctx.span "Unreachable"
  | ALoan lc ->
      aloan_content_to_consumed_ty_aux ~filter ctx abs_regions av.ty lc
  | ABorrow _ ->
      (* This value should have been generated by a loan projector: there
           can't be aborrows unless there are nested borrows, which are not
           supported yet. *)
      [%craise] ctx.span "Unreachable"
  | ASymbolic (pm, aproj) ->
      [%sanity_check] ctx.span (pm = PNone);
      aproj_to_consumed_ty_aux ctx abs_regions aproj av.ty
  | AIgnored _ ->
      if filter then None
      else
        (* If we do not filter it means we are inside an ADT. *)
        Some (ctx_translate_fwd_ty ctx av.ty)

and adt_avalue_to_consumed_ty_aux ~(filter : bool) (ctx : bs_ctx)
    (abs_regions : T.RegionId.Set.t) (av : V.tavalue) (adt_v : V.adt_avalue) :
    ty option =
  let _, out =
    gtranslate_adt_fields ~project_borrows:false
      (fun ~filter ctx v ->
        ( ctx,
          match tavalue_to_consumed_ty_aux ~filter ctx abs_regions v with
          | None -> None
          | Some x -> Some ((), x) ))
      (compute_tavalue_proj_kind ctx.span ctx.type_ctx.type_infos abs_regions)
      (fun _ -> translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos av.ty)
      mk_simpl_tuple_ty ~filter ctx av av.ty adt_v.field_values
  in
  Option.map snd out

and aloan_content_to_consumed_ty_aux ~(filter : bool) (ctx : bs_ctx)
    (_abs_regions : T.RegionId.Set.t) (ty : T.ty) (lc : V.aloan_content) :
    ty option =
  let _ = filter in
  match lc with
  | AMutLoan (pm, _, child) ->
      [%sanity_check] ctx.span (pm = PNone);
      [%sanity_check] ctx.span (ValuesUtils.is_aignored child.value);
      Some (ctx_translate_fwd_ty ctx ty)
  | ASharedLoan (_, _, _, _) -> [%craise] ctx.span "Unreachable"
  | AEndedMutLoan _ | AEndedSharedLoan _ ->
      (* We shouldn't compute the type of a region abstraction if it contains ended loans *)
      [%craise] ctx.span "Unreachable"
  | AIgnoredMutLoan (_, _) ->
      (* There can be *inner* not ended mutable loans, but not outer ones *)
      [%craise] ctx.span "Unreachable"
  | AEndedIgnoredMutLoan _ ->
      (* This happens with nested borrows: we need to dive in *)
      [%craise] ctx.span "Unimplemented"
  | AIgnoredSharedLoan _ ->
      (* This case only happens with nested borrows *)
      [%craise] ctx.span "Unimplemented"

and aproj_to_consumed_ty_aux (ctx : bs_ctx) (_abs_regions : T.RegionId.Set.t)
    (aproj : V.aproj) (_ty : T.ty) : ty option =
  match aproj with
  | V.AProjLoans { proj; consumed; borrows } ->
      [%sanity_check] ctx.span (consumed = []);
      [%sanity_check] ctx.span (borrows = []);
      Some (ctx_translate_fwd_ty ctx proj.proj_ty)
  | V.AEndedProjLoans _ | AEndedProjBorrows _ | AEmpty | AProjBorrows _ ->
      [%craise] ctx.span "Unreachable"

let tavalue_to_consumed_ty (ctx : bs_ctx) (abs_regions : T.RegionId.Set.t)
    (av : V.tavalue) : ty option =
  (* Check if the value was generated from a loan projector: if yes, and if
     it contains mutable loans, then we generate a consumed value (because
     upon ending the borrow we consumed a value).
     Otherwise we ignore it. *)
  [%ltrace tavalue_to_string ~with_ended:true ctx av];
  match
    compute_tavalue_proj_kind ctx.span ctx.type_ctx.type_infos abs_regions av
  with
  | LoanProj BMut ->
      [%ltrace "the value contains mutable loan projectors"];
      tavalue_to_consumed_ty_aux ~filter:true ctx abs_regions av
  | LoanProj BShared | BorrowProj _ | UnknownProj ->
      (* If it is a borrow proj we ignore it. If it is an unknown projection,
         it means the value doesn't contain loans nor borrows, so nothing
         is consumed upon ending the abstraction: we can ignore it as well. *)
      [%ltrace
        "the value doesn't contains mutable loan projectors (ignoring it)"];
      None

let rec tavalue_to_given_back_ty_aux ~(filter : bool) (ctx : bs_ctx)
    (abs_regions : T.RegionId.Set.t) (av : V.tavalue) : ty option =
  match av.value with
  | AAdt adt_v ->
      adt_avalue_to_given_back_ty_aux ~filter abs_regions av adt_v ctx
  | ABottom -> [%craise] ctx.span "Unreachable"
  | ALoan _ ->
      (* The avalue should have been generated by a borrow projector: this case is unreachable *)
      [%craise] ctx.span "Unreachable"
  | ABorrow bc -> aborrow_content_to_given_back_ty_aux ~filter bc av.ty ctx
  | ASymbolic (pm, aproj) ->
      [%sanity_check] ctx.span (pm = PNone);
      aproj_to_given_back_ty_aux aproj av.ty ctx
  | AIgnored _ ->
      if filter then None
      else Some (translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos av.ty)

and adt_avalue_to_given_back_ty_aux ~(filter : bool)
    (abs_regions : T.RegionId.Set.t) (av : V.tavalue) (adt_v : V.adt_avalue)
    (ctx : bs_ctx) : ty option =
  let _, out =
    gtranslate_adt_fields ~project_borrows:true
      (fun ~filter ctx v ->
        ( ctx,
          match tavalue_to_given_back_ty_aux ~filter ctx abs_regions v with
          | None -> None
          | Some x -> Some ((), x) ))
      (compute_tavalue_proj_kind ctx.span ctx.type_ctx.type_infos abs_regions)
      (fun _ -> translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos av.ty)
      mk_simpl_tuple_ty ~filter ctx av av.ty adt_v.field_values
  in
  Option.map snd out

and aborrow_content_to_given_back_ty_aux ~(filter : bool)
    (bc : V.aborrow_content) (ty : T.ty) (ctx : bs_ctx) : ty option =
  match bc with
  | V.AMutBorrow _ ->
      Some (translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos ty)
  | ASharedBorrow _ ->
      if filter then None
      else Some (translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos ty)
  | AIgnoredMutBorrow _ ->
      (* Can happen in case of nested borrows, ignoring for now *)
      [%craise] ctx.span "Unimplemented"
  | AEndedMutBorrow _
  | AEndedIgnoredMutBorrow _
  | AEndedSharedBorrow
  | AProjSharedBorrow _ -> [%craise] ctx.span "Unreachable"

and aproj_to_given_back_ty_aux (aproj : V.aproj) (ty : T.ty) (ctx : bs_ctx) :
    ty option =
  match aproj with
  | V.AProjBorrows { proj = _; loans } ->
      [%sanity_check] ctx.span (loans = []);
      Some (translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos ty)
  | V.AEndedProjLoans _ | AEndedProjBorrows _ | AEmpty | AProjLoans _ ->
      [%craise] ctx.span "Unreachable"

let tavalue_to_given_back_ty (ctx : bs_ctx) (abs_regions : T.RegionId.Set.t)
    (v : V.tavalue) : ty option =
  (* Check if the value was generated from a borrow projector: if yes, and if
     it contains mutable borrows we generate a given back pattern (because
     upon ending the borrow the abstraction gave back a value).
     Otherwise we ignore it. *)
  match
    compute_tavalue_proj_kind ctx.span ctx.type_ctx.type_infos abs_regions v
  with
  | BorrowProj BMut ->
      tavalue_to_given_back_ty_aux ctx abs_regions ~filter:true v
  | BorrowProj BShared | LoanProj _ | UnknownProj ->
      (* If it is a loan proj we ignore it. If it is an unknown projection,
         it means the value doesn't contain loans nor borrows, so nothing
         is given back: we can ignore it as well. *)
      None

(** Compute the type of a region abstraction, seen as a continuation.

    Remark: there shouldn't be any ended loans in this continuation. Also note
    that we flatten the values. *)
let abs_to_input_output_tys (ctx : bs_ctx) (abs : V.abs) : ty list * ty list =
  let inputs =
    List.filter_map (tavalue_to_consumed_ty ctx abs.regions.owned) abs.avalues
  in

  let outputs =
    List.filter_map (tavalue_to_given_back_ty ctx abs.regions.owned) abs.avalues
  in

  (inputs, outputs)

(** Compute the type of a region abstraction, seen as a continuation.

    The result is [None] if the type is actually [unit].

    Remark: there shouldn't be any ended loans in this continuation. Also note
    that we flatten the values. *)
let abs_to_ty (ctx : bs_ctx) (abs : V.abs) : ty option =
  let inputs, outputs = abs_to_input_output_tys ctx abs in
  if inputs = [] && outputs = [] then None
  else Some (mk_arrows inputs (mk_simpl_tuple_ty outputs))

let compute_tevalue_proj_kind (span : Meta.span) (type_infos : type_infos)
    (abs_regions : T.RegionId.Set.t) (ev : V.tevalue) : tavalue_kind =
  let has_borrows = ref false in
  let has_mut_borrows = ref false in
  let has_loans = ref false in
  let has_mut_loans = ref false in
  let keep_region (r : T.region) =
    match r with
    | T.RVar (Free rid) -> T.RegionId.Set.mem rid abs_regions
    | _ -> false
  in
  let visitor =
    object
      inherit [_] V.iter_tavalue as super

      method! visit_tevalue _ ev =
        (* Remember the type of the current value *)
        super#visit_tevalue ev.ty ev

      method! visit_ELoan env lc =
        has_loans := true;
        begin
          match lc with
          | EIgnoredMutLoan _ | EEndedIgnoredMutLoan _ -> ()
          | EMutLoan _ | EEndedMutLoan _ -> has_mut_loans := true
        end;
        (* Continue exploring as a sanity check: we want to make sure we don't find borrows *)
        super#visit_ELoan env lc

      method! visit_EBorrow env bc =
        has_borrows := true;
        begin
          match bc with
          | EIgnoredMutBorrow _ | EEndedIgnoredMutBorrow _ -> ()
          | EMutBorrow _ | EEndedMutBorrow _ -> has_mut_borrows := true
        end;
        (* Continue exploring as a sanity check: we want to make sure we don't find loans *)
        super#visit_EBorrow env bc

      method! visit_ESymbolic ty pm eproj =
        [%sanity_check] span (pm = PNone);
        match eproj with
        | V.EEndedProjLoans _ ->
            has_loans := true;
            (* We need to check wether the projected loans are mutable or not *)
            if
              TypesUtils.ty_has_mut_borrow_for_region_in_pred type_infos
                keep_region ty
            then has_mut_loans := true;
            (* Continue exploring (same reasons as above) *)
            super#visit_ESymbolic ty pm eproj
        | EProjLoans _ ->
            has_loans := true;
            (* Continue exploring (same reasons as above) *)
            super#visit_ESymbolic ty pm eproj
        | EEndedProjBorrows _ ->
            has_borrows := true;
            (* We need to check wether the projected borrows are mutable or not *)
            if
              TypesUtils.ty_has_mut_borrow_for_region_in_pred type_infos
                keep_region ty
            then has_mut_borrows := true;
            (* Continue exploring (same reasons as above) *)
            super#visit_ESymbolic ty pm eproj
        | EProjBorrows _ ->
            has_borrows := true;
            (* Continue exploring (same reasons as above) *)
            super#visit_ESymbolic ty pm eproj
        | EEmpty ->
            (* Continue exploring (same reasons as above) *)
            super#visit_ESymbolic ty pm eproj
    end
  in
  visitor#visit_tevalue ev.ty ev;
  [%cassert] span ((not !has_borrows) || not !has_loans) "Unreachable";
  let to_borrow_kind b = if b then BMut else BShared in
  if !has_borrows then BorrowProj (to_borrow_kind !has_mut_borrows)
  else if !has_loans then LoanProj (to_borrow_kind !has_mut_loans)
  else UnknownProj

let abs_fvar_id_to_tpattern (ctx : bs_ctx)
    (fvar_to_texpr : texpr V.AbsFVarId.Map.t ref) (rids : T.RegionId.Set.t)
    ~(filter : bool) (fid : V.abs_fvar_id) (ty : T.ty) :
    bs_ctx * tpattern option =
  let type_infos = ctx.type_ctx.type_infos in
  let keep_region (r : T.region) =
    match r with
    | T.RVar (Free rid) -> T.RegionId.Set.mem rid rids
    | _ -> false
  in
  if TypesUtils.ty_has_mut_borrow_for_region_in_pred type_infos keep_region ty
  then (
    let ctx, fvar = fresh_var_llbc_ty None ty ctx in
    fvar_to_texpr :=
      V.AbsFVarId.Map.add fid (mk_texpr_from_fvar fvar) !fvar_to_texpr;
    (ctx, Some (mk_tpattern_from_fvar fvar None)))
  else
    let pat =
      if filter then begin
        None
      end
      else begin
        fvar_to_texpr := V.AbsFVarId.Map.add fid mk_unit_texpr !fvar_to_texpr;
        let ty = ctx_translate_fwd_ty ctx ty in
        Some (mk_dummy_pattern ty)
      end
    in
    (ctx, pat)

(** Map inputs (i.e., (symbolic) loans) or ouputs (i.e., (symbolic) borrows) to
    free variables. We use this in order to control the order in which we bind
    the inputs (it is fixed by the avalues which act as a signature of the
    function). *)
type bound_borrows_loans = {
  concrete : texpr V.BorrowId.Map.t;
  symbolic : texpr NormSymbProjMap.t;
}

let empty_bound_borrows_loans : bound_borrows_loans =
  { concrete = V.BorrowId.Map.empty; symbolic = NormSymbProjMap.empty }

let bound_borrows_loans_to_string (ctx : bs_ctx) (bound : bound_borrows_loans) :
    string =
  let { concrete; symbolic } = bound in
  "{\n  concrete: "
  ^ V.BorrowId.Map.to_string (Some "    ") (texpr_to_string ctx) concrete
  ^ "\n  symbolic: "
  ^ NormSymbProjMap.to_string (Some "    ") (texpr_to_string ctx) symbolic
  ^ "\n}"

(** We need [fvar_to_texpr] because variables may be bound inside intermediate
    let-bindings inside the region abstraction continuation, so we need to
    remember by which pure expression we translated the abstraction free
    variable, in case it is used later. In case we ignore a free variable (we
    want to eliminate it) we register it in [fvar_to_none] for sanity purposes.
*)
let eoutput_to_pat (ctx : bs_ctx) (fvar_to_texpr : texpr V.AbsFVarId.Map.t ref)
    (rids : T.RegionId.Set.t) (output : V.tevalue) :
    bs_ctx * bound_borrows_loans * tpattern =
  let span = ctx.span in
  let type_infos = ctx.type_ctx.type_infos in
  let concrete = ref V.BorrowId.Map.empty in
  let symbolic = ref NormSymbProjMap.empty in
  let keep_region (r : T.region) =
    match r with
    | T.RVar (Free rid) -> T.RegionId.Set.mem rid rids
    | _ -> false
  in
  let fresh_fvar ctx (ty : T.ty) : bs_ctx * texpr * tpattern =
    let ctx, fvar = fresh_var_llbc_ty None ty ctx in
    (ctx, mk_texpr_from_fvar fvar, mk_tpattern_from_fvar fvar None)
  in
  let add_symbolic ctx (sv_id : SymbolicValueId.id) (proj_ty : T.ty) :
      bs_ctx * tpattern =
    let ctx, e, pat = fresh_fvar ctx proj_ty in
    let norm_proj_ty = InterpreterBorrowsCore.normalize_proj_ty rids proj_ty in
    symbolic := NormSymbProjMap.add { sv_id; norm_proj_ty } e !symbolic;
    (ctx, pat)
  in
  let add_concrete ctx (bid : V.BorrowId.id) (ty : T.ty) : bs_ctx * tpattern =
    let ctx, e, pat = fresh_fvar ctx ty in
    concrete := V.BorrowId.Map.add bid e !concrete;
    (ctx, pat)
  in
  let rec to_pat ~(filter : bool) (ctx : bs_ctx) (output : V.tevalue) :
      bs_ctx * tpattern option =
    match output.value with
    | V.ELet _
    | V.EJoinMarkers _
    | V.EBVar _
    | V.EApp _
    | V.EBottom
    | V.EValue _
    | V.ELoan _ -> [%internal_error] span
    | V.EFVar afid ->
        abs_fvar_id_to_tpattern ctx fvar_to_texpr rids ~filter afid output.ty
    | V.EBorrow bc -> (
        match bc with
        | V.EIgnoredMutBorrow _
        | V.EEndedMutBorrow _
        | V.EEndedIgnoredMutBorrow _ -> [%internal_error] span
        | V.EMutBorrow (pm, bid, _mv, child) ->
            [%sanity_check] span (pm = PNone);
            [%sanity_check] span (ValuesUtils.is_eignored child.value);
            let ctx, e = add_concrete ctx bid output.ty in
            (ctx, Some e))
    | V.ESymbolic (pm, proj) ->
        [%sanity_check] span (pm = PNone);
        begin
          match proj with
          | V.EProjLoans _
          | V.EEndedProjLoans _
          | V.EEndedProjBorrows _
          | V.EEmpty -> [%internal_error] span
          | V.EProjBorrows { proj; loans } ->
              [%sanity_check] span (loans = []);
              (* Case disjunction depending on whether we actually need to give back
                 something or not *)
              if
                TypesUtils.ty_has_mut_borrow_for_region_in_pred type_infos
                  keep_region output.ty
              then
                let ctx, e = add_symbolic ctx proj.sv_id output.ty in
                (ctx, Some e)
              else
                let pat =
                  if filter then None
                  else
                    let ty = ctx_translate_fwd_ty ctx output.ty in
                    Some (mk_dummy_pattern ty)
                in
                (ctx, pat)
        end
    | V.EAdt { variant_id; field_values } -> begin
        let ctx, out =
          gtranslate_adt_fields ~project_borrows:true
            (fun ~filter ctx v ->
              let ctx, pat = to_pat ~filter ctx v in
              ( ctx,
                match pat with
                | None -> None
                | Some x -> Some ((), x) ))
            (compute_tevalue_proj_kind ctx.span ctx.type_ctx.type_infos rids)
            (fun fields ->
              let ty =
                translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos
                  output.ty
              in
              mk_adt_pattern ty variant_id fields)
            mk_simpl_tuple_pattern ~filter ctx output output.ty field_values
        in
        (ctx, Option.map snd out)
      end
    | V.EIgnored -> (ctx, None)
  in
  let ctx, pat = to_pat ~filter:true ctx output in
  let pat =
    match pat with
    | None -> mk_dummy_pattern mk_unit_ty
    | Some pat -> pat
  in
  let bound = { concrete = !concrete; symbolic = !symbolic } in
  (ctx, bound, pat)

let tepat_to_tpattern (ctx : bs_ctx)
    (fvar_to_texpr : texpr V.AbsFVarId.Map.t ref) (rids : T.RegionId.Set.t)
    (pat : V.tepat) : bs_ctx * tpattern =
  let span = ctx.span in
  let type_infos = ctx.type_ctx.type_infos in
  let keep_region (r : T.region) =
    match r with
    | T.RVar (Free rid) -> T.RegionId.Set.mem rid rids
    | _ -> false
  in
  let rec to_pat ~(filter : bool) (ctx : bs_ctx) (pat : V.tepat) :
      bs_ctx * tpattern option =
    match pat.epat with
    | V.POpen fid ->
        abs_fvar_id_to_tpattern ctx fvar_to_texpr rids ~filter fid pat.epat_ty
    | V.PBound ->
        (* Binders should have been opened *)
        [%internal_error] span
    | V.PAdt (variant_id, fields) -> begin
        (* Note that the [project_borrows] field doesn't matter *)
        let project_borrows = true in
        let compute_proj_kind (pat : V.tepat) : tavalue_kind =
          if
            TypesUtils.ty_has_mut_borrow_for_region_in_pred type_infos
              keep_region pat.epat_ty
          then BorrowProj BMut
          else BorrowProj BShared
        in
        let ctx, out =
          gtranslate_adt_fields ~project_borrows
            (fun ~filter ctx v ->
              let ctx, pat = to_pat ~filter ctx v in
              (ctx, Option.map (fun x -> ((), x)) pat))
            compute_proj_kind
            (fun fields ->
              let ty =
                translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos
                  pat.epat_ty
              in
              mk_adt_pattern ty variant_id fields)
            mk_simpl_tuple_pattern ~filter ctx pat pat.epat_ty fields
        in
        let out = Option.map snd out in
        (ctx, out)
      end
    | V.PIgnored -> (ctx, None)
  in
  let ctx, pat = to_pat ~filter:true ctx pat in
  let pat =
    match pat with
    | Some pat -> pat
    | None -> mk_dummy_pattern mk_unit_ty
  in
  (ctx, pat)

(** The boolean is [can_fail] (i.e., does the expression live in the error
    monad?).

    [bound_inputs]: see the doc of [bound_inputs] *)
let einput_to_texpr (ctx : bs_ctx) (ectx : C.eval_ctx) (rids : T.RegionId.Set.t)
    (bound_inputs : bound_borrows_loans)
    (fvar_to_texpr : texpr V.AbsFVarId.Map.t ref) (input : V.tevalue) :
    bs_ctx * bool * texpr =
  let span = ctx.span in
  let rec to_texpr ~(filter : bool) (rids : T.RegionId.Set.t) (ctx : bs_ctx)
      (input : V.tevalue) : bs_ctx * bool * texpr option =
    match input.value with
    | V.ELet (rids', pat, bound, next) ->
        (* Open the binders *)
        let pat, next = ValuesUtils.open_binder span pat next in
        (* Translate *)
        let ctx, bound_can_fail, bound =
          to_texpr ~filter:false rids' ctx bound
        in
        let ctx, pat = tepat_to_tpattern ctx fvar_to_texpr rids pat in
        let ctx, next_can_fail, next = to_texpr ~filter:false rids ctx next in
        (* Create the let binding *)
        let bound =
          match bound with
          | None -> mk_unit_texpr
          | Some bound -> bound
        in
        let next =
          match next with
          | None -> mk_unit_texpr
          | Some next -> next
        in
        let next =
          if bound_can_fail && not next_can_fail then
            mk_result_ok_texpr span next
          else next
        in
        let e =
          mk_closed_checked_let __FILE__ __LINE__ ctx false pat bound next
        in
        let can_fail = bound_can_fail || next_can_fail in
        (ctx, can_fail, Some e)
    | V.EJoinMarkers _ | V.EBVar _ ->
        (* - joins should have been eliminated
           - there should be no bound variables *)
        [%internal_error] span
    | V.EFVar fvid ->
        let e = V.AbsFVarId.Map.find_opt fvid !fvar_to_texpr in
        (ctx, false, e)
    | V.EApp (f, args) ->
        let ctx, args =
          List.fold_left_map
            (fun ctx arg ->
              let ctx, can_fail, arg = to_texpr ~filter:false rids ctx arg in
              [%sanity_check] span (not can_fail);
              (ctx, arg))
            ctx args
        in
        let args = List.filter_map (fun x -> x) args in
        begin
          match f with
          | V.EOutputAbs _ | V.EInputAbs _ ->
              (* Those shouln't get merged *)
              [%internal_error] span
          | V.EFunCall (call_id, rg_id) ->
              let call_info = V.FunCallId.Map.find call_id ctx.calls in
              let call = call_info.forward in
              let fun_id =
                match call.call_id with
                | S.Fun (fun_id, _) -> fun_id
                | Unop _ | Binop _ ->
                    (* Those don't have backward functions *)
                    [%craise] ctx.span "Unreachable"
              in
              let effect_info =
                get_fun_effect_info ctx fun_id None (Some rg_id)
              in
              let can_fail = effect_info.can_fail in
              (* Lookup the variable introduced for the backward function *)
              let func =
                RegionGroupId.Map.find rg_id (Option.get call_info.back_funs)
              in
              let e =
                begin
                  match func with
                  | None ->
                      [%sanity_check] span (args = []);
                      None
                  | Some func -> Some (mk_apps span func args)
                end
              in
              (ctx, can_fail, e)
          | V.ELoop (abs_id, _lid, _rg_id) ->
              (* Lookup the variable introduced for the backward function *)
              let e =
                match
                  V.AbstractionId.Map.find_opt abs_id ctx.abs_id_to_fvar
                with
                | None ->
                    [%sanity_check] span
                      (V.AbstractionId.Set.mem abs_id ctx.ignored_abs_ids);
                    None
                | Some f -> Some (mk_apps span f args)
              in
              let can_fail = false in
              (ctx, can_fail, e)
        end
    | V.EAdt { variant_id; field_values } -> begin
        let ctx, out =
          gtranslate_adt_fields ~project_borrows:false
            (fun ~filter ctx v ->
              let ctx, can_fail, e = to_texpr ~filter rids ctx v in
              (ctx, Option.map (fun x -> (can_fail, x)) e))
            (compute_tevalue_proj_kind ctx.span ctx.type_ctx.type_infos rids)
            (fun fields ->
              let ty =
                translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos
                  input.ty
              in
              mk_adt_texpr span ty variant_id fields)
            (mk_simpl_tuple_texpr span)
            ~filter ctx input input.ty field_values
        in
        match out with
        | None -> (ctx, false, None)
        | Some (can_fail, x) ->
            [%sanity_check] span (List.for_all (fun x -> not x) can_fail);
            (ctx, false, Some x)
      end
    | V.ELoan lc -> (
        match lc with
        | V.EMutLoan (pm, lid, child) ->
            [%sanity_check] span (pm = PNone);
            [%sanity_check] span (ValuesUtils.is_eignored child.value);
            let e =
              [%unwrap_with_span] span
                (V.BorrowId.Map.find_opt lid bound_inputs.concrete)
                "Unexpected"
            in
            (ctx, false, Some e)
        | V.EEndedMutLoan _ | V.EIgnoredMutLoan _ | V.EEndedIgnoredMutLoan _ ->
            [%internal_error] span)
    | V.EBorrow _ -> [%internal_error] span
    | V.ESymbolic (pm, proj) -> begin
        [%sanity_check] span (pm = PNone);
        match proj with
        | V.EProjLoans { proj = { sv_id; proj_ty }; consumed; borrows } ->
            [%sanity_check] span (consumed = []);
            [%sanity_check] span (borrows = []);
            let norm_proj_ty =
              InterpreterBorrowsCore.normalize_proj_ty rids proj_ty
            in
            let e =
              NormSymbProjMap.find_opt { sv_id; norm_proj_ty }
                bound_inputs.symbolic
            in
            (ctx, false, e)
        | V.EProjBorrows _
        | V.EEndedProjLoans _
        | V.EEndedProjBorrows _
        | V.EEmpty -> [%internal_error] span
      end
    | V.EValue (env, mv) ->
        let e = tvalue_to_texpr ctx { ectx with env } mv in
        (ctx, false, Some e)
    | V.EIgnored -> (ctx, false, None)
    | V.EBottom -> [%internal_error] span
  in
  let ctx, can_fail, e = to_texpr ~filter:false rids ctx input in
  let e =
    match e with
    | None -> mk_unit_texpr
    | Some e -> e
  in
  (ctx, can_fail, e)

(** Go through some avalues to register the inputs (i.e., the borrows).

    We need this to fix the order of the *inputs*: the *avalues* act as a
    function signature, while the order of the borrows inside the *evalues* is
    arbitrary. *)
let register_inputs (ctx : bs_ctx) (rids : T.RegionId.Set.t)
    (avl : V.tavalue list) : bound_borrows_loans * fvar list =
  let span = ctx.span in
  let type_infos = ctx.type_ctx.type_infos in
  let concrete = ref V.BorrowId.Map.empty in
  let symbolic = ref NormSymbProjMap.empty in
  let ctx = ref ctx in
  let fvars = ref [] in
  let keep_region (r : T.region) =
    match r with
    | T.RVar (Free rid) -> T.RegionId.Set.mem rid rids
    | _ -> false
  in
  let fresh_fvar (ty : T.ty) : texpr =
    let ctx', fvar = fresh_var_llbc_ty None ty !ctx in
    ctx := ctx';
    fvars := fvar :: !fvars;
    mk_texpr_from_fvar fvar
  in
  let add_symbolic (sv_id : SymbolicValueId.id) (proj_ty : T.ty) : unit =
    let e = fresh_fvar proj_ty in
    let norm_proj_ty = InterpreterBorrowsCore.normalize_proj_ty rids proj_ty in
    symbolic := NormSymbProjMap.add { sv_id; norm_proj_ty } e !symbolic
  in
  let add_concrete (bid : V.BorrowId.id) (ty : T.ty) : unit =
    let e = fresh_fvar ty in
    concrete := V.BorrowId.Map.add bid e !concrete
  in
  let rec register (av : V.tavalue) : unit =
    match av.value with
    | V.AAdt { variant_id = _; field_values } -> List.iter register field_values
    | V.ALoan lc -> (
        match lc with
        | V.AMutLoan (pm, bid, child) ->
            [%sanity_check] span (pm = PNone);
            add_concrete bid av.ty;
            register child
        | V.ASharedLoan (pm, _, _, child) ->
            [%sanity_check] span (pm = PNone);
            register child
        | V.AIgnoredMutLoan (_, child) | V.AIgnoredSharedLoan child ->
            register child
        | V.AEndedMutLoan _ | V.AEndedSharedLoan _ | V.AEndedIgnoredMutLoan _ ->
            [%internal_error] span)
    | V.ABorrow bc -> (
        match bc with
        | V.AMutBorrow (_, _, child) | V.AIgnoredMutBorrow (_, child) ->
            register child
        | V.ASharedBorrow (_, _, _)
        | V.AEndedMutBorrow _
        | V.AEndedSharedBorrow
        | V.AEndedIgnoredMutBorrow _ -> [%internal_error] span
        | V.AProjSharedBorrow _ -> ())
    | V.ASymbolic (pm, proj) -> (
        [%sanity_check] span (pm = PNone);
        match proj with
        | V.AProjLoans { proj = { sv_id; proj_ty }; consumed; borrows } ->
            [%sanity_check] span (consumed = []);
            [%sanity_check] span (borrows = []);
            if
              TypesUtils.ty_has_mut_borrow_for_region_in_pred type_infos
                keep_region av.ty
            then add_symbolic sv_id proj_ty
            else ()
        | V.AProjBorrows { proj = _; loans } ->
            [%sanity_check] span (loans = []);
            ()
        | V.AEndedProjLoans _ | V.AEndedProjBorrows _ | V.AEmpty ->
            [%internal_error] span)
    | V.ABottom | V.AIgnored _ -> ()
  in
  List.iter register avl;
  ({ concrete = !concrete; symbolic = !symbolic }, List.rev !fvars)

(** Given some bound outputs, go through some avalues to sort those outputs in
    the order given by the avalues.

    The goal is similar to [register_inputs]: we want to use avalues as a
    function signature.

    TODO: we shouldn't do this. The avalues should be independent from the
    function signature. The signature should be contained within the abstraction
    continuation. *)
let register_outputs (ctx : bs_ctx) (bound_outputs : bound_borrows_loans)
    (rids : T.RegionId.Set.t) (avl : V.tavalue list) : texpr list =
  [%ltrace
    "- bound_outputs:\n"
    ^ bound_borrows_loans_to_string ctx bound_outputs
    ^ "- avl:\n"
    ^ Print.list_to_string (SymbolicToPureCore.tavalue_to_string ctx) avl];
  let span = ctx.span in
  let type_infos = ctx.type_ctx.type_infos in
  let outputs = ref [] in
  let keep_region (r : T.region) =
    match r with
    | T.RVar (Free rid) -> T.RegionId.Set.mem rid rids
    | _ -> false
  in
  let add_symbolic (sv_id : SymbolicValueId.id) (proj_ty : T.ty) : unit =
    let norm_proj_ty = InterpreterBorrowsCore.normalize_proj_ty rids proj_ty in
    let e =
      NormSymbProjMap.find { sv_id; norm_proj_ty } bound_outputs.symbolic
    in
    outputs := e :: !outputs
  in
  let add_concrete (bid : V.BorrowId.id) : unit =
    let e = V.BorrowId.Map.find bid bound_outputs.concrete in
    outputs := e :: !outputs
  in
  let rec register (av : V.tavalue) : unit =
    match av.value with
    | V.AAdt { variant_id = _; field_values } -> List.iter register field_values
    | V.ALoan lc -> (
        match lc with
        | V.AMutLoan (pm, _, child) | V.ASharedLoan (pm, _, _, child) ->
            [%sanity_check] span (pm = PNone);
            register child
        | V.AIgnoredMutLoan (_, child) | V.AIgnoredSharedLoan child ->
            register child
        | V.AEndedMutLoan _ | V.AEndedSharedLoan _ | V.AEndedIgnoredMutLoan _ ->
            [%internal_error] span)
    | V.ABorrow bc -> (
        match bc with
        | V.AMutBorrow (pm, bid, child) ->
            [%sanity_check] span (pm = PNone);
            add_concrete bid;
            register child
        | V.AIgnoredMutBorrow (_, child) -> register child
        | V.ASharedBorrow (_, _, _)
        | V.AEndedMutBorrow _
        | V.AEndedSharedBorrow
        | V.AEndedIgnoredMutBorrow _ -> [%internal_error] span
        | V.AProjSharedBorrow _ -> ())
    | V.ASymbolic (pm, proj) -> (
        [%sanity_check] span (pm = PNone);
        match proj with
        | V.AProjLoans { proj = _; consumed; borrows } ->
            [%sanity_check] span (consumed = []);
            [%sanity_check] span (borrows = [])
        | V.AProjBorrows { proj = { sv_id; proj_ty }; loans } ->
            [%sanity_check] span (loans = []);
            if
              TypesUtils.ty_has_mut_borrow_for_region_in_pred type_infos
                keep_region av.ty
            then add_symbolic sv_id proj_ty
            else ()
        | V.AEndedProjLoans _ | V.AEndedProjBorrows _ | V.AEmpty ->
            [%internal_error] span)
    | V.ABottom | V.AIgnored _ -> ()
  in
  List.iter register avl;
  List.rev !outputs

let abs_cont_to_texpr_aux (ctx : bs_ctx) (ectx : C.eval_ctx) (abs : V.abs)
    (output : V.tevalue) (input : V.tevalue) : texpr option =
  let span = ctx.span in
  (* Go through the *avalues* to introduce free variables for the loans:
     we need to do this to fix the order of the *inputs* (the order given
     by the abstraction expression itself is arbitrary)
  *)
  let bound_inputs, inputs =
    register_inputs ctx abs.regions.owned abs.avalues
  in

  (* Translate the abstraction expression *)
  let fvar_to_texpr = ref V.AbsFVarId.Map.empty in
  let ctx, can_fail, input_e =
    einput_to_texpr ctx ectx abs.regions.owned bound_inputs fvar_to_texpr input
  in
  [%sanity_check] span (not can_fail);
  let ctx, bound_outputs, pat =
    eoutput_to_pat ctx fvar_to_texpr abs.regions.owned output
  in

  (* Go through the *avalues* to compute the order of the *outputs*. Same remark
     as with the inputs: we do this to fix the order *)
  let outputs =
    register_outputs ctx bound_outputs abs.regions.owned abs.avalues
  in

  if inputs = [] && outputs = [] then None
  else
    (* Put everything together *)
    let output_e = mk_simpl_tuple_texpr span outputs in
    let e =
      mk_closed_checked_let __FILE__ __LINE__ ctx can_fail pat input_e output_e
    in
    let e =
      mk_closed_lambdas span
        (List.map (fun fv -> mk_tpattern_from_fvar fv None) inputs)
        e
    in
    Some e

(** Translate the continuation of a region abstraction to a pure continuation.

    Returns [None] if the continuation has type [unit] (i.e., it consumes
    nothing and returns nothing). *)
let translate_abs_to_cont (ctx : bs_ctx) (ectx : C.eval_ctx) (abs : V.abs) :
    texpr option =
  [%ltrace "abs:\n" ^ abs_to_string ctx abs];
  match abs.cont with
  | None -> [%internal_error] ctx.span
  | Some cont -> (
      match (cont.output, cont.input) with
      | Some output, Some input ->
          abs_cont_to_texpr_aux ctx ectx abs output input
      | _ -> [%internal_error] ctx.span)
