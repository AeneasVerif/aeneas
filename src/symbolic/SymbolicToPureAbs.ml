open LlbcAstUtils
open Pure
open PureUtils
open FunsAnalysis
open TypesAnalysis
open InterpreterUtils
open SymbolicToPureCore
open SymbolicToPureTypes
open SymbolicToPureValues

(** Explore an abstraction value and compute the type of the value consumed upon
    ending the loans. *)
let rec tavalue_to_consumed_ty_aux ~(filter : bool) (ctx : bs_ctx)
    (abs_regions : T.RegionId.Set.t) (av : V.tavalue) : ty option =
  match av.value with
  | AAdt adt_v -> adt_avalue_to_consumed_ty_aux ~filter ctx abs_regions av adt_v
  | ABottom -> [%craise] ctx.span "Unreachable"
  | ALoan lc ->
      aloan_content_to_consumed_ty_aux ~filter ctx abs_regions av.ty lc
  | ABorrow _ ->
      (* This value should have been generated by a loan projector: there
           can't be aborrows unless there are nested borrows, which are not
           supported yet. *)
      [%craise] ctx.span "Unreachable"
  | ASymbolic (pm, aproj) ->
      [%sanity_check] ctx.span (pm = PNone);
      aproj_to_consumed_ty_aux ctx abs_regions aproj av.ty
  | AIgnored _ ->
      if filter then None
      else
        (* If we do not filter it means we are inside an ADT. *)
        Some (ctx_translate_fwd_ty ctx av.ty)

and adt_avalue_to_consumed_ty_aux ~(filter : bool) (ctx : bs_ctx)
    (abs_regions : T.RegionId.Set.t) (av : V.tavalue) (adt_v : V.adt_avalue) :
    ty option =
  (* We do not do the same thing depending on whether we visit a tuple
     or a "regular" ADT *)
  let adt_id, _ = TypesUtils.ty_as_adt av.ty in
  (* Check if the ADT contains borrows *)
  match
    compute_tavalue_proj_kind ctx.span ctx.type_ctx.type_infos abs_regions av
  with
  | BorrowProj _ -> [%craise] ctx.span "Unreachable"
  | UnknownProj ->
      (* If we filter: ignore the value.
         Otherwise, translate everything. *)
      if filter then None
      else begin
        match adt_id with
        | TAdtId _ | TBuiltin (TBox | TArray | TSlice | TStr) ->
            Some
              (translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos av.ty)
        | TTuple ->
            let fields =
              List.map
                (tavalue_to_consumed_ty_aux ~filter ctx abs_regions)
                adt_v.field_values
            in
            let fields = List.map Option.get fields in
            Some (mk_simpl_tuple_ty fields)
      end
  | LoanProj borrow_kind -> begin
      (* Translate the field values *)
      let field_types =
        let filter =
          filter
          &&
          match adt_id with
          | TTuple | TBuiltin TBox -> true
          | TBuiltin _ | TAdtId _ -> borrow_kind = BShared
        in
        List.map
          (tavalue_to_consumed_ty_aux ~filter ctx abs_regions)
          adt_v.field_values
      in
      match adt_id with
      | TAdtId _ ->
          (* We should preserve all the fields *)
          Some (translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos av.ty)
      | TBuiltin TBox -> begin
          (* The box type becomes the identity in the translation *)
          match field_types with
          | [ v ] -> v
          | _ -> [%craise] ctx.span "Unreachable"
        end
      | TBuiltin (TArray | TSlice | TStr) ->
          (* This case is unreachable:
             - for array and slice: in order to access one of their elements
               we need to go through an index function
             - for strings: the [str] is not polymorphic.
          *)
          [%craise] ctx.span "Unreachable"
      | TTuple ->
          (* If the filtering is activated, we ignore the fields which do not
             consume values (i.e., which do not contain ended mutable borrows). *)
          if filter then
            let field_types = List.filter_map (fun x -> x) field_types in
            if field_types = [] then None
            else
              (* Note that if there is exactly one field value,
               * [mk_simpl_tuple_rvalue] is the identity *)
              Some (mk_simpl_tuple_ty field_types)
          else
            (* If we do not filter the fields, all the types should be [Some ...] *)
            let field_types = List.map Option.get field_types in
            Some (mk_simpl_tuple_ty field_types)
    end

and aloan_content_to_consumed_ty_aux ~(filter : bool) (ctx : bs_ctx)
    (_abs_regions : T.RegionId.Set.t) (ty : T.ty) (lc : V.aloan_content) :
    ty option =
  let _ = filter in
  match lc with
  | AMutLoan (pm, _, child) ->
      [%sanity_check] ctx.span (pm = PNone);
      [%sanity_check] ctx.span (ValuesUtils.is_aignored child.value);
      Some (ctx_translate_fwd_ty ctx ty)
  | ASharedLoan (_, _, _, _) -> [%craise] ctx.span "Unreachable"
  | AEndedMutLoan _ | AEndedSharedLoan _ ->
      (* We shouldn't compute the type of a region abstraction if it contains ended loans *)
      [%craise] ctx.span "Unreachable"
  | AIgnoredMutLoan (_, _) ->
      (* There can be *inner* not ended mutable loans, but not outer ones *)
      [%craise] ctx.span "Unreachable"
  | AEndedIgnoredMutLoan _ ->
      (* This happens with nested borrows: we need to dive in *)
      [%craise] ctx.span "Unimplemented"
  | AIgnoredSharedLoan _ ->
      (* This case only happens with nested borrows *)
      [%craise] ctx.span "Unimplemented"

and aproj_to_consumed_ty_aux (ctx : bs_ctx) (_abs_regions : T.RegionId.Set.t)
    (aproj : V.aproj) (_ty : T.ty) : ty option =
  match aproj with
  | V.AProjLoans { proj; consumed; borrows } ->
      [%sanity_check] ctx.span (consumed = []);
      [%sanity_check] ctx.span (borrows = []);
      Some (ctx_translate_fwd_ty ctx proj.proj_ty)
  | V.AEndedProjLoans _ | AEndedProjBorrows _ | AEmpty | AProjBorrows _ ->
      [%craise] ctx.span "Unreachable"

let tavalue_to_consumed_ty (ctx : bs_ctx) (ectx : C.eval_ctx)
    (abs_regions : T.RegionId.Set.t) (av : V.tavalue) : ty option =
  (* Check if the value was generated from a loan projector: if yes, and if
     it contains mutable loans, then we generate a consumed value (because
     upon ending the borrow we consumed a value).
     Otherwise we ignore it. *)
  [%ltrace tavalue_to_string ~with_ended:true ectx av];
  match
    compute_tavalue_proj_kind ctx.span ctx.type_ctx.type_infos abs_regions av
  with
  | LoanProj BMut ->
      [%ltrace "the value contains mutable loan projectors"];
      tavalue_to_consumed_ty_aux ~filter:true ctx abs_regions av
  | LoanProj BShared | BorrowProj _ | UnknownProj ->
      (* If it is a borrow proj we ignore it. If it is an unknown projection,
         it means the value doesn't contain loans nor borrows, so nothing
         is consumed upon ending the abstraction: we can ignore it as well. *)
      [%ltrace
        "the value doesn't contains mutable loan projectors (ignoring it)"];
      None

let rec tavalue_to_given_back_ty_aux ~(filter : bool)
    (abs_regions : T.RegionId.Set.t) (av : V.tavalue) (ctx : bs_ctx) : ty option
    =
  match av.value with
  | AAdt adt_v ->
      adt_avalue_to_given_back_ty_aux ~filter abs_regions av adt_v ctx
  | ABottom -> [%craise] ctx.span "Unreachable"
  | ALoan _ ->
      (* The avalue should have been generated by a borrow projector: this case is unreachable *)
      [%craise] ctx.span "Unreachable"
  | ABorrow bc -> aborrow_content_to_given_back_ty_aux ~filter bc av.ty ctx
  | ASymbolic (pm, aproj) ->
      [%sanity_check] ctx.span (pm = PNone);
      aproj_to_given_back_ty_aux aproj av.ty ctx
  | AIgnored _ ->
      if filter then None
      else Some (translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos av.ty)

and adt_avalue_to_given_back_ty_aux ~(filter : bool)
    (abs_regions : T.RegionId.Set.t) (av : V.tavalue) (adt_v : V.adt_avalue)
    (ctx : bs_ctx) : ty option =
  (* Check if the ADT contains borrows *)
  match
    compute_tavalue_proj_kind ctx.span ctx.type_ctx.type_infos abs_regions av
  with
  | LoanProj _ -> [%craise] ctx.span "Unreachable"
  | UnknownProj ->
      (* If we filter: ignore the pattern.
         Otherwise, return a dummy value. *)
      if filter then None
      else Some (translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos av.ty)
  | BorrowProj borrow_kind -> begin
      (* We do not do the same thing depending on whether we visit a tuple
         or a "regular" ADT *)
      let adt_id, _ = TypesUtils.ty_as_adt av.ty in
      (* Translate the field values *)
      (* For now we forget the meta-place information so that it doesn't get used
         by several fields (which would then all have the same name...), but we
         might want to do something smarter *)
      let field_types =
        let filter =
          filter
          &&
          match adt_id with
          | TTuple | TBuiltin TBox -> true
          | TBuiltin _ | TAdtId _ -> borrow_kind = BShared
        in
        List.map
          (fun fv -> tavalue_to_given_back_ty_aux ~filter abs_regions fv ctx)
          adt_v.field_values
      in
      match adt_id with
      | TAdtId _ ->
          Some (translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos av.ty)
      | TBuiltin TBox -> begin
          (* The box type becomes the identity in the translation *)
          match field_types with
          | [ pat ] -> pat
          | _ -> [%craise] ctx.span "Unreachable"
        end
      | TBuiltin (TArray | TSlice | TStr) ->
          (* This case is unreachable:
             - for array and slice: in order to access one of their elements
               we need to go through an index function
             - for strings: the [str] is not polymorphic.
          *)
          [%craise] ctx.span "Unreachable"
      | TTuple ->
          (* Sanity checks *)
          let variant_id = adt_v.variant_id in
          [%sanity_check] ctx.span (variant_id = None);
          (* If the filtering is activated, we ignore the fields which do not
             give values back (i.e., which do not contain mutable borrows). *)
          if filter then
            let field_types = List.filter_map (fun x -> x) field_types in
            if field_types = [] then None
            else
              (* Note that if there is exactly one field value, [mk_simpl_tuple_pattern]
               * is the identity *)
              Some (mk_simpl_tuple_ty field_types)
          else
            (* If we do not filter the fields, all the patterns should be [Some ...] *)
            let field_types = List.map Option.get field_types in
            Some (mk_simpl_tuple_ty field_types)
    end

and aborrow_content_to_given_back_ty_aux ~(filter : bool)
    (bc : V.aborrow_content) (ty : T.ty) (ctx : bs_ctx) : ty option =
  match bc with
  | V.AMutBorrow _ ->
      Some (translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos ty)
  | ASharedBorrow _ ->
      if filter then None
      else Some (translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos ty)
  | AIgnoredMutBorrow _ ->
      (* Can happen in case of nested borrows, ignoring for now *)
      [%craise] ctx.span "Unimplemented"
  | AEndedMutBorrow _
  | AEndedIgnoredMutBorrow _
  | AEndedSharedBorrow
  | AProjSharedBorrow _ -> [%craise] ctx.span "Unreachable"

and aproj_to_given_back_ty_aux (aproj : V.aproj) (ty : T.ty) (ctx : bs_ctx) :
    ty option =
  match aproj with
  | V.AProjBorrows { proj = _; loans } ->
      [%sanity_check] ctx.span (loans = []);
      Some (translate_fwd_ty (Some ctx.span) ctx.type_ctx.type_infos ty)
  | V.AEndedProjLoans _ | AEndedProjBorrows _ | AEmpty | AProjLoans _ ->
      [%craise] ctx.span "Unreachable"

let tavalue_to_given_back_ty (ctx : bs_ctx) (abs_regions : T.RegionId.Set.t)
    (v : V.tavalue) : ty option =
  (* Check if the value was generated from a borrow projector: if yes, and if
     it contains mutable borrows we generate a given back pattern (because
     upon ending the borrow the abstraction gave back a value).
     Otherwise we ignore it. *)
  match
    compute_tavalue_proj_kind ctx.span ctx.type_ctx.type_infos abs_regions v
  with
  | BorrowProj BMut ->
      tavalue_to_given_back_ty_aux abs_regions ~filter:true v ctx
  | BorrowProj BShared | LoanProj _ | UnknownProj ->
      (* If it is a loan proj we ignore it. If it is an unknown projection,
         it means the value doesn't contain loans nor borrows, so nothing
         is given back: we can ignore it as well. *)
      None

(** Compute the type of a region abstraction, seen as a continuation.

    Remark: there shouldn't be any ended loans in this continuation. Also note
    that we flatten the values. *)
let abs_to_input_output_tys (ctx : bs_ctx) (ectx : C.eval_ctx) (abs : V.abs) :
    ty list * ty list =
  let inputs =
    List.filter_map
      (tavalue_to_consumed_ty ctx ectx abs.regions.owned)
      abs.avalues
  in

  let outputs =
    List.filter_map (tavalue_to_given_back_ty ctx abs.regions.owned) abs.avalues
  in

  (inputs, outputs)

(** Compute the type of a region abstraction, seen as a continuation.

    Remark: there shouldn't be any ended loans in this continuation. Also note
    that we flatten the values. *)
let abs_to_ty (ctx : bs_ctx) (ectx : C.eval_ctx) (abs : V.abs) : ty =
  let inputs, outputs = abs_to_input_output_tys ctx ectx abs in
  mk_arrows inputs (mk_simpl_tuple_ty outputs)

let compute_tevalue_proj_kind span type_infos (abs_regions : T.RegionId.Set.t)
    (ev : V.tevalue) : tavalue_kind =
  let has_borrows = ref false in
  let has_mut_borrows = ref false in
  let has_loans = ref false in
  let has_mut_loans = ref false in
  let keep_region (r : T.region) =
    match r with
    | T.RVar (Free rid) -> T.RegionId.Set.mem rid abs_regions
    | _ -> false
  in
  let visitor =
    object
      inherit [_] V.iter_tavalue as super

      method! visit_tevalue _ ev =
        (* Remember the type of the current value *)
        super#visit_tevalue ev.ty ev

      method! visit_ELoan env lc =
        has_loans := true;
        begin
          match lc with
          | EIgnoredMutLoan _ | EEndedIgnoredMutLoan _ -> ()
          | EMutLoan _ | EEndedMutLoan _ -> has_mut_loans := true
        end;
        (* Continue exploring as a sanity check: we want to make sure we don't find borrows *)
        super#visit_ELoan env lc

      method! visit_EBorrow env bc =
        has_borrows := true;
        begin
          match bc with
          | EIgnoredMutBorrow _ | EEndedIgnoredMutBorrow _ -> ()
          | EMutBorrow _ | EEndedMutBorrow _ -> has_mut_borrows := true
        end;
        (* Continue exploring as a sanity check: we want to make sure we don't find loans *)
        super#visit_EBorrow env bc

      method! visit_ESymbolic ty pm eproj =
        [%sanity_check] span (pm = PNone);
        match eproj with
        | V.EEndedProjLoans _ ->
            has_loans := true;
            (* We need to check wether the projected loans are mutable or not *)
            if
              TypesUtils.ty_has_mut_borrow_for_region_in_pred type_infos
                keep_region ty
            then has_mut_loans := true;
            (* Continue exploring (same reasons as above) *)
            super#visit_ESymbolic ty pm eproj
        | EProjLoans _ ->
            has_loans := true;
            (* Continue exploring (same reasons as above) *)
            super#visit_ESymbolic ty pm eproj
        | EEndedProjBorrows _ ->
            has_borrows := true;
            (* We need to check wether the projected borrows are mutable or not *)
            if
              TypesUtils.ty_has_mut_borrow_for_region_in_pred type_infos
                keep_region ty
            then has_mut_borrows := true;
            (* Continue exploring (same reasons as above) *)
            super#visit_ESymbolic ty pm eproj
        | EProjBorrows _ ->
            has_borrows := true;
            (* Continue exploring (same reasons as above) *)
            super#visit_ESymbolic ty pm eproj
        | EEmpty ->
            (* Continue exploring (same reasons as above) *)
            super#visit_ESymbolic ty pm eproj
    end
  in
  visitor#visit_tevalue ev.ty ev;
  [%cassert] span ((not !has_borrows) || not !has_loans) "Unreachable";
  let to_borrow_kind b = if b then BMut else BShared in
  if !has_borrows then BorrowProj (to_borrow_kind !has_mut_borrows)
  else if !has_loans then LoanProj (to_borrow_kind !has_mut_loans)
  else UnknownProj

(** We need [fvar_to_texpr] because variables may be bound inside intermediate
    let-bindings inside the region abstraction continuation, so we need to
    remember by which pure expression we translated the abstraction free
    variable, in case it is used later. *)
let eoutput_to_pat (ctx : bs_ctx) (fvar_to_texpr : texpr V.AbsFVarId.Map.t ref)
    (fvar_to_none : V.AbsFVarId.Set.t ref) (rids : T.RegionId.Set.t)
    (output : V.tevalue) : bs_ctx * tpattern =
  let span = ctx.span in
  let type_infos = ctx.type_ctx.type_infos in
  let keep_region (r : T.region) =
    match r with
    | T.RVar (Free rid) -> T.RegionId.Set.mem rid rids
    | _ -> false
  in
  let rec to_pat ~(filter : bool) (ctx : bs_ctx) (output : V.tevalue) :
      bs_ctx * tpattern option =
    match output.value with
    | V.ELet _
    | V.EJoinMarkers _
    | V.EBVar _
    | V.EApp _
    | V.EBottom
    | V.EValue _
    | V.ELoan _ -> [%internal_error] span
    | V.EFVar afid ->
        if
          TypesUtils.ty_has_mut_borrow_for_region_in_pred type_infos keep_region
            output.ty
        then (
          let ctx, fvar = fresh_var_llbc_ty None output.ty ctx in
          fvar_to_texpr :=
            V.AbsFVarId.Map.add afid (mk_texpr_from_fvar fvar) !fvar_to_texpr;
          (ctx, Some (mk_tpattern_from_fvar fvar None)))
        else
          let pat =
            if filter then begin
              fvar_to_none := V.AbsFVarId.Set.add afid !fvar_to_none;
              None
            end
            else begin
              fvar_to_texpr :=
                V.AbsFVarId.Map.add afid mk_unit_texpr !fvar_to_texpr;
              let ty = ctx_translate_fwd_ty ctx output.ty in
              Some (mk_dummy_pattern ty)
            end
          in
          (ctx, pat)
    | V.EBorrow bc -> (
        match bc with
        | V.EIgnoredMutBorrow _
        | V.EEndedMutBorrow _
        | V.EEndedIgnoredMutBorrow _ -> [%internal_error] span
        | V.EMutBorrow (pm, _bid, _mv, child) ->
            [%sanity_check] span (pm = PNone);
            [%sanity_check] span (ValuesUtils.is_eignored child.value);
            let ctx, fvar = fresh_var_llbc_ty None output.ty ctx in
            (ctx, Some (mk_tpattern_from_fvar fvar None)))
    | V.ESymbolic (pm, proj) ->
        [%sanity_check] span (pm = PNone);
        begin
          match proj with
          | V.EProjLoans _
          | V.EEndedProjLoans _
          | V.EEndedProjBorrows _
          | V.EEmpty -> [%internal_error] span
          | V.EProjBorrows { proj = _; loans } ->
              [%sanity_check] span (loans = []);
              (* Case disjunction depending on whether we actually need to give back
             something or not *)
              if
                TypesUtils.ty_has_mut_borrow_for_region_in_pred type_infos
                  keep_region output.ty
              then
                let ctx, fvar = fresh_var_llbc_ty None output.ty ctx in
                (ctx, Some (mk_tpattern_from_fvar fvar None))
              else
                let pat =
                  if filter then None
                  else
                    let ty = ctx_translate_fwd_ty ctx output.ty in
                    Some (mk_dummy_pattern ty)
                in
                (ctx, pat)
        end
    | V.EAdt { variant_id = _; field_values } ->
        let filter =
          match compute_tevalue_proj_kind span type_infos rids output with
          | LoanProj _ -> [%internal_error] span
          | BorrowProj _ | UnknownProj -> false
        in
        let ctx, field_values =
          List.fold_left_map (to_pat ~filter) ctx field_values
        in
        let field_values = List.filter_map (fun x -> x) field_values in
        begin
          match field_values with
          | [] -> (ctx, None)
          | _ -> (ctx, Some (mk_simpl_tuple_pattern field_values))
        end
    | V.EIgnored _ -> (ctx, None)
  in
  let ctx, pat = to_pat ~filter:false ctx output in
  let pat =
    match pat with
    | None -> mk_dummy_pattern mk_unit_ty
    | Some pat -> pat
  in
  (ctx, pat)

let tepat_to_tpattern (ctx : bs_ctx)
    (fvar_to_texpr : texpr V.AbsFVarId.Map.t ref)
    (fvar_to_none : V.AbsFVarId.Set.t ref) (rids : T.RegionId.Set.t)
    (pat : V.tepat) : bs_ctx * tpattern =
  ()

(** The boolean is [can_fail] (i.e., does the expression live in the error
    monad?) *)
let rec einput_to_texpr_aux (ctx : bs_ctx) (ectx : C.eval_ctx)
    (rids : T.RegionId.Set.t) (input : V.tevalue) : bs_ctx * bool * texpr option
    =
  let span = ctx.span in
  let type_infos = ctx.type_ctx.type_infos in
  let keep_region (r : T.region) =
    match r with
    | T.RVar (Free rid) -> T.RegionId.Set.mem rid rids
    | _ -> false
  in
  (* Accumulating the inputs in the order we find them: we will use this
     to introduce the variables bound by the continuation *)
  let inputs = ref [] in
  let fvar_to_texpr = ref V.AbsFVarId.Map.empty in
  let fvar_to_none = ref V.AbsFVarId.Set.empty in
  let rec to_texpr ~(filter : bool) (rids : T.RegionId.Set.t) (ctx : bs_ctx)
      (input : V.tevalue) : bs_ctx * bool * texpr option =
    match input.value with
    | V.ELet (rids', pat, bound, next) ->
        (* Open the binders *)
        let pat, next = ValuesUtils.open_binder span pat next in
        (* Translate *)
        let ctx, bound_can_fail, bound =
          to_texpr ~filter:false rids' ctx bound
        in
        let ctx, pat =
          tepat_to_tpattern ctx fvar_to_texpr fvar_to_none rids pat
        in
        let ctx, next_can_fail, next = to_texpr ~filter:false rids ctx next in
        (* Create the let binding *)
        let bound =
          match bound with
          | None -> mk_unit_texpr
          | Some bound -> bound
        in
        let next =
          match next with
          | None -> mk_unit_texpr
          | Some next -> next
        in
        let next =
          if bound_can_fail && not next_can_fail then
            mk_result_ok_texpr span next
          else next
        in
        let e =
          mk_closed_checked_let __FILE__ __LINE__ ctx false pat bound next
        in
        let can_fail = bound_can_fail || next_can_fail in
        (ctx, can_fail, Some e)
    | V.EJoinMarkers _ | V.EBVar _ ->
        (* - joins should have been eliminated
           - there should be no bound variables *)
        [%internal_error] span
    | V.EFVar fvid ->
        let e =
          match V.AbsFVarId.Map.find_opt fvid !fvar_to_texpr with
          | None ->
              [%sanity_check] span (V.AbsFVarId.Set.mem fvid !fvar_to_none);
              None
          | Some e -> Some e
        in
        (ctx, false, e)
    | V.EApp (f, args) ->
        let ctx, args =
          List.fold_left_map
            (fun ctx arg ->
              let ctx, can_fail, arg = to_texpr ~filter:false rids ctx arg in
              [%sanity_check] span (not can_fail);
              (ctx, arg))
            ctx args
        in
        let args = List.filter_map (fun x -> x) args in
        begin
          match f with
          | V.EOutputAbs _ | V.EInputAbs _ ->
              (* Those shouln't get merged *)
              [%internal_error] span
          | V.EFunCall (call_id, rg_id) ->
              let call_info = V.FunCallId.Map.find call_id ctx.calls in
              let call = call_info.forward in
              let fun_id =
                match call.call_id with
                | S.Fun (fun_id, _) -> fun_id
                | Unop _ | Binop _ ->
                    (* Those don't have backward functions *)
                    [%craise] ctx.span "Unreachable"
              in
              let effect_info =
                get_fun_effect_info ctx fun_id None (Some rg_id)
              in
              let can_fail = effect_info.can_fail in
              (* Lookup the variable introduced for the backward function *)
              let func =
                RegionGroupId.Map.find rg_id (Option.get call_info.back_funs)
              in
              let e =
                begin
                  match func with
                  | None ->
                      [%sanity_check] span (args = []);
                      None
                  | Some func -> Some (mk_apps span func args)
                end
              in
              (ctx, can_fail, e)
          | V.ELoop (abs_id, lid, rg_id) ->
              (* Lookup the variable introduced for the backward function *)
              let e =
                match
                  V.AbstractionId.Map.find_opt abs_id ctx.abs_id_to_fvar
                with
                | None ->
                    [%sanity_check] span
                      (V.AbstractionId.Set.mem abs_id ctx.ignored_abs_ids);
                    None
                | Some f -> Some (mk_apps span f args)
              in
              (ctx, false, e)
        end
    | V.EAdt _ -> _
    | V.ELoan _ -> _
    | V.EBorrow _ -> [%internal_error] span
    | V.ESymbolic (_, _) -> _
    | V.EValue _ -> _
    | V.EIgnored _ -> _
    | V.EBottom -> [%internal_error] span
  in
  to_texpr ~filter:false rids ctx input

let abs_cont_to_texpr_aux (ctx : bs_ctx) (ectx : C.eval_ctx) (abs : V.abs)
    (output : V.tevalue) (input : V.tevalue) : bs_ctx * texpr =
  ()

let abs_cont_to_texpr (ctx : bs_ctx) (ectx : C.eval_ctx) (abs : V.abs)
    (cont : V.abs_cont) : bs_ctx * texpr =
  match abs.cont with
  | None -> [%internal_error] ctx.span
  | Some cont -> abs_cont_to_texpr_aux ctx ectx abs output input
