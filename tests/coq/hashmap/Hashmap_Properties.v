(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [hashmap]: function definitions *)
Require Import Primitives.
Import Primitives.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.
Local Open Scope Primitives_scope.
Require Export Hashmap_Types.
Import Hashmap_Types.
Require Export Hashmap_Funs.
Import Hashmap_Funs.
Require Import Lia.
Require Import Coq.Unicode.Utf8.
Require Import Coq.Program.Basics.
Require Import Coq.Program.Equality.
Require Import Coq.Logic.ProofIrrelevance.
Require Import Coq.Bool.Bool.

Module Hashmap_Properties.

(* Generic, intuitive utilities *)

Inductive i_int :=
  | _0 : i_int
  | _S : i_int -> i_int.

Fixpoint i_add (a b: i_int) : i_int :=
  match a with
  | _0    => b
  | _S a' => _S (i_add a' b)
  end.

Lemma i_add_zero_r a : i_add a _0 = a.
Proof.
induction a.
- reflexivity.
- simpl. now rewrite IHa.
Qed.

Lemma i_add_zero_r0 a : i_add a _0 = a.
auto. Admitted.

Global Hint Resolve i_add_zero_r: i_ints.

Lemma i_add_zero_r1 a : i_add a _0 = a.
auto with i_ints. Qed.

Lemma i_add_zero_r2 a : a = i_add a _0.
auto with i_ints. Qed.

Lemma i_add_zero_r3 a : i_add (i_add a _0) _0 = a.
auto with i_ints. Admitted.

Global Hint Rewrite i_add_zero_r0: i_ints.

Lemma i_add_sym x : i_add x _0 = i_add _0 x.
now autorewrite with i_ints. Qed.

Lemma j_add_zero_r1 a : i_add a _0 = a.
now autorewrite with i_ints. Qed.

Lemma j_add_zero_r2 a : a = i_add a _0.
now autorewrite with i_ints. Qed.

Lemma j_add_zero_r3 a : i_add (i_add a _0) _0 = a.
now autorewrite with i_ints. Qed.

Global Hint Resolve i_add_zero_r: core.

Lemma i_add_zero_r4 a : i_add a _0 = a.
auto. Qed.

(* Generic, intuitive utilities *)

Lemma neg_impl {A B: Prop} : (A -> B) -> ~B -> ~A.
intuition. Qed.

Lemma neg_equiv {A B: Prop} : A <-> B -> ~A <-> ~B.
apply not_iff_compat. Qed.

Lemma orb_dis {A B: bool} : (A || B) = false <-> A = false /\ B = false.
destruct A, B ; intuition.
Qed.

Lemma Zsucc_le_mono n m : n <= m -> n <= Z.succ m.
intuition. Qed.

Lemma Zpred_le_mono n m : n <= m -> Z.pred n <= m.
intuition. Qed.

Lemma Zle_antisym {n m} : (n <= m) <-> (m >= n).
intuition. Qed.

(* Utilities on top of Primitives *)

(* First, monadic utilities *)

Definition opt_to_res {T} (o: option T) : result T :=
    match o with
    | Some n => Return n
    | None   => Fail_ Failure
    end.

Definition fmap_res {A B} (x: result A) (f: A -> B) : result B :=
    x' <- x; Return (f x').

(* Vector utilities *)

(* Uses proof irrelevance so vector underlying lists can be equated *)
Lemma vec_list_inj {T} {a b: vec T} : (vec_to_list a = vec_to_list b) -> (a = b).
Proof.
destruct a, b.
apply ProofIrrelevanceTheory.subset_eq_compat.
Qed.

(* May be more clear as a lambda-term as it's a definition *)
Definition bounded_vec_push_back {T} (v: vec T) (x: T) (b: vec_length v < usize_max) : vec T.
Proof.
exists (x :: vec_to_list v).
simpl (length (x :: vec_to_list v)).
rewrite Nat2Z.inj_succ.
now apply (Zlt_le_succ _ _ b).
Defined.

(*
Lemma vec_push_success {T} (v: vec T) (x: T) (b: vec_length v < usize_max) :
  vec_push_back T v x = Return (bounded_vec_push_back v x b).
Proof.
remember (vec_push_back T v x) as W.
destruct W.
- f_equal
1: { unfold vec_push_back in HeqW. unfold bounded_vec_push_back. simpl. now exists v0. }

(* Contradiction from vec_push_back impl *)
exfalso.
unfold vec_push_back, vec_bind in Heqw.
set (l := vec_to_list v ++ x :: nil) in Heqw.
simpl in Heqw.
assert (Z.of_nat (length l) <= scalar_max Usize).
change l with (vec_to_list v ++ x :: nil).
rewrite app_length.
simpl.
rewrite Nat.add_1_r.
rewrite Nat2Z.inj_succ.
unfold vec_length in b.
now apply (Zlt_le_succ _ _ b).

remember (Sumbool.sumbool_of_bool (scalar_le_max Usize (Z.of_nat (length l)))) as s in Heqw.
destruct s.
- inversion Heqw.
- clear Heqs Heqw.
  apply (proj1 orb_dis) in e0.
  destruct e0.
  rewrite (proj2 (Z.leb_le _ _) H) in H1.
  inversion H1.
Qed.

Definition bounded_vec_push_back {T} (v: vec T) (x: T) (b: vec_length v < usize_max) : vec T :=
  exist _ (vec_to_list v :: x) ().
*)

(* Arithmetic utilities *)

(* Comparisons *)

(* Not sure if it works well, but we want to e.g. simpl constants *)
#[export]
Hint Unfold usize_to_nat : core.

(* Uses proof irrelevance so scalars with the same number can be equated *)
Lemma scalar_Z_inj {ty} {n m: scalar ty} : (to_Z n = to_Z m) -> (n = m).
Proof.
destruct m, n.
apply ProofIrrelevanceTheory.subset_eq_compat.
Qed.

(* Usize lemmas can be generalized for positive scalars *)
Lemma usize_nat_inj {n m: usize} : (usize_to_nat n = usize_to_nat m) -> (n = m).
Proof.
intro H.
unfold usize_to_nat in H.
apply Z2Nat.inj in H.
- apply scalar_Z_inj, H.
- apply (proj2_sig n).
- apply (proj2_sig m).
Qed.

(* It's a simple implication in "scalar_in_bounds_valid" *)
Lemma scalar_in_bounds_valid2 (ty: scalar_ty) (x: Z) :
  scalar_in_bounds ty x = true <-> scalar_min ty <= x <= scalar_max ty.
Proof.
split. now apply scalar_in_bounds_valid.
intro H.
unfold scalar_in_bounds, scalar_ge_min, scalar_le_max.
lia.
Qed.

(* This direct way of filling scalar may allow (relatively) simpler proofs *)
Definition mk_bounded_scalar ty (n: Z) (Hmin: scalar_min ty <= n) (Hmax: n <= scalar_max ty) : scalar ty :=
    exist _ n (conj Hmin Hmax).

Lemma mk_bounded_scalar_success ty (n: Z) (Hmin: scalar_min ty <= n) (Hmax: n <= scalar_max ty) :
    mk_scalar ty n = Return (mk_bounded_scalar ty n Hmin Hmax).
Proof.
unfold mk_scalar.
(* set (H := proj2 (scalar_in_bounds_valid2 ty n) (conj Hmin Hmax)).
   Ideally, want "now rewrite H" *)
remember (Sumbool.sumbool_of_bool (scalar_in_bounds ty n)) as b.
destruct b.
- now apply f_equal, scalar_Z_inj.
- exfalso.
  clear Heqb.
  rewrite (proj2 (scalar_in_bounds_valid2 ty n) (conj Hmin Hmax)) in e.
  inversion e.
Qed.

Definition bounded_scalar_succ {ty} (n: scalar ty) (p: to_Z n < scalar_max ty) : scalar ty :=
    let z := (to_Z n) in
    let p0 := Zsucc_le_mono (scalar_min ty) z (proj1 (proj2_sig n)) in
    let p1 := Zlt_le_succ z (scalar_max ty) p in
    mk_bounded_scalar _ (Z.succ z) p0 p1.

Lemma sc_succ_above_min {ty} (n: scalar ty) b : to_Z (bounded_scalar_succ n b) > scalar_min ty.
Proof.
assert (H := proj2_sig n).
simpl in *.
unfold to_Z.
lia.
Qed.

(* Should be generalized for any scalar *)
Lemma sc_succ_pred_eq (n: usize) {b} :
  usize_sub (bounded_scalar_succ n b) (1%usize) = Return n.
Proof.
unfold scalar_sub, usize_sub.
cut (to_Z (bounded_scalar_succ n b) - to_Z 1 %usize = to_Z n).
- intro H. rewrite H.
  assert (p := proj2_sig n).
  rewrite (mk_bounded_scalar_success Usize (to_Z n) (proj1 p) (proj2 p)).
  now apply f_equal, scalar_Z_inj.
- apply Z.pred_succ.
Qed.

Lemma mk_scalar_success (ty: scalar_ty) {n: Z} : (scalar_min ty <= n) -> (n <= scalar_max ty) -> ∃x, mk_scalar ty n = Return x.
Proof.
intros Hmin Hmax.
exists (mk_bounded_scalar ty n Hmin Hmax).
apply mk_bounded_scalar_success.
Qed.

Lemma usize_peano_ind (P: usize -> Prop) :
  P (0%usize) ->
  (∀n, ∀b: to_Z n < usize_max, P n -> P (bounded_scalar_succ n b)) ->
  ∀n, P n.
Proof.
intros base rec n.
destruct n.

(* We should exploit Peano induction on either Z with constraints or positives with upper bound *)
(* Here, we destruct the Z number of do the induction on natural numbers *)
destruct x.
3: { exfalso. simpl in *. unfold usize_min in a. lia. }
- set (x := exist (λ x0 : Z, scalar_min Usize <= x0 <= scalar_max Usize) 0 a).
  set (y := 0%usize).
  assert (H : x = y) by now apply usize_nat_inj.
  now apply (eq_ind y P base x).
- (* nat_ind: P P0 (f:∀n.Pn->PSn) -> ∀n.Pn *)
  admit.
Admitted.

(* Not trivial to generalize due to eq_refl in %usize. The zero and successor case are done to ease recursion *)
Lemma usize_nat_zero {n: usize} : (usize_to_nat n = 0%nat) <-> (n = 0 %usize).
Proof.
split ; intro H.
- now apply usize_nat_inj, H.
- now rewrite H.
Qed.

Lemma usize_nat_succ {n: usize} {m: nat} : (usize_to_nat n = S m) -> (∃i, usize_sub n 1 %usize = Return i).
Proof.
destruct n. intro I.
destruct x.
1: { inversion I. }
2: { inversion I. }

set (z := Z.pos p).
assert (Hmin: 0 <= z - 1) by lia.
assert (Hmax: z - 1 <= scalar_max Usize) by lia.

apply (mk_scalar_success Usize Hmin Hmax).
Qed.

Lemma usize_to_nonzero {n: usize} : n <> 0%usize <-> ∃m, usize_to_nat n = S m.
Proof.
split.
- intros H.
  assert (H':= neg_impl usize_nat_inj H).
  unfold usize_to_nat at 2 in H'. simpl in H'.
  exists (Nat.pred (usize_to_nat n)).
  destruct (usize_to_nat n).
  + contradiction.
  + now rewrite Nat.pred_succ.
- intros p H.
  destruct p.
  apply (f_equal usize_to_nat) in H.
  rewrite H0 in H.
  inversion H.
Qed.

(* There are may similar lemmas to be defined *)
Lemma scalar_eqb_eq {ty} {n m: scalar ty} :
    (n s= m) = true <-> n = m.
Proof.
unfold scalar_eqb.
split ; intro.
- now apply scalar_Z_inj, Z.eqb_eq.
- now apply Z.eqb_eq, f_equal.
Qed.

Lemma scalar_eqb_ne {ty} {n m: scalar ty} :
(n s= m) = false <-> n <> m.
Proof.
rewrite <-(not_true_iff_false (n s= m)).
apply (neg_equiv scalar_eqb_eq).
Qed.

Lemma xyz (ty : scalar_ty) (x: Z) :
  scalar_min ty <= x <= scalar_max ty ->
  ∃n.    mk_scalar ty x = Return n
      /\ to_Z n = x.
Proof.
Admitted.

(* Utilities for the hashmap *)

Definition key_id   := usize.
Definition hash_id  := usize.
Definition slot_id  := usize.
Definition chain_id := usize.

Definition chain_t T := list (usize * T).

Fixpoint list_t_to_chain {T} (l: List_t T) : chain_t T :=
    match l with
    | ListCons n x t => cons (n, x) (list_t_to_chain t)
    | ListNil => nil
    end.

Definition get_slots_len {T} (hm: Hash_map_t T) : usize :=
    vec_len (List_t T) hm.(Hash_map_slots).

(* Hash *)

Definition get_hash (k: key_id) : hash_id :=
    (hash_key_fwd k) %return.

Definition get_hash_pos {T} (hm: Hash_map_t T) (k: key_id) : result slot_id :=
    scalar_rem (get_hash k) (get_slots_len hm).

(* Given hm, i, j: give key-value pair *)
Definition get_kv {T} (hm: Hash_map_t T) (i: slot_id) (j: chain_id) : result (usize * T) :=
    let l := vec_to_list hm.(Hash_map_slots) in
    ch <- opt_to_res (nth_error l (usize_to_nat i));
    let kv := nth_error (list_t_to_chain ch) (usize_to_nat j) in
    opt_to_res kv.

Definition result_prop_bind {T} (x: result T) (p: T -> Prop) : Prop :=
    match x with
    | Fail_ Failure => True
    | Fail_ _ => False
    | Return x => p x
    end.

(* Allocate slots *)

Definition hm_clean_slots {T}(slots: vec (List_t T)) : list (chain_t T) :=
    List.map list_t_to_chain (vec_to_list slots).

Definition hm_allocate_slots_spec (T: Type) (n: nat) : list (chain_t T) :=
    repeat (@nil (usize * T)) n.

(* Need more general statement:
    n < usize_max ->
    HM_alloc_slots T fuel v n = Return v' ->
    HM_alloc_slots T Sfuel v' Sn = Return v'::[nil]
*)
Lemma hm_allocate_slots_shape_rec (T: Type) (fuel: nat) (v: vec (List_t T)) (n: usize) (b: to_Z n < usize_max) :
  v0 <- 
  Return 
  match hash_map_allocate_slots_fwd T (S fuel) v (bounded_scalar_succ n b) with
  | Fail_ _ => True
  | Return v1 => let v0
    Return v1 = 
  ∃v', (
    hash_map_allocate_slots_fwd T fuel v n = Return v'
    ->
    hash_map_allocate_slots_fwd T (S fuel) v' (bounded_scalar_succ n b) = vec_push_back _ (hash_map_allocate_slots_fwd T fuel v n) ListNil
  ).
Proof.
destruct.
intros X Y.
Admitted.

Lemma hm_allocate_slots_shape (T: Type) (n: usize) (fuel: nat) :
    match hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n with
    | Return v => hm_clean_slots v =
                  hm_allocate_slots_spec T (usize_to_nat n)
    | Fail_ OutOfFuel => True
    | Fail_ Failure => False
    end.
Proof.
remember (hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n) as x.
induction x.
- unfold hash_map_allocate_slots_fwd in Heqx.
  destruct fuel. inversion Heqx.
  remember (n s= 0%usize) as y.
  induction y ; apply eq_sym in Heqy.
  1: {
    rewrite scalar_eqb_eq in Heqy.
    rewrite Heqy.
    inversion Heqx.
    now unfold hm_allocate_slots_spec, hm_clean_slots.
  }
  rewrite scalar_eqb_ne in Heqy.
  set (nEx := (proj1 usize_to_nonzero) Heqy).
  destruct nEx.
  assert (nEx' := usize_nat_succ H).
  destruct nEx'.
  rewrite H0 in Heqx.
  admit.
- destruct e.
    + admit.
    + trivial.
Admitted.

Lemma hm_allocate_slots_shape2 (T: Type) (n: usize) (fuel: nat) :
    match hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n with
    | Return v => hm_clean_slots v =
                  hm_allocate_slots_spec T (usize_to_nat n)
    | Fail_ OutOfFuel => True
    | Fail_ Failure => False
    end.
Proof.
revert n.
apply (usize_peano_ind (λ n: usize,
  match hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n with
  | Return v => hm_clean_slots v =
                hm_allocate_slots_spec T (usize_to_nat n)
  | Fail_ OutOfFuel => True
  | Fail_ Failure => False
  end)).
- remember (hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) 0 %usize) as x.
  induction x.
  unfold hash_map_allocate_slots_fwd in Heqx.
  destruct fuel. inversion Heqx.
  simpl in Heqx.
  inversion Heqx.
  now unfold hm_allocate_slots_spec, hm_clean_slots.
  destruct e.
  + unfold hash_map_allocate_slots_fwd in Heqx.
    destruct fuel. inversion Heqx.
    inversion Heqx.
  + trivial.
- intros.
  set (n' := bounded_scalar_succ n b).
  remember (hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n') as x.
  induction x.
  unfold hash_map_allocate_slots_fwd in Heqx.
  destruct fuel. inversion Heqx.
  remember (n' s= 0 %usize) as y.
  induction y ; apply eq_sym in Heqy.
  1: {
    rewrite scalar_eqb_eq in Heqy.
    assert (Hne := sc_succ_above_min n b).
    change (bounded_scalar_succ n b) with n' in Hne.
    rewrite Heqy in Hne.
    inversion Hne.
  }
  change n' with (bounded_scalar_succ n b) in Heqx.
  rewrite (sc_succ_pred_eq n) in Heqx.

  assert (Hne := sc_succ_above_min n b).
  
  unfold hash_map_allocate_slots_fwd.
Admitted.

Lemma hm_allocate_slots_shape3 (T: Type) (n: usize) (fuel: nat) :
    match hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n with
    | Return v => hm_clean_slots v =
                  hm_allocate_slots_spec T (usize_to_nat n)
    | Fail_ OutOfFuel => True
    | Fail_ Failure => False
    end.
Proof.
revert fuel n.
apply (usize_peano_ind (λ n: usize,
  match hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n with
  | Return v => hm_clean_slots v =
                hm_allocate_slots_spec T (usize_to_nat n)
  | Fail_ OutOfFuel => True
  | Fail_ Failure => False
  end)).
- remember (hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) 0 %usize) as X. induction X.
  + destruct fuel ; now inversion HeqX.
  + destruct fuel. now inversion HeqX.
    destruct e. 2: { trivial. }
    now inversion HeqX.
- intros.
  unfold hash_map_allocate_slots_fwd.
  remember (hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n) as X. induction X.
  + destruct fuel. trivial.
    fold hash_map_allocate_slots_fwd.

    remember (bounded_scalar_succ n b s= 0 %usize) as y.
    induction y ; apply eq_sym in Heqy.
    1: {
      rewrite scalar_eqb_eq in Heqy.
      assert (Hne := sc_succ_above_min n b).
      rewrite Heqy in Hne.
      inversion Hne.
    }
    clear Heqy.
    rewrite (sc_succ_pred_eq n).

    (* Fuel & vector mismatch in HeqX *)
    (* I need to keep those parameters generic *)

    (* I admit HeqX with a different fuel *)
    assert (HeqX': Return a =
    hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n) by admit.

    simpl.
    rewrite <-HeqX'.

    simpl (vec_push_back (List_t T) (vec_new (List_t T)) ListNil).

    rewrite (sc_succ_pred_eq n).
    
    

  Admitted.

Lemma hm_allocate_slots_shape3 (T: Type) (n: usize) (fuel: nat) :
    match hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n with
    | Return v => hm_clean_slots v =
                  hm_allocate_slots_spec T (usize_to_nat n)
    | Fail_ OutOfFuel => True
    | Fail_ Failure => False
    end.
Proof.
remember (hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n) as X. induction X.
- apply (usize_peano_ind (λ n: usize, hm_clean_slots a = hm_allocate_slots_spec T (usize_to_nat n))).

revert n.
apply (usize_peano_ind (λ n: usize,
  match hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n with
  | Return v => hm_clean_slots v =
                hm_allocate_slots_spec T (usize_to_nat n)
  | Fail_ OutOfFuel => True
  | Fail_ Failure => False
  end)).
- admit.
- intros.
  remember (hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) (bounded_scalar_succ n b)) as x.
  induction x.
  destruct fuel. inversion Heqx.
  unfold hash_map_allocate_slots_fwd in Heqx.
  rewrite (sc_succ_pred_eq n) in Heqx.

  remember (bounded_scalar_succ n b s= 0 %usize) as y.
  induction y ; apply eq_sym in Heqy.
  1: {
    rewrite scalar_eqb_eq in Heqy.
    assert (Hne := sc_succ_above_min n b).
    rewrite Heqy in Hne.
    inversion Hne.
  }
  clear Heqy.
  fold hash_map_allocate_slots_fwd in Heqx.

  assert (vpb : vec_length (vec_new (List_t T)) < usize_max) by admit.
  destruct (vec_push_success vpb).

  injection result in Heqx.
  unfold vec_push_back at 1 in Heqx.
  simpl in Heqx.

  assert (Ind: hash_map_allocate_slots_fwd T
    (S fuel)
    (vec_new (List_t T))
    n
    = Return (vec_new (List_t T))).
  admit.

Admitted.

Lemma hm_allocate_slots_fuel (T: Type) (n: usize) :
    let fuel := S (usize_to_nat n) in
    match hm_allocate_slots_raw T n fuel with
    | Fail_ OutOfFuel => False
    | _ => True
    end.
Proof.
    induction (usize_to_nat n) ; unfold hm_allocate_slots_raw ; simpl.
    - 
Qed.

hm_allocate_slots_raw T n fuel = Return x.
set (v := hm_allocate_slots_raw T n fuel).
induction (usize_to_nat n) ; unfold hm_allocate_slots_raw in v ; simpl in *.
- inversion wfp.
-
Qed.

(*Lemma hm_allocate_slots_no_fail (T: Type) (n: usize) (fuel: nat) (wfp: Nat.lt fuel (usize_to_nat n)) : ∃x, hm_allocate_slots_raw T n fuel = Return x.
set (v := hm_allocate_slots_raw T n fuel).
induction (usize_to_nat n) ; unfold hm_allocate_slots_raw in v ; simpl in *.
- inversion wfp.
-
Qed.*)

Lemma hm_allocate_slots_eq (T: Type) (n: usize) (fuel: nat) (wfp: Nat.le fuel (usize_to_nat n)) :
    fmap_res (hash_map_allocate_slots_fwd T fuel (vec_new (List_t T)) n) (fun v => list_t_to_chain (vec_to_list v)) = Return (hm_allocate_slots T n).

(* Main invariants *)

Notation "x <-- c1 ; c2" := (result_prop_bind c1 (fun x => c2))
(at level 61, c1 at next level, right associativity).

Definition key_is_in_hash_slot {T} (hm: Hash_map_t T) (i: slot_id) (j: chain_id) : Prop :=
    kv <-- get_kv hm i j;
    p  <-- get_hash_pos hm (fst kv);
    (p = i).

Definition no_key_duplicate {T} (hm: Hash_map_t T) (i: slot_id) (j1 j2: chain_id) (p: j1 <> j2) : Prop :=
    kv1 <-- get_kv hm i j1;
    kv2 <-- get_kv hm i j2;
    (fst kv1 <> fst kv2).

Definition hm_invariants {T} (hm: Hash_map_t T) :=
    (∀i j, key_is_in_hash_slot hm i j) /\
    (∀i j1 j2 p, no_key_duplicate hm i j1 j2 p).



Lemma hm_new_inv (T: Type) : hm_invariants ((hash_map_new_fwd T 1%nat)%return).

End Hashmap_Properties.
