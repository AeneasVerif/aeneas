(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [demo] *)
Require Import Primitives.
Import Primitives.
Require Import Coq.ZArith.ZArith.
Require Import List.
Import ListNotations.
Local Open Scope Primitives_scope.
Module Demo.

(** [demo::choose]:
    Source: 'src/demo.rs', lines 5:0-5:70 *)
Definition choose
  (T : Type) (b : bool) (x : T) (y : T) : result (T * (T -> result (T * T))) :=
  if b
  then let back_'a := fun (ret : T) => Return (ret, y) in Return (x, back_'a)
  else let back_'a := fun (ret : T) => Return (x, ret) in Return (y, back_'a)
.

(** [demo::mul3_add1]:
    Source: 'src/demo.rs', lines 13:0-13:31 *)
Definition mul3_add1 (x : u32) : result u32 :=
  i <- u32_add x x; i1 <- u32_add i x; u32_add i1 1%u32
.

(** [demo::use_mul3_add1]:
    Source: 'src/demo.rs', lines 17:0-17:43 *)
Definition use_mul3_add1 (x : u32) (y : u32) : result u32 :=
  i <- mul3_add1 x; u32_add i y
.

(** [demo::incr]:
    Source: 'src/demo.rs', lines 21:0-21:31 *)
Definition incr (x : u32) : result u32 :=
  u32_add x 1%u32.

(** [demo::use_incr]:
    Source: 'src/demo.rs', lines 25:0-25:17 *)
Definition use_incr : result unit :=
  x <- incr 0%u32; x1 <- incr x; _ <- incr x1; Return tt
.

(** [demo::CList]
    Source: 'src/demo.rs', lines 34:0-34:17 *)
Inductive CList_t (T : Type) :=
| CList_CCons : T -> CList_t T -> CList_t T
| CList_CNil : CList_t T
.

Arguments CList_CCons { _ }.
Arguments CList_CNil { _ }.

(** [demo::list_nth]:
    Source: 'src/demo.rs', lines 39:0-39:56 *)
Fixpoint list_nth (T : Type) (n : nat) (l : CList_t T) (i : u32) : result T :=
  match n with
  | O => Fail_ OutOfFuel
  | S n1 =>
    match l with
    | CList_CCons x tl =>
      if i s= 0%u32
      then Return x
      else (i1 <- u32_sub i 1%u32; list_nth T n1 tl i1)
    | CList_CNil => Fail_ Failure
    end
  end
.

(** [demo::list_nth1]: loop 0:
    Source: 'src/demo.rs', lines 54:0-63:1 *)
Fixpoint list_nth1_loop
  (T : Type) (n : nat) (l : CList_t T) (i : u32) : result T :=
  match n with
  | O => Fail_ OutOfFuel
  | S n1 =>
    match l with
    | CList_CCons x tl =>
      if i s= 0%u32
      then Return x
      else (i1 <- u32_sub i 1%u32; list_nth1_loop T n1 tl i1)
    | CList_CNil => Fail_ Failure
    end
  end
.

(** [demo::list_nth1]:
    Source: 'src/demo.rs', lines 54:0-54:65 *)
Definition list_nth1
  (T : Type) (n : nat) (l : CList_t T) (i : u32) : result T :=
  list_nth1_loop T n l i
.

(** Trait declaration: [demo::Counter]
    Source: 'src/demo.rs', lines 67:0-67:17 *)
Record Counter_t (Self : Type) := mkCounter_t {
  Counter_t_incr : Self -> result (usize * Self);
}.

Arguments mkCounter_t { _ }.
Arguments Counter_t_incr { _ }.

(** [demo::{(demo::Counter for usize)}::incr]:
    Source: 'src/demo.rs', lines 72:4-72:31 *)
Definition counterUsize_incr (self : usize) : result (usize * usize) :=
  self1 <- usize_add self 1%usize; Return (self, self1)
.

(** Trait implementation: [demo::{(demo::Counter for usize)}]
    Source: 'src/demo.rs', lines 71:0-71:22 *)
Definition CounterUsize : Counter_t usize := {|
  Counter_t_incr := counterUsize_incr;
|}.

(** [demo::use_counter]:
    Source: 'src/demo.rs', lines 79:0-79:59 *)
Definition use_counter
  (T : Type) (counterInst : Counter_t T) (cnt : T) : result (usize * T) :=
  p <- counterInst.(Counter_t_incr) cnt;
  let (_, cnt1) := p in
  counterInst.(Counter_t_incr) cnt1
.

(** [demo::use_vec_index]:
    Source: 'src/demo.rs', lines 86:0-86:51 *)
Definition use_vec_index (i : usize) (v : alloc_vec_Vec u32) : result u32 :=
  alloc_vec_Vec_index u32 usize (core_slice_index_SliceIndexUsizeSliceTInst
    u32) v i
.

End Demo.
