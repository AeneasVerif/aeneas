(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [paper] *)
Require Import Primitives.
Import Primitives.
Require Import Coq.ZArith.ZArith.
Require Import List.
Import ListNotations.
Local Open Scope Primitives_scope.
Module Paper.

(** [paper::ref_incr]: merged forward/backward function
    (there is a single backward function, and the forward function returns ()) *)
Definition ref_incr (x : i32) : result i32 :=
  i32_add x 1%i32.

(** [paper::test_incr]: forward function *)
Definition test_incr : result unit :=
  x <- ref_incr 0%i32; if negb (x s= 1%i32) then Fail_ Failure else Return tt
.

(** Unit test for [paper::test_incr] *)
Check (test_incr )%return.

(** [paper::choose]: forward function *)
Definition choose (T : Type) (b : bool) (x : T) (y : T) : result T :=
  if b then Return x else Return y
.

(** [paper::choose]: backward function 0 *)
Definition choose_back
  (T : Type) (b : bool) (x : T) (y : T) (ret : T) : result (T * T) :=
  if b then Return (ret, y) else Return (x, ret)
.

(** [paper::test_choose]: forward function *)
Definition test_choose : result unit :=
  z <- choose i32 true 0%i32 0%i32;
  z0 <- i32_add z 1%i32;
  if negb (z0 s= 1%i32)
  then Fail_ Failure
  else (
    p <- choose_back i32 true 0%i32 0%i32 z0;
    let (x, y) := p in
    if negb (x s= 1%i32)
    then Fail_ Failure
    else if negb (y s= 0%i32) then Fail_ Failure else Return tt)
.

(** Unit test for [paper::test_choose] *)
Check (test_choose )%return.

(** [paper::List] *)
Inductive List_t (T : Type) :=
| List_Cons : T -> List_t T -> List_t T
| List_Nil : List_t T
.

Arguments List_Cons {T} _ _.
Arguments List_Nil {T}.

(** [paper::list_nth_mut]: forward function *)
Fixpoint list_nth_mut (T : Type) (l : List_t T) (i : u32) : result T :=
  match l with
  | List_Cons x tl =>
    if i s= 0%u32
    then Return x
    else (i0 <- u32_sub i 1%u32; list_nth_mut T tl i0)
  | List_Nil => Fail_ Failure
  end
.

(** [paper::list_nth_mut]: backward function 0 *)
Fixpoint list_nth_mut_back
  (T : Type) (l : List_t T) (i : u32) (ret : T) : result (List_t T) :=
  match l with
  | List_Cons x tl =>
    if i s= 0%u32
    then Return (List_Cons ret tl)
    else (
      i0 <- u32_sub i 1%u32;
      tl0 <- list_nth_mut_back T tl i0 ret;
      Return (List_Cons x tl0))
  | List_Nil => Fail_ Failure
  end
.

(** [paper::sum]: forward function *)
Fixpoint sum (l : List_t i32) : result i32 :=
  match l with
  | List_Cons x tl => i <- sum tl; i32_add x i
  | List_Nil => Return 0%i32
  end
.

(** [paper::test_nth]: forward function *)
Definition test_nth : result unit :=
  let l := List_Nil in
  let l0 := List_Cons 3%i32 l in
  let l1 := List_Cons 2%i32 l0 in
  x <- list_nth_mut i32 (List_Cons 1%i32 l1) 2%u32;
  x0 <- i32_add x 1%i32;
  l2 <- list_nth_mut_back i32 (List_Cons 1%i32 l1) 2%u32 x0;
  i <- sum l2;
  if negb (i s= 7%i32) then Fail_ Failure else Return tt
.

(** Unit test for [paper::test_nth] *)
Check (test_nth )%return.

(** [paper::call_choose]: forward function *)
Definition call_choose (p : (u32 * u32)) : result u32 :=
  let (px, py) := p in
  pz <- choose u32 true px py;
  pz0 <- u32_add pz 1%u32;
  p0 <- choose_back u32 true px py pz0;
  let (px0, _) := p0 in
  Return px0
.

End Paper .
