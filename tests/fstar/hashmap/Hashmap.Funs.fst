(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [hashmap]: function definitions *)
module Hashmap.Funs
open Primitives
include Hashmap.Types
include Hashmap.FunsExternal
include Hashmap.Clauses

#set-options "--z3rlimit 50 --fuel 1 --ifuel 1"

(** [hashmap::hash_key]:
    Source: 'tests/src/hashmap.rs', lines 36:0-41:1 *)
let hash_key (k : usize) : result usize =
  Ok k

(** [hashmap::{core::clone::Clone for hashmap::Fraction}::clone]:
    Source: 'tests/src/hashmap.rs', lines 43:9-43:14 *)
let clonehashmapFraction_clone (self : fraction_t) : result fraction_t =
  Ok self

(** [hashmap::{core::clone::Clone for hashmap::Fraction}::clone_from]:
    Source: 'tests/src/hashmap.rs', lines 43:9-43:14 *)
let clonehashmapFraction_clone_from
  (self : fraction_t) (source : fraction_t) : result fraction_t =
  clonehashmapFraction_clone source

(** Trait implementation: [hashmap::{core::clone::Clone for hashmap::Fraction}]
    Source: 'tests/src/hashmap.rs', lines 43:9-43:14 *)
let core_clone_ClonehashmapFraction : core_clone_Clone fraction_t = {
  clone = clonehashmapFraction_clone;
  clone_from = clonehashmapFraction_clone_from;
}

(** Trait implementation: [hashmap::{core::marker::Copy for hashmap::Fraction}]
    Source: 'tests/src/hashmap.rs', lines 43:16-43:20 *)
let core_marker_CopyhashmapFraction : core_marker_Copy fraction_t = {
  cloneInst = core_clone_ClonehashmapFraction;
}

(** [hashmap::{hashmap::HashMap<T>}::allocate_slots]: loop 0:
    Source: 'tests/src/hashmap.rs', lines 68:8-71:9 *)
let rec hashMap_allocate_slots_loop
  (#t : Type0) (slots : alloc_vec_Vec (aList_t t)) (n : usize) :
  Tot (result (alloc_vec_Vec (aList_t t)))
  (decreases (hashMap_allocate_slots_loop_decreases slots n))
  =
  if n > 0
  then
    let* slots1 = alloc_vec_Vec_push slots AList_Nil in
    let* n1 = usize_sub n 1 in
    hashMap_allocate_slots_loop slots1 n1
  else Ok slots

(** [hashmap::{hashmap::HashMap<T>}::allocate_slots]:
    Source: 'tests/src/hashmap.rs', lines 67:4-73:5 *)
let hashMap_allocate_slots
  (#t : Type0) (slots : alloc_vec_Vec (aList_t t)) (n : usize) :
  result (alloc_vec_Vec (aList_t t))
  =
  hashMap_allocate_slots_loop slots n

(** [hashmap::{hashmap::HashMap<T>}::new_with_capacity]:
    Source: 'tests/src/hashmap.rs', lines 76:4-87:5 *)
let hashMap_new_with_capacity
  (t : Type0) (capacity : usize) (max_load_factor : fraction_t) :
  result (hashMap_t t)
  =
  let* slots = hashMap_allocate_slots (alloc_vec_Vec_new (aList_t t)) capacity
  in
  let* i = usize_mul capacity max_load_factor.dividend in
  let* i1 = usize_div i max_load_factor.divisor in
  Ok
    { num_entries = 0; max_load_factor; max_load = i1; saturated = false; slots
    }

(** [hashmap::{hashmap::HashMap<T>}::new]:
    Source: 'tests/src/hashmap.rs', lines 89:4-98:5 *)
let hashMap_new (t : Type0) : result (hashMap_t t) =
  hashMap_new_with_capacity t 32 { dividend = 4; divisor = 5 }

(** [hashmap::{hashmap::HashMap<T>}::clear]: loop 0:
    Source: 'tests/src/hashmap.rs', lines 104:8-107:9 *)
let rec hashMap_clear_loop
  (#t : Type0) (slots : alloc_vec_Vec (aList_t t)) (i : usize) :
  Tot (result (alloc_vec_Vec (aList_t t)))
  (decreases (hashMap_clear_loop_decreases slots i))
  =
  let i1 = alloc_vec_Vec_len slots in
  if i < i1
  then
    let* (_, index_mut_back) =
      alloc_vec_Vec_index_mut (core_slice_index_SliceIndexUsizeSliceInst
        (aList_t t)) slots i
    in
    let* i2 = usize_add i 1 in
    let slots1 = index_mut_back AList_Nil in
    hashMap_clear_loop slots1 i2
  else Ok slots

(** [hashmap::{hashmap::HashMap<T>}::clear]:
    Source: 'tests/src/hashmap.rs', lines 100:4-108:5 *)
let hashMap_clear (#t : Type0) (self : hashMap_t t) : result (hashMap_t t) =
  let* slots = hashMap_clear_loop self.slots 0 in
  Ok { self with num_entries = 0; slots }

(** [hashmap::{hashmap::HashMap<T>}::len]:
    Source: 'tests/src/hashmap.rs', lines 110:4-112:5 *)
let hashMap_len (#t : Type0) (self : hashMap_t t) : result usize =
  Ok self.num_entries

(** [hashmap::{hashmap::HashMap<T>}::insert_in_list]: loop 0:
    Source: 'tests/src/hashmap.rs', lines 1:0-133:9 *)
let rec hashMap_insert_in_list_loop
  (#t : Type0) (key : usize) (value : t) (ls : aList_t t) :
  Tot (result (bool & (aList_t t)))
  (decreases (hashMap_insert_in_list_loop_decreases key value ls))
  =
  begin match ls with
  | AList_Cons ckey cvalue tl ->
    if ckey = key
    then Ok (false, (AList_Cons ckey value tl))
    else
      let* (b, tl1) = hashMap_insert_in_list_loop key value tl in
      Ok (b, (AList_Cons ckey cvalue tl1))
  | AList_Nil -> Ok (true, (AList_Cons key value AList_Nil))
  end

(** [hashmap::{hashmap::HashMap<T>}::insert_in_list]:
    Source: 'tests/src/hashmap.rs', lines 117:4-134:5 *)
let hashMap_insert_in_list
  (#t : Type0) (key : usize) (value : t) (ls : aList_t t) :
  result (bool & (aList_t t))
  =
  hashMap_insert_in_list_loop key value ls

(** [hashmap::{hashmap::HashMap<T>}::insert_no_resize]:
    Source: 'tests/src/hashmap.rs', lines 137:4-145:5 *)
let hashMap_insert_no_resize
  (#t : Type0) (self : hashMap_t t) (key : usize) (value : t) :
  result (hashMap_t t)
  =
  let* hash = hash_key key in
  let i = alloc_vec_Vec_len self.slots in
  let* hash_mod = usize_rem hash i in
  let* (a, index_mut_back) =
    alloc_vec_Vec_index_mut (core_slice_index_SliceIndexUsizeSliceInst (aList_t
      t)) self.slots hash_mod
  in
  let* (inserted, a1) = hashMap_insert_in_list key value a in
  if inserted
  then
    let* i1 = usize_add self.num_entries 1 in
    let v = index_mut_back a1 in
    Ok { self with num_entries = i1; slots = v }
  else let v = index_mut_back a1 in Ok { self with slots = v }

(** [hashmap::{hashmap::HashMap<T>}::move_elements_from_list]: loop 0:
    Source: 'tests/src/hashmap.rs', lines 199:12-206:17 *)
let rec hashMap_move_elements_from_list_loop
  (#t : Type0) (ntable : hashMap_t t) (ls : aList_t t) :
  Tot (result (hashMap_t t))
  (decreases (hashMap_move_elements_from_list_loop_decreases ntable ls))
  =
  begin match ls with
  | AList_Cons k v tl ->
    let* ntable1 = hashMap_insert_no_resize ntable k v in
    hashMap_move_elements_from_list_loop ntable1 tl
  | AList_Nil -> Ok ntable
  end

(** [hashmap::{hashmap::HashMap<T>}::move_elements_from_list]:
    Source: 'tests/src/hashmap.rs', lines 196:4-209:5 *)
let hashMap_move_elements_from_list
  (#t : Type0) (ntable : hashMap_t t) (ls : aList_t t) : result (hashMap_t t) =
  hashMap_move_elements_from_list_loop ntable ls

(** [hashmap::{hashmap::HashMap<T>}::move_elements]: loop 0:
    Source: 'tests/src/hashmap.rs', lines 185:8-192:9 *)
let rec hashMap_move_elements_loop
  (#t : Type0) (ntable : hashMap_t t) (slots : alloc_vec_Vec (aList_t t))
  (i : usize) :
  Tot (result ((hashMap_t t) & (alloc_vec_Vec (aList_t t))))
  (decreases (hashMap_move_elements_loop_decreases ntable slots i))
  =
  let i1 = alloc_vec_Vec_len slots in
  if i < i1
  then
    let* (a, index_mut_back) =
      alloc_vec_Vec_index_mut (core_slice_index_SliceIndexUsizeSliceInst
        (aList_t t)) slots i
    in
    let (ls, a1) = core_mem_replace a AList_Nil in
    let* ntable1 = hashMap_move_elements_from_list ntable ls in
    let* i2 = usize_add i 1 in
    let slots1 = index_mut_back a1 in
    hashMap_move_elements_loop ntable1 slots1 i2
  else Ok (ntable, slots)

(** [hashmap::{hashmap::HashMap<T>}::move_elements]:
    Source: 'tests/src/hashmap.rs', lines 183:4-193:5 *)
let hashMap_move_elements
  (#t : Type0) (ntable : hashMap_t t) (slots : alloc_vec_Vec (aList_t t)) :
  result ((hashMap_t t) & (alloc_vec_Vec (aList_t t)))
  =
  hashMap_move_elements_loop ntable slots 0

(** [hashmap::{hashmap::HashMap<T>}::try_resize]:
    Source: 'tests/src/hashmap.rs', lines 160:4-179:5 *)
let hashMap_try_resize
  (#t : Type0) (self : hashMap_t t) : result (hashMap_t t) =
  let capacity = alloc_vec_Vec_len self.slots in
  let* n1 = usize_div core_num_Usize_MAX 2 in
  let* i = usize_div n1 self.max_load_factor.dividend in
  if capacity <= i
  then
    let* i1 = usize_mul capacity 2 in
    let* ntable = hashMap_new_with_capacity t i1 self.max_load_factor in
    let* p = hashMap_move_elements ntable self.slots in
    let (ntable1, _) = p in
    Ok { self with max_load = ntable1.max_load; slots = ntable1.slots }
  else Ok { self with saturated = true }

(** [hashmap::{hashmap::HashMap<T>}::insert]:
    Source: 'tests/src/hashmap.rs', lines 149:4-156:5 *)
let hashMap_insert
  (#t : Type0) (self : hashMap_t t) (key : usize) (value : t) :
  result (hashMap_t t)
  =
  let* self1 = hashMap_insert_no_resize self key value in
  let* i = hashMap_len self1 in
  if i > self1.max_load
  then if self1.saturated then Ok self1 else hashMap_try_resize self1
  else Ok self1

(** [hashmap::{hashmap::HashMap<T>}::contains_key_in_list]: loop 0:
    Source: 'tests/src/hashmap.rs', lines 1:0-231:9 *)
let rec hashMap_contains_key_in_list_loop
  (#t : Type0) (key : usize) (ls : aList_t t) :
  Tot (result bool)
  (decreases (hashMap_contains_key_in_list_loop_decreases key ls))
  =
  begin match ls with
  | AList_Cons ckey _ tl ->
    if ckey = key then Ok true else hashMap_contains_key_in_list_loop key tl
  | AList_Nil -> Ok false
  end

(** [hashmap::{hashmap::HashMap<T>}::contains_key_in_list]:
    Source: 'tests/src/hashmap.rs', lines 219:4-232:5 *)
let hashMap_contains_key_in_list
  (#t : Type0) (key : usize) (ls : aList_t t) : result bool =
  hashMap_contains_key_in_list_loop key ls

(** [hashmap::{hashmap::HashMap<T>}::contains_key]:
    Source: 'tests/src/hashmap.rs', lines 212:4-216:5 *)
let hashMap_contains_key
  (#t : Type0) (self : hashMap_t t) (key : usize) : result bool =
  let* hash = hash_key key in
  let i = alloc_vec_Vec_len self.slots in
  let* hash_mod = usize_rem hash i in
  let* a =
    alloc_vec_Vec_index (core_slice_index_SliceIndexUsizeSliceInst (aList_t t))
      self.slots hash_mod
  in
  hashMap_contains_key_in_list key a

(** [hashmap::{hashmap::HashMap<T>}::get_in_list]: loop 0:
    Source: 'tests/src/hashmap.rs', lines 238:8-246:5 *)
let rec hashMap_get_in_list_loop
  (#t : Type0) (key : usize) (ls : aList_t t) :
  Tot (result (option t))
  (decreases (hashMap_get_in_list_loop_decreases key ls))
  =
  begin match ls with
  | AList_Cons ckey cvalue tl ->
    if ckey = key then Ok (Some cvalue) else hashMap_get_in_list_loop key tl
  | AList_Nil -> Ok None
  end

(** [hashmap::{hashmap::HashMap<T>}::get_in_list]:
    Source: 'tests/src/hashmap.rs', lines 237:4-246:5 *)
let hashMap_get_in_list
  (#t : Type0) (key : usize) (ls : aList_t t) : result (option t) =
  hashMap_get_in_list_loop key ls

(** [hashmap::{hashmap::HashMap<T>}::get]:
    Source: 'tests/src/hashmap.rs', lines 248:4-252:5 *)
let hashMap_get
  (#t : Type0) (self : hashMap_t t) (key : usize) : result (option t) =
  let* hash = hash_key key in
  let i = alloc_vec_Vec_len self.slots in
  let* hash_mod = usize_rem hash i in
  let* a =
    alloc_vec_Vec_index (core_slice_index_SliceIndexUsizeSliceInst (aList_t t))
      self.slots hash_mod
  in
  hashMap_get_in_list key a

(** [hashmap::{hashmap::HashMap<T>}::get_mut_in_list]: loop 0:
    Source: 'tests/src/hashmap.rs', lines 255:8-263:5 *)
let rec hashMap_get_mut_in_list_loop
  (#t : Type0) (ls : aList_t t) (key : usize) :
  Tot (result ((option t) & (option t -> aList_t t)))
  (decreases (hashMap_get_mut_in_list_loop_decreases ls key))
  =
  begin match ls with
  | AList_Cons ckey cvalue tl ->
    if ckey = key
    then
      let back =
        fun ret ->
          let x = begin match ret with | Some x1 -> x1 | _ -> cvalue end in
          AList_Cons ckey x tl
      in
      Ok ((Some cvalue), back)
    else
      let* (o, back) = hashMap_get_mut_in_list_loop tl key in
      let back1 = fun ret -> let tl1 = back ret in AList_Cons ckey cvalue tl1
      in
      Ok (o, back1)
  | AList_Nil -> let back = fun ret -> AList_Nil in Ok (None, back)
  end

(** [hashmap::{hashmap::HashMap<T>}::get_mut_in_list]:
    Source: 'tests/src/hashmap.rs', lines 254:4-263:5 *)
let hashMap_get_mut_in_list
  (#t : Type0) (ls : aList_t t) (key : usize) :
  result ((option t) & (option t -> aList_t t))
  =
  hashMap_get_mut_in_list_loop ls key

(** [hashmap::{hashmap::HashMap<T>}::get_mut]:
    Source: 'tests/src/hashmap.rs', lines 266:4-270:5 *)
let hashMap_get_mut
  (#t : Type0) (self : hashMap_t t) (key : usize) :
  result ((option t) & (option t -> hashMap_t t))
  =
  let* hash = hash_key key in
  let i = alloc_vec_Vec_len self.slots in
  let* hash_mod = usize_rem hash i in
  let* (a, index_mut_back) =
    alloc_vec_Vec_index_mut (core_slice_index_SliceIndexUsizeSliceInst (aList_t
      t)) self.slots hash_mod
  in
  let* (o, get_mut_in_list_back) = hashMap_get_mut_in_list a key in
  let back =
    fun ret ->
      let a1 = get_mut_in_list_back ret in
      let v = index_mut_back a1 in
      { self with slots = v }
  in
  Ok (o, back)

(** [hashmap::{hashmap::HashMap<T>}::remove_from_list]: loop 0:
    Source: 'tests/src/hashmap.rs', lines 1:0-297:17 *)
let rec hashMap_remove_from_list_loop
  (#t : Type0) (key : usize) (ls : aList_t t) :
  Tot (result ((option t) & (aList_t t)))
  (decreases (hashMap_remove_from_list_loop_decreases key ls))
  =
  begin match ls with
  | AList_Cons ckey x tl ->
    if ckey = key
    then
      let (mv_ls, _) = core_mem_replace ls AList_Nil in
      begin match mv_ls with
      | AList_Cons _ cvalue tl1 -> Ok ((Some cvalue), tl1)
      | AList_Nil -> Fail Failure
      end
    else
      let* (o, tl1) = hashMap_remove_from_list_loop key tl in
      Ok (o, (AList_Cons ckey x tl1))
  | AList_Nil -> Ok (None, AList_Nil)
  end

(** [hashmap::{hashmap::HashMap<T>}::remove_from_list]:
    Source: 'tests/src/hashmap.rs', lines 274:4-300:5 *)
let hashMap_remove_from_list
  (#t : Type0) (key : usize) (ls : aList_t t) :
  result ((option t) & (aList_t t))
  =
  hashMap_remove_from_list_loop key ls

(** [hashmap::{hashmap::HashMap<T>}::remove]:
    Source: 'tests/src/hashmap.rs', lines 303:4-315:5 *)
let hashMap_remove
  (#t : Type0) (self : hashMap_t t) (key : usize) :
  result ((option t) & (hashMap_t t))
  =
  let* hash = hash_key key in
  let i = alloc_vec_Vec_len self.slots in
  let* hash_mod = usize_rem hash i in
  let* (a, index_mut_back) =
    alloc_vec_Vec_index_mut (core_slice_index_SliceIndexUsizeSliceInst (aList_t
      t)) self.slots hash_mod
  in
  let* (x, a1) = hashMap_remove_from_list key a in
  begin match x with
  | None -> let v = index_mut_back a1 in Ok (None, { self with slots = v })
  | Some _ ->
    let* i1 = usize_sub self.num_entries 1 in
    let v = index_mut_back a1 in
    Ok (x, { self with num_entries = i1; slots = v })
  end

(** [hashmap::insert_on_disk]:
    Source: 'tests/src/hashmap.rs', lines 334:0-341:1 *)
let insert_on_disk
  (key : usize) (value : u64) (st : state) : result (state & unit) =
  let* (st1, hm) = utils_deserialize st in
  let* hm1 = hashMap_insert hm key value in
  utils_serialize hm1 st1

