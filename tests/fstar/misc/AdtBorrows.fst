(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [adt_borrows] *)
module AdtBorrows
open Primitives

#set-options "--z3rlimit 50 --fuel 1 --ifuel 1"

(** [adt_borrows::SharedWrapper]
    Source: 'tests/src/adt-borrows.rs', lines 7:0-7:35 *)
type sharedWrapper_t (t : Type0) = t

(** [adt_borrows::{adt_borrows::SharedWrapper<'a, T>}::create]:
    Source: 'tests/src/adt-borrows.rs', lines 10:4-12:5 *)
let sharedWrapper_create (#t : Type0) (x : t) : result (sharedWrapper_t t) =
  Ok x

(** [adt_borrows::{adt_borrows::SharedWrapper<'a, T>}::unwrap]:
    Source: 'tests/src/adt-borrows.rs', lines 14:4-16:5 *)
let sharedWrapper_unwrap (#t : Type0) (self : sharedWrapper_t t) : result t =
  Ok self

(** [adt_borrows::use_shared_wrapper]:
    Source: 'tests/src/adt-borrows.rs', lines 19:0-24:1 *)
let use_shared_wrapper : result unit =
  let* w = sharedWrapper_create 0 in
  let* p = sharedWrapper_unwrap w in
  if 0 = p then Ok () else Fail Failure

(** [adt_borrows::SharedWrapper1]
    Source: 'tests/src/adt-borrows.rs', lines 26:0-28:1 *)
type sharedWrapper1_t (t : Type0) = { x : t; }

(** [adt_borrows::{adt_borrows::SharedWrapper1<'a, T>}#1::create]:
    Source: 'tests/src/adt-borrows.rs', lines 31:4-33:5 *)
let sharedWrapper1_create (#t : Type0) (x : t) : result (sharedWrapper1_t t) =
  Ok { x }

(** [adt_borrows::{adt_borrows::SharedWrapper1<'a, T>}#1::unwrap]:
    Source: 'tests/src/adt-borrows.rs', lines 35:4-37:5 *)
let sharedWrapper1_unwrap (#t : Type0) (self : sharedWrapper1_t t) : result t =
  Ok self.x

(** [adt_borrows::use_shared_wrapper1]:
    Source: 'tests/src/adt-borrows.rs', lines 40:0-45:1 *)
let use_shared_wrapper1 : result unit =
  let* w = sharedWrapper1_create 0 in
  let* p = sharedWrapper1_unwrap w in
  if 0 = p then Ok () else Fail Failure

(** [adt_borrows::SharedWrapper2]
    Source: 'tests/src/adt-borrows.rs', lines 47:0-50:1 *)
type sharedWrapper2_t (t : Type0) = { x : t; y : t; }

(** [adt_borrows::{adt_borrows::SharedWrapper2<'a, 'b, T>}#2::create]:
    Source: 'tests/src/adt-borrows.rs', lines 53:4-55:5 *)
let sharedWrapper2_create
  (#t : Type0) (x : t) (y : t) : result (sharedWrapper2_t t) =
  Ok { x; y }

(** [adt_borrows::{adt_borrows::SharedWrapper2<'a, 'b, T>}#2::unwrap]:
    Source: 'tests/src/adt-borrows.rs', lines 57:4-59:5 *)
let sharedWrapper2_unwrap
  (#t : Type0) (self : sharedWrapper2_t t) : result (t & t) =
  Ok (self.x, self.y)

(** [adt_borrows::use_shared_wrapper2]:
    Source: 'tests/src/adt-borrows.rs', lines 62:0-69:1 *)
let use_shared_wrapper2 : result unit =
  let* w = sharedWrapper2_create 0 1 in
  let* p = sharedWrapper2_unwrap w in
  let (px, py) = p in
  if 0 = px then if 1 = py then Ok () else Fail Failure else Fail Failure

(** [adt_borrows::MutWrapper]
    Source: 'tests/src/adt-borrows.rs', lines 71:0-71:36 *)
type mutWrapper_t (t : Type0) = t

(** [adt_borrows::{adt_borrows::MutWrapper<'a, T>}#3::create]:
    Source: 'tests/src/adt-borrows.rs', lines 74:4-76:5 *)
let mutWrapper_create
  (#t : Type0) (x : t) : result ((mutWrapper_t t) & (mutWrapper_t t -> t)) =
  Ok (x, fun ret -> ret)

(** [adt_borrows::{adt_borrows::MutWrapper<'a, T>}#3::unwrap]:
    Source: 'tests/src/adt-borrows.rs', lines 78:4-80:5 *)
let mutWrapper_unwrap
  (#t : Type0) (self : mutWrapper_t t) : result (t & (t -> mutWrapper_t t)) =
  let back = fun ret -> ret in Ok (self, back)

(** [adt_borrows::use_mut_wrapper]:
    Source: 'tests/src/adt-borrows.rs', lines 83:0-89:1 *)
let use_mut_wrapper : result unit =
  let* (w, create_back) = mutWrapper_create 0 in
  let* (p, unwrap_back) = mutWrapper_unwrap w in
  let* p1 = i32_add p 1 in
  let x = create_back (unwrap_back p1) in
  if x = 1 then Ok () else Fail Failure

(** [adt_borrows::MutWrapper1]
    Source: 'tests/src/adt-borrows.rs', lines 91:0-93:1 *)
type mutWrapper1_t (t : Type0) = { x : t; }

(** [adt_borrows::{adt_borrows::MutWrapper1<'a, T>}#4::create]:
    Source: 'tests/src/adt-borrows.rs', lines 96:4-98:5 *)
let mutWrapper1_create
  (#t : Type0) (x : t) : result ((mutWrapper1_t t) & (mutWrapper1_t t -> t)) =
  let back = fun ret -> ret.x in Ok ({ x }, back)

(** [adt_borrows::{adt_borrows::MutWrapper1<'a, T>}#4::unwrap]:
    Source: 'tests/src/adt-borrows.rs', lines 100:4-102:5 *)
let mutWrapper1_unwrap
  (#t : Type0) (self : mutWrapper1_t t) : result (t & (t -> mutWrapper1_t t)) =
  let back = fun ret -> { x = ret } in Ok (self.x, back)

(** [adt_borrows::use_mut_wrapper1]:
    Source: 'tests/src/adt-borrows.rs', lines 105:0-111:1 *)
let use_mut_wrapper1 : result unit =
  let* (w, create_back) = mutWrapper1_create 0 in
  let* (p, unwrap_back) = mutWrapper1_unwrap w in
  let* p1 = i32_add p 1 in
  let x = create_back (unwrap_back p1) in
  if x = 1 then Ok () else Fail Failure

(** [adt_borrows::MutWrapper2]
    Source: 'tests/src/adt-borrows.rs', lines 113:0-116:1 *)
type mutWrapper2_t (t : Type0) = { x : t; y : t; }

(** [adt_borrows::{adt_borrows::MutWrapper2<'a, 'b, T>}#5::create]:
    Source: 'tests/src/adt-borrows.rs', lines 119:4-121:5 *)
let mutWrapper2_create
  (#t : Type0) (x : t) (y : t) :
  result ((mutWrapper2_t t) & (mutWrapper2_t t -> t) & (mutWrapper2_t t -> t))
  =
  let back'a = fun ret -> ret.x in
  let back'b = fun ret -> ret.y in
  Ok ({ x; y }, back'a, back'b)

(** [adt_borrows::{adt_borrows::MutWrapper2<'a, 'b, T>}#5::unwrap]:
    Source: 'tests/src/adt-borrows.rs', lines 123:4-125:5 *)
let mutWrapper2_unwrap
  (#t : Type0) (self : mutWrapper2_t t) :
  result ((t & t) & (t -> mutWrapper2_t t) & (t -> mutWrapper2_t t))
  =
  let back'a = fun ret -> { self with x = ret } in
  let back'b = fun ret -> { self with y = ret } in
  Ok ((self.x, self.y), back'a, back'b)

(** [adt_borrows::use_mut_wrapper2]:
    Source: 'tests/src/adt-borrows.rs', lines 128:0-137:1 *)
let use_mut_wrapper2 : result unit =
  let* (w, create_back, create_back1) = mutWrapper2_create 0 10 in
  let* (p, unwrap_back, unwrap_back1) = mutWrapper2_unwrap w in
  let (px, py) = p in
  let* px1 = i32_add px 1 in
  let* py1 = i32_add py 1 in
  let x = create_back { w with x = (unwrap_back px1).x } in
  if x = 1
  then
    let y = create_back1 { w with y = (unwrap_back1 py1).y } in
    if y = 11 then Ok () else Fail Failure
  else Fail Failure

(** [adt_borrows::array_shared_borrow]:
    Source: 'tests/src/adt-borrows.rs', lines 146:0-148:1 *)
let array_shared_borrow (#n : usize) (x : array u32 n) : result (array u32 n) =
  Ok x

(** [adt_borrows::array_mut_borrow]:
    Source: 'tests/src/adt-borrows.rs', lines 150:0-152:1 *)
let array_mut_borrow
  (#n : usize) (x : array u32 n) :
  result ((array u32 n) & (array u32 n -> array u32 n))
  =
  Ok (x, fun ret -> ret)

(** [adt_borrows::boxed_slice_shared_borrow]:
    Source: 'tests/src/adt-borrows.rs', lines 154:0-156:1 *)
let boxed_slice_shared_borrow (x : slice u32) : result (slice u32) =
  Ok x

(** [adt_borrows::boxed_slice_mut_borrow]:
    Source: 'tests/src/adt-borrows.rs', lines 158:0-160:1 *)
let boxed_slice_mut_borrow
  (x : slice u32) : result ((slice u32) & (slice u32 -> slice u32)) =
  Ok (x, fun ret -> ret)

(** [adt_borrows::SharedList]
    Source: 'tests/src/adt-borrows.rs', lines 165:0-168:1 *)
type sharedList_t (t : Type0) =
| SharedList_Nil : sharedList_t t
| SharedList_Cons : t -> sharedList_t t -> sharedList_t t

(** [adt_borrows::{adt_borrows::SharedList<'a, T>}#6::push]:
    Source: 'tests/src/adt-borrows.rs', lines 172:4-174:5 *)
let sharedList_push
  (#t : Type0) (self : sharedList_t t) (x : t) : result (sharedList_t t) =
  Ok (SharedList_Cons x self)

(** [adt_borrows::{adt_borrows::SharedList<'a, T>}#6::pop]:
    Source: 'tests/src/adt-borrows.rs', lines 176:4-182:5 *)
let sharedList_pop
  (#t : Type0) (self : sharedList_t t) : result (t & (sharedList_t t)) =
  begin match self with
  | SharedList_Nil -> Fail Failure
  | SharedList_Cons hd tl -> Ok (hd, tl)
  end

(** [adt_borrows::MutList]
    Source: 'tests/src/adt-borrows.rs', lines 185:0-188:1 *)
type mutList_t (t : Type0) =
| MutList_Nil : mutList_t t
| MutList_Cons : t -> mutList_t t -> mutList_t t

(** [adt_borrows::{adt_borrows::MutList<'a, T>}#7::push]:
    Source: 'tests/src/adt-borrows.rs', lines 192:4-194:5 *)
let mutList_push
  (#t : Type0) (self : mutList_t t) (x : t) :
  result ((mutList_t t) & (mutList_t t -> ((mutList_t t) & t)))
  =
  let back =
    fun ret ->
      let (x1, ml) =
        begin match ret with
        | MutList_Cons x2 ml1 -> (x2, ml1)
        | _ -> (x, self)
        end in
      (ml, x1) in
  Ok (MutList_Cons x self, back)

(** [adt_borrows::{adt_borrows::MutList<'a, T>}#7::pop]:
    Source: 'tests/src/adt-borrows.rs', lines 196:4-202:5 *)
let mutList_pop
  (#t : Type0) (self : mutList_t t) :
  result ((t & (mutList_t t)) & ((t & (mutList_t t)) -> mutList_t t))
  =
  begin match self with
  | MutList_Nil -> Fail Failure
  | MutList_Cons hd tl ->
    let back = fun ret -> let (x, ml) = ret in MutList_Cons x ml in
    Ok ((hd, tl), back)
  end

(** [adt_borrows::wrap_shared_in_option]:
    Source: 'tests/src/adt-borrows.rs', lines 205:0-207:1 *)
let wrap_shared_in_option (#t : Type0) (x : t) : result (option t) =
  Ok (Some x)

(** [adt_borrows::wrap_mut_in_option]:
    Source: 'tests/src/adt-borrows.rs', lines 209:0-211:1 *)
let wrap_mut_in_option
  (#t : Type0) (x : t) : result ((option t) & (option t -> t)) =
  let back = fun ret -> begin match ret with | Some x1 -> x1 | _ -> x end in
  Ok (Some x, back)

(** [adt_borrows::List]
    Source: 'tests/src/adt-borrows.rs', lines 213:0-216:1 *)
type list_t (t : Type0) =
| List_Cons : t -> list_t t -> list_t t
| List_Nil : list_t t

(** [adt_borrows::nth_shared]: loop 0:
    Source: 'tests/src/adt-borrows.rs', lines 219:4-228:1 *)
let rec nth_shared_loop
  (#t : Type0) (ls : list_t t) (i : u32) : result (option t) =
  begin match ls with
  | List_Cons x tl ->
    if i = 0
    then Ok (Some x)
    else let* i1 = u32_sub i 1 in nth_shared_loop tl i1
  | List_Nil -> Ok None
  end

(** [adt_borrows::nth_shared]:
    Source: 'tests/src/adt-borrows.rs', lines 218:0-228:1 *)
let nth_shared (#t : Type0) (ls : list_t t) (i : u32) : result (option t) =
  nth_shared_loop ls i

(** [adt_borrows::nth_mut]: loop 0:
    Source: 'tests/src/adt-borrows.rs', lines 231:4-240:1 *)
let rec nth_mut_loop
  (#t : Type0) (ls : list_t t) (i : u32) :
  result ((option t) & (option t -> list_t t))
  =
  begin match ls with
  | List_Cons x tl ->
    if i = 0
    then
      let back =
        fun ret ->
          let x1 = begin match ret with | Some x2 -> x2 | _ -> x end in
          List_Cons x1 tl in
      Ok (Some x, back)
    else
      let* i1 = u32_sub i 1 in
      let* (o, back) = nth_mut_loop tl i1 in
      let back1 = fun ret -> let tl1 = back ret in List_Cons x tl1 in
      Ok (o, back1)
  | List_Nil -> let back = fun ret -> List_Nil in Ok (None, back)
  end

(** [adt_borrows::nth_mut]:
    Source: 'tests/src/adt-borrows.rs', lines 230:0-240:1 *)
let nth_mut
  (#t : Type0) (ls : list_t t) (i : u32) :
  result ((option t) & (option t -> list_t t))
  =
  nth_mut_loop ls i

