(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [demo] *)
module Demo
open Primitives

#set-options "--z3rlimit 50 --fuel 1 --ifuel 1"

(** [core::num::{u32}::wrapping_add]:
    Source: '/rustc/library/core/src/num/uint_macros.rs', lines 2315:8-2315:58
    Name pattern: [core::num::{u32}::wrapping_add] *)
assume val core_num_U32_wrapping_add : u32 -> u32 -> result u32

(** [core::num::{u32}::wrapping_sub]:
    Source: '/rustc/library/core/src/num/uint_macros.rs', lines 2352:8-2352:58
    Name pattern: [core::num::{u32}::wrapping_sub] *)
assume val core_num_U32_wrapping_sub : u32 -> u32 -> result u32

(** [demo::choose]:
    Source: 'tests/src/demo.rs', lines 8:0-14:1 *)
let choose
  (#t : Type0) (b : bool) (x : t) (y : t) : result (t & (t -> (t & t))) =
  if b
  then let back = fun ret -> (ret, y) in Ok (x, back)
  else let back = fun ret -> (x, ret) in Ok (y, back)

(** [demo::mul2_add1]:
    Source: 'tests/src/demo.rs', lines 16:0-18:1 *)
let mul2_add1 (x : u32) : result u32 =
  let* i = u32_add x x in u32_add i 1

(** [demo::use_mul2_add1]:
    Source: 'tests/src/demo.rs', lines 20:0-22:1 *)
let use_mul2_add1 (x : u32) (y : u32) : result u32 =
  let* i = mul2_add1 x in u32_add i y

(** [demo::incr]:
    Source: 'tests/src/demo.rs', lines 24:0-26:1 *)
let incr (x : u32) : result u32 =
  u32_add x 1

(** [demo::use_incr]:
    Source: 'tests/src/demo.rs', lines 28:0-33:1 *)
let use_incr : result unit =
  let* x = incr 0 in let* x1 = incr x in let* _ = incr x1 in Ok ()

(** [demo::CList]
    Source: 'tests/src/demo.rs', lines 37:0-40:1 *)
type cList_t (t : Type0) =
| CList_CCons : t -> cList_t t -> cList_t t
| CList_CNil : cList_t t

(** [demo::list_nth]:
    Source: 'tests/src/demo.rs', lines 42:0-55:1 *)
let rec list_nth (#t : Type0) (n : nat) (l : cList_t t) (i : u32) : result t =
  if is_zero n
  then Fail OutOfFuel
  else
    let n1 = decrease n in
    begin match l with
    | CList_CCons x tl ->
      if i = 0 then Ok x else let* i1 = u32_sub i 1 in list_nth n1 tl i1
    | CList_CNil -> Fail Failure
    end

(** [demo::list_nth1]: loop 0:
    Source: 'tests/src/demo.rs', lines 58:4-66:1 *)
let rec list_nth1_loop
  (#t : Type0) (n : nat) (l : cList_t t) (i : u32) : result t =
  if is_zero n
  then Fail OutOfFuel
  else
    let n1 = decrease n in
    begin match l with
    | CList_CCons x tl ->
      if i = 0 then Ok x else let* i1 = u32_sub i 1 in list_nth1_loop n1 tl i1
    | CList_CNil -> Fail Failure
    end

(** [demo::list_nth1]:
    Source: 'tests/src/demo.rs', lines 57:0-66:1 *)
let list_nth1 (#t : Type0) (n : nat) (l : cList_t t) (i : u32) : result t =
  list_nth1_loop n l i

(** [demo::list_nth_mut]:
    Source: 'tests/src/demo.rs', lines 68:0-81:1 *)
let rec list_nth_mut
  (#t : Type0) (n : nat) (l : cList_t t) (i : u32) :
  result (t & (t -> cList_t t))
  =
  if is_zero n
  then Fail OutOfFuel
  else
    let n1 = decrease n in
    begin match l with
    | CList_CCons x tl ->
      if i = 0
      then let back = fun ret -> CList_CCons ret tl in Ok (x, back)
      else
        let* i1 = u32_sub i 1 in
        let* (x1, list_nth_mut_back) = list_nth_mut n1 tl i1 in
        let back =
          fun ret -> let tl1 = list_nth_mut_back ret in CList_CCons x tl1
        in
        Ok (x1, back)
    | CList_CNil -> Fail Failure
    end

(** [demo::i32_id]:
    Source: 'tests/src/demo.rs', lines 83:0-89:1 *)
let rec i32_id (n : nat) (i : i32) : result i32 =
  if is_zero n
  then Fail OutOfFuel
  else
    let n1 = decrease n in
    if i = 0
    then Ok 0
    else let* i1 = i32_sub i 1 in let* i2 = i32_id n1 i1 in i32_add i2 1

(** [demo::list_tail]:
    Source: 'tests/src/demo.rs', lines 91:0-96:1 *)
let rec list_tail
  (#t : Type0) (n : nat) (l : cList_t t) :
  result ((cList_t t) & (cList_t t -> cList_t t))
  =
  if is_zero n
  then Fail OutOfFuel
  else
    let n1 = decrease n in
    begin match l with
    | CList_CCons x tl ->
      let* (c, list_tail_back) = list_tail n1 tl in
      let back = fun ret -> let tl1 = list_tail_back ret in CList_CCons x tl1
      in
      Ok (c, back)
    | CList_CNil -> Ok (CList_CNil, (fun ret -> ret))
    end

(** Trait declaration: [demo::Counter]
    Source: 'tests/src/demo.rs', lines 100:0-102:1 *)
noeq type counter_t (self : Type0) = { incr : self -> result (usize & self); }

(** [demo::{demo::Counter for usize}::incr]:
    Source: 'tests/src/demo.rs', lines 105:4-109:5 *)
let counterUsize_incr (self : usize) : result (usize & usize) =
  let* self1 = usize_add self 1 in Ok (self, self1)

(** Trait implementation: [demo::{demo::Counter for usize}]
    Source: 'tests/src/demo.rs', lines 104:0-110:1 *)
let counterUsize : counter_t usize = { incr = counterUsize_incr; }

(** [demo::use_counter]:
    Source: 'tests/src/demo.rs', lines 112:0-114:1 *)
let use_counter
  (#t : Type0) (counterInst : counter_t t) (cnt : t) : result (usize & t) =
  counterInst.incr cnt

(** [demo::mod_add]:
    Source: 'tests/src/demo.rs', lines 117:0-125:1 *)
let mod_add (a : u32) (b : u32) : result u32 =
  if a < 3329
  then
    if b < 3329
    then
      let* sum = u32_add a b in
      let* res = core_num_U32_wrapping_sub sum 3329 in
      let* mask = u32_shr #I32 res 16 in
      let q = u32_and 3329 mask in
      core_num_U32_wrapping_add res q
    else Fail Failure
  else Fail Failure

