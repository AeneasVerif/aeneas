(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [demo] *)
module Demo
open Primitives

#set-options "--z3rlimit 50 --fuel 1 --ifuel 1"

(** [demo::choose]:
    Source: 'src/demo.rs', lines 5:0-5:70 *)
let choose
  (t : Type0) (b : bool) (x : t) (y : t) : result (t & (t -> result (t & t))) =
  if b
  then let back = fun ret -> Return (ret, y) in Return (x, back)
  else let back = fun ret -> Return (x, ret) in Return (y, back)

(** [demo::mul3_add1]:
    Source: 'src/demo.rs', lines 13:0-13:31 *)
let mul3_add1 (x : u32) : result u32 =
  let* i = u32_add x x in let* i1 = u32_add i x in u32_add i1 1

(** [demo::use_mul3_add1]:
    Source: 'src/demo.rs', lines 17:0-17:43 *)
let use_mul3_add1 (x : u32) (y : u32) : result u32 =
  let* i = mul3_add1 x in u32_add i y

(** [demo::incr]:
    Source: 'src/demo.rs', lines 21:0-21:31 *)
let incr (x : u32) : result u32 =
  u32_add x 1

(** [demo::use_incr]:
    Source: 'src/demo.rs', lines 25:0-25:17 *)
let use_incr : result unit =
  let* x = incr 0 in let* x1 = incr x in let* _ = incr x1 in Return ()

(** [demo::CList]
    Source: 'src/demo.rs', lines 34:0-34:17 *)
type cList_t (t : Type0) =
| CList_CCons : t -> cList_t t -> cList_t t
| CList_CNil : cList_t t

(** [demo::list_nth]:
    Source: 'src/demo.rs', lines 39:0-39:56 *)
let rec list_nth (t : Type0) (n : nat) (l : cList_t t) (i : u32) : result t =
  if is_zero n
  then Fail OutOfFuel
  else
    let n1 = decrease n in
    begin match l with
    | CList_CCons x tl ->
      if i = 0 then Return x else let* i1 = u32_sub i 1 in list_nth t n1 tl i1
    | CList_CNil -> Fail Failure
    end

(** [demo::list_nth1]: loop 0:
    Source: 'src/demo.rs', lines 54:0-63:1 *)
let rec list_nth1_loop
  (t : Type0) (n : nat) (l : cList_t t) (i : u32) : result t =
  if is_zero n
  then Fail OutOfFuel
  else
    let n1 = decrease n in
    begin match l with
    | CList_CCons x tl ->
      if i = 0
      then Return x
      else let* i1 = u32_sub i 1 in list_nth1_loop t n1 tl i1
    | CList_CNil -> Fail Failure
    end

(** [demo::list_nth1]:
    Source: 'src/demo.rs', lines 54:0-54:65 *)
let list_nth1 (t : Type0) (n : nat) (l : cList_t t) (i : u32) : result t =
  list_nth1_loop t n l i

(** Trait declaration: [demo::Counter]
    Source: 'src/demo.rs', lines 67:0-67:17 *)
noeq type counter_t (self : Type0) = { incr : self -> result (usize & self); }

(** [demo::{(demo::Counter for usize)}::incr]:
    Source: 'src/demo.rs', lines 72:4-72:31 *)
let counterUsize_incr (self : usize) : result (usize & usize) =
  let* self1 = usize_add self 1 in Return (self, self1)

(** Trait implementation: [demo::{(demo::Counter for usize)}]
    Source: 'src/demo.rs', lines 71:0-71:22 *)
let counterUsize : counter_t usize = { incr = counterUsize_incr; }

(** [demo::use_counter]:
    Source: 'src/demo.rs', lines 79:0-79:59 *)
let use_counter
  (t : Type0) (counterInst : counter_t t) (cnt : t) : result (usize & t) =
  let* (_, cnt1) = counterInst.incr cnt in counterInst.incr cnt1

