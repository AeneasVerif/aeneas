(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [external]: function definitions *)
module External.Funs
open Primitives
include External.Types
include External.Opaque

#set-options "--z3rlimit 50 --fuel 1 --ifuel 1"

(** [external::swap] *)
let swap_fwd (t : Type0) (x : t) (y : t) (st : state) : result (state & unit) =
  begin match core_mem_swap_fwd t x y st with
  | Fail -> Fail
  | Return (st0, _) ->
    begin match core_mem_swap_back0 t x y st with
    | Fail -> Fail
    | Return _ ->
      begin match core_mem_swap_back1 t x y st with
      | Fail -> Fail
      | Return _ -> Return (st0, ())
      end
    end
  end

(** [external::swap] *)
let swap_back (t : Type0) (x : t) (y : t) (st : state) : result (t & t) =
  begin match core_mem_swap_back0 t x y st with
  | Fail -> Fail
  | Return x0 ->
    begin match core_mem_swap_back1 t x y st with
    | Fail -> Fail
    | Return y0 -> Return (x0, y0)
    end
  end

(** [external::test_new_non_zero_u32] *)
let test_new_non_zero_u32_fwd
  (x : u32) (st : state) : result (state & core_num_nonzero_non_zero_u32_t) =
  begin match core_num_nonzero_non_zero_u32_new_fwd x st with
  | Fail -> Fail
  | Return (st0, opt) ->
    begin match
      core_option_option_unwrap_fwd core_num_nonzero_non_zero_u32_t opt st0
      with
    | Fail -> Fail
    | Return (st1, nzu) -> Return (st1, nzu)
    end
  end

(** [external::test_vec] *)
let test_vec_fwd : result unit =
  let v = vec_new u32 in
  begin match vec_push_back u32 v 0 with
  | Fail -> Fail
  | Return _ -> Return ()
  end

(** Unit test for [external::test_vec] *)
let _ = assert_norm (test_vec_fwd = Return ())

(** [external::custom_swap] *)
let custom_swap_fwd
  (t : Type0) (x : t) (y : t) (st : state) : result (state & t) =
  begin match core_mem_swap_fwd t x y st with
  | Fail -> Fail
  | Return (st0, _) ->
    begin match core_mem_swap_back0 t x y st with
    | Fail -> Fail
    | Return x0 ->
      begin match core_mem_swap_back1 t x y st with
      | Fail -> Fail
      | Return _ -> Return (st0, x0)
      end
    end
  end

(** [external::custom_swap] *)
let custom_swap_back
  (t : Type0) (x : t) (y : t) (st : state) (ret : t) : result (t & t) =
  begin match core_mem_swap_back0 t x y st with
  | Fail -> Fail
  | Return _ ->
    begin match core_mem_swap_back1 t x y st with
    | Fail -> Fail
    | Return y0 -> Return (ret, y0)
    end
  end

(** [external::test_custom_swap] *)
let test_custom_swap_fwd
  (x : u32) (y : u32) (st : state) : result (state & unit) =
  begin match custom_swap_fwd u32 x y st with
  | Fail -> Fail
  | Return (st0, _) -> Return (st0, ())
  end

(** [external::test_custom_swap] *)
let test_custom_swap_back
  (x : u32) (y : u32) (st : state) : result (u32 & u32) =
  begin match custom_swap_back u32 x y st 1 with
  | Fail -> Fail
  | Return (x0, y0) -> Return (x0, y0)
  end

(** [external::test_swap_non_zero] *)
let test_swap_non_zero_fwd (x : u32) (st : state) : result (state & u32) =
  begin match swap_fwd u32 x 0 st with
  | Fail -> Fail
  | Return (st0, _) ->
    begin match swap_back u32 x 0 st with
    | Fail -> Fail
    | Return (x0, _) -> if x0 = 0 then Fail else Return (st0, x0)
    end
  end

