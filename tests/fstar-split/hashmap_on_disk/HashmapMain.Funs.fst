(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [hashmap_main]: function definitions *)
module HashmapMain.Funs
open Primitives
include HashmapMain.Types
include HashmapMain.FunsExternal
include HashmapMain.Clauses

#set-options "--z3rlimit 50 --fuel 1 --ifuel 1"

(** [hashmap_main::hashmap::hash_key]: forward function
    Source: 'src/hashmap.rs', lines 27:0-27:32 *)
let hashmap_hash_key (k : usize) : result usize =
  Return k

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::allocate_slots]: loop 0: forward function
    Source: 'src/hashmap.rs', lines 50:4-56:5 *)
let rec hashmap_HashMap_allocate_slots_loop
  (t : Type0) (slots : alloc_vec_Vec (hashmap_List_t t)) (n : usize) :
  Tot (result (alloc_vec_Vec (hashmap_List_t t)))
  (decreases (hashmap_HashMap_allocate_slots_loop_decreases t slots n))
  =
  if n > 0
  then
    let* slots1 = alloc_vec_Vec_push (hashmap_List_t t) slots Hashmap_List_Nil
      in
    let* n1 = usize_sub n 1 in
    hashmap_HashMap_allocate_slots_loop t slots1 n1
  else Return slots

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::allocate_slots]: forward function
    Source: 'src/hashmap.rs', lines 50:4-50:76 *)
let hashmap_HashMap_allocate_slots
  (t : Type0) (slots : alloc_vec_Vec (hashmap_List_t t)) (n : usize) :
  result (alloc_vec_Vec (hashmap_List_t t))
  =
  hashmap_HashMap_allocate_slots_loop t slots n

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::new_with_capacity]: forward function
    Source: 'src/hashmap.rs', lines 59:4-63:13 *)
let hashmap_HashMap_new_with_capacity
  (t : Type0) (capacity : usize) (max_load_dividend : usize)
  (max_load_divisor : usize) :
  result (hashmap_HashMap_t t)
  =
  let* slots =
    hashmap_HashMap_allocate_slots t (alloc_vec_Vec_new (hashmap_List_t t))
      capacity in
  let* i = usize_mul capacity max_load_dividend in
  let* i1 = usize_div i max_load_divisor in
  Return
    {
      num_entries = 0;
      max_load_factor = (max_load_dividend, max_load_divisor);
      max_load = i1;
      slots = slots
    }

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::new]: forward function
    Source: 'src/hashmap.rs', lines 75:4-75:24 *)
let hashmap_HashMap_new (t : Type0) : result (hashmap_HashMap_t t) =
  hashmap_HashMap_new_with_capacity t 32 4 5

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::clear]: loop 0: merged forward/backward function
    (there is a single backward function, and the forward function returns ())
    Source: 'src/hashmap.rs', lines 80:4-88:5 *)
let rec hashmap_HashMap_clear_loop
  (t : Type0) (slots : alloc_vec_Vec (hashmap_List_t t)) (i : usize) :
  Tot (result (alloc_vec_Vec (hashmap_List_t t)))
  (decreases (hashmap_HashMap_clear_loop_decreases t slots i))
  =
  let i1 = alloc_vec_Vec_len (hashmap_List_t t) slots in
  if i < i1
  then
    let* i2 = usize_add i 1 in
    let* slots1 =
      alloc_vec_Vec_index_mut_back (hashmap_List_t t) usize
        (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t)) slots i
        Hashmap_List_Nil in
    hashmap_HashMap_clear_loop t slots1 i2
  else Return slots

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::clear]: merged forward/backward function
    (there is a single backward function, and the forward function returns ())
    Source: 'src/hashmap.rs', lines 80:4-80:27 *)
let hashmap_HashMap_clear
  (t : Type0) (self : hashmap_HashMap_t t) : result (hashmap_HashMap_t t) =
  let* v = hashmap_HashMap_clear_loop t self.slots 0 in
  Return { self with num_entries = 0; slots = v }

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::len]: forward function
    Source: 'src/hashmap.rs', lines 90:4-90:30 *)
let hashmap_HashMap_len
  (t : Type0) (self : hashmap_HashMap_t t) : result usize =
  Return self.num_entries

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::insert_in_list]: loop 0: forward function
    Source: 'src/hashmap.rs', lines 97:4-114:5 *)
let rec hashmap_HashMap_insert_in_list_loop
  (t : Type0) (key : usize) (value : t) (ls : hashmap_List_t t) :
  Tot (result bool)
  (decreases (hashmap_HashMap_insert_in_list_loop_decreases t key value ls))
  =
  begin match ls with
  | Hashmap_List_Cons ckey _ tl ->
    if ckey = key
    then Return false
    else hashmap_HashMap_insert_in_list_loop t key value tl
  | Hashmap_List_Nil -> Return true
  end

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::insert_in_list]: forward function
    Source: 'src/hashmap.rs', lines 97:4-97:71 *)
let hashmap_HashMap_insert_in_list
  (t : Type0) (key : usize) (value : t) (ls : hashmap_List_t t) : result bool =
  hashmap_HashMap_insert_in_list_loop t key value ls

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::insert_in_list]: loop 0: backward function 0
    Source: 'src/hashmap.rs', lines 97:4-114:5 *)
let rec hashmap_HashMap_insert_in_list_loop_back
  (t : Type0) (key : usize) (value : t) (ls : hashmap_List_t t) :
  Tot (result (hashmap_List_t t))
  (decreases (hashmap_HashMap_insert_in_list_loop_decreases t key value ls))
  =
  begin match ls with
  | Hashmap_List_Cons ckey cvalue tl ->
    if ckey = key
    then Return (Hashmap_List_Cons ckey value tl)
    else
      let* tl1 = hashmap_HashMap_insert_in_list_loop_back t key value tl in
      Return (Hashmap_List_Cons ckey cvalue tl1)
  | Hashmap_List_Nil -> Return (Hashmap_List_Cons key value Hashmap_List_Nil)
  end

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::insert_in_list]: backward function 0
    Source: 'src/hashmap.rs', lines 97:4-97:71 *)
let hashmap_HashMap_insert_in_list_back
  (t : Type0) (key : usize) (value : t) (ls : hashmap_List_t t) :
  result (hashmap_List_t t)
  =
  hashmap_HashMap_insert_in_list_loop_back t key value ls

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::insert_no_resize]: merged forward/backward function
    (there is a single backward function, and the forward function returns ())
    Source: 'src/hashmap.rs', lines 117:4-117:54 *)
let hashmap_HashMap_insert_no_resize
  (t : Type0) (self : hashmap_HashMap_t t) (key : usize) (value : t) :
  result (hashmap_HashMap_t t)
  =
  let* hash = hashmap_hash_key key in
  let i = alloc_vec_Vec_len (hashmap_List_t t) self.slots in
  let* hash_mod = usize_rem hash i in
  let* l =
    alloc_vec_Vec_index_mut (hashmap_List_t t) usize
      (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t))
      self.slots hash_mod in
  let* inserted = hashmap_HashMap_insert_in_list t key value l in
  if inserted
  then
    let* i1 = usize_add self.num_entries 1 in
    let* l1 = hashmap_HashMap_insert_in_list_back t key value l in
    let* v =
      alloc_vec_Vec_index_mut_back (hashmap_List_t t) usize
        (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t))
        self.slots hash_mod l1 in
    Return { self with num_entries = i1; slots = v }
  else
    let* l1 = hashmap_HashMap_insert_in_list_back t key value l in
    let* v =
      alloc_vec_Vec_index_mut_back (hashmap_List_t t) usize
        (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t))
        self.slots hash_mod l1 in
    Return { self with slots = v }

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::move_elements_from_list]: loop 0: merged forward/backward function
    (there is a single backward function, and the forward function returns ())
    Source: 'src/hashmap.rs', lines 183:4-196:5 *)
let rec hashmap_HashMap_move_elements_from_list_loop
  (t : Type0) (ntable : hashmap_HashMap_t t) (ls : hashmap_List_t t) :
  Tot (result (hashmap_HashMap_t t))
  (decreases (
    hashmap_HashMap_move_elements_from_list_loop_decreases t ntable ls))
  =
  begin match ls with
  | Hashmap_List_Cons k v tl ->
    let* ntable1 = hashmap_HashMap_insert_no_resize t ntable k v in
    hashmap_HashMap_move_elements_from_list_loop t ntable1 tl
  | Hashmap_List_Nil -> Return ntable
  end

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::move_elements_from_list]: merged forward/backward function
    (there is a single backward function, and the forward function returns ())
    Source: 'src/hashmap.rs', lines 183:4-183:72 *)
let hashmap_HashMap_move_elements_from_list
  (t : Type0) (ntable : hashmap_HashMap_t t) (ls : hashmap_List_t t) :
  result (hashmap_HashMap_t t)
  =
  hashmap_HashMap_move_elements_from_list_loop t ntable ls

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::move_elements]: loop 0: merged forward/backward function
    (there is a single backward function, and the forward function returns ())
    Source: 'src/hashmap.rs', lines 171:4-180:5 *)
let rec hashmap_HashMap_move_elements_loop
  (t : Type0) (ntable : hashmap_HashMap_t t)
  (slots : alloc_vec_Vec (hashmap_List_t t)) (i : usize) :
  Tot (result ((hashmap_HashMap_t t) & (alloc_vec_Vec (hashmap_List_t t))))
  (decreases (hashmap_HashMap_move_elements_loop_decreases t ntable slots i))
  =
  let i1 = alloc_vec_Vec_len (hashmap_List_t t) slots in
  if i < i1
  then
    let* l =
      alloc_vec_Vec_index_mut (hashmap_List_t t) usize
        (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t)) slots i
      in
    let ls = core_mem_replace (hashmap_List_t t) l Hashmap_List_Nil in
    let* ntable1 = hashmap_HashMap_move_elements_from_list t ntable ls in
    let* i2 = usize_add i 1 in
    let l1 = core_mem_replace_back (hashmap_List_t t) l Hashmap_List_Nil in
    let* slots1 =
      alloc_vec_Vec_index_mut_back (hashmap_List_t t) usize
        (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t)) slots i
        l1 in
    hashmap_HashMap_move_elements_loop t ntable1 slots1 i2
  else Return (ntable, slots)

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::move_elements]: merged forward/backward function
    (there is a single backward function, and the forward function returns ())
    Source: 'src/hashmap.rs', lines 171:4-171:95 *)
let hashmap_HashMap_move_elements
  (t : Type0) (ntable : hashmap_HashMap_t t)
  (slots : alloc_vec_Vec (hashmap_List_t t)) (i : usize) :
  result ((hashmap_HashMap_t t) & (alloc_vec_Vec (hashmap_List_t t)))
  =
  hashmap_HashMap_move_elements_loop t ntable slots i

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::try_resize]: merged forward/backward function
    (there is a single backward function, and the forward function returns ())
    Source: 'src/hashmap.rs', lines 140:4-140:28 *)
let hashmap_HashMap_try_resize
  (t : Type0) (self : hashmap_HashMap_t t) : result (hashmap_HashMap_t t) =
  let* max_usize = scalar_cast U32 Usize core_u32_max in
  let capacity = alloc_vec_Vec_len (hashmap_List_t t) self.slots in
  let* n1 = usize_div max_usize 2 in
  let (i, i1) = self.max_load_factor in
  let* i2 = usize_div n1 i in
  if capacity <= i2
  then
    let* i3 = usize_mul capacity 2 in
    let* ntable = hashmap_HashMap_new_with_capacity t i3 i i1 in
    let* (ntable1, _) = hashmap_HashMap_move_elements t ntable self.slots 0 in
    Return
      { ntable1 with num_entries = self.num_entries; max_load_factor = (i, i1)
      }
  else Return { self with max_load_factor = (i, i1) }

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::insert]: merged forward/backward function
    (there is a single backward function, and the forward function returns ())
    Source: 'src/hashmap.rs', lines 129:4-129:48 *)
let hashmap_HashMap_insert
  (t : Type0) (self : hashmap_HashMap_t t) (key : usize) (value : t) :
  result (hashmap_HashMap_t t)
  =
  let* self1 = hashmap_HashMap_insert_no_resize t self key value in
  let* i = hashmap_HashMap_len t self1 in
  if i > self1.max_load
  then hashmap_HashMap_try_resize t self1
  else Return self1

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::contains_key_in_list]: loop 0: forward function
    Source: 'src/hashmap.rs', lines 206:4-219:5 *)
let rec hashmap_HashMap_contains_key_in_list_loop
  (t : Type0) (key : usize) (ls : hashmap_List_t t) :
  Tot (result bool)
  (decreases (hashmap_HashMap_contains_key_in_list_loop_decreases t key ls))
  =
  begin match ls with
  | Hashmap_List_Cons ckey _ tl ->
    if ckey = key
    then Return true
    else hashmap_HashMap_contains_key_in_list_loop t key tl
  | Hashmap_List_Nil -> Return false
  end

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::contains_key_in_list]: forward function
    Source: 'src/hashmap.rs', lines 206:4-206:68 *)
let hashmap_HashMap_contains_key_in_list
  (t : Type0) (key : usize) (ls : hashmap_List_t t) : result bool =
  hashmap_HashMap_contains_key_in_list_loop t key ls

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::contains_key]: forward function
    Source: 'src/hashmap.rs', lines 199:4-199:49 *)
let hashmap_HashMap_contains_key
  (t : Type0) (self : hashmap_HashMap_t t) (key : usize) : result bool =
  let* hash = hashmap_hash_key key in
  let i = alloc_vec_Vec_len (hashmap_List_t t) self.slots in
  let* hash_mod = usize_rem hash i in
  let* l =
    alloc_vec_Vec_index (hashmap_List_t t) usize
      (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t))
      self.slots hash_mod in
  hashmap_HashMap_contains_key_in_list t key l

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::get_in_list]: loop 0: forward function
    Source: 'src/hashmap.rs', lines 224:4-237:5 *)
let rec hashmap_HashMap_get_in_list_loop
  (t : Type0) (key : usize) (ls : hashmap_List_t t) :
  Tot (result t)
  (decreases (hashmap_HashMap_get_in_list_loop_decreases t key ls))
  =
  begin match ls with
  | Hashmap_List_Cons ckey cvalue tl ->
    if ckey = key
    then Return cvalue
    else hashmap_HashMap_get_in_list_loop t key tl
  | Hashmap_List_Nil -> Fail Failure
  end

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::get_in_list]: forward function
    Source: 'src/hashmap.rs', lines 224:4-224:70 *)
let hashmap_HashMap_get_in_list
  (t : Type0) (key : usize) (ls : hashmap_List_t t) : result t =
  hashmap_HashMap_get_in_list_loop t key ls

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::get]: forward function
    Source: 'src/hashmap.rs', lines 239:4-239:55 *)
let hashmap_HashMap_get
  (t : Type0) (self : hashmap_HashMap_t t) (key : usize) : result t =
  let* hash = hashmap_hash_key key in
  let i = alloc_vec_Vec_len (hashmap_List_t t) self.slots in
  let* hash_mod = usize_rem hash i in
  let* l =
    alloc_vec_Vec_index (hashmap_List_t t) usize
      (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t))
      self.slots hash_mod in
  hashmap_HashMap_get_in_list t key l

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::get_mut_in_list]: loop 0: forward function
    Source: 'src/hashmap.rs', lines 245:4-254:5 *)
let rec hashmap_HashMap_get_mut_in_list_loop
  (t : Type0) (ls : hashmap_List_t t) (key : usize) :
  Tot (result t)
  (decreases (hashmap_HashMap_get_mut_in_list_loop_decreases t ls key))
  =
  begin match ls with
  | Hashmap_List_Cons ckey cvalue tl ->
    if ckey = key
    then Return cvalue
    else hashmap_HashMap_get_mut_in_list_loop t tl key
  | Hashmap_List_Nil -> Fail Failure
  end

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::get_mut_in_list]: forward function
    Source: 'src/hashmap.rs', lines 245:4-245:86 *)
let hashmap_HashMap_get_mut_in_list
  (t : Type0) (ls : hashmap_List_t t) (key : usize) : result t =
  hashmap_HashMap_get_mut_in_list_loop t ls key

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::get_mut_in_list]: loop 0: backward function 0
    Source: 'src/hashmap.rs', lines 245:4-254:5 *)
let rec hashmap_HashMap_get_mut_in_list_loop_back
  (t : Type0) (ls : hashmap_List_t t) (key : usize) (ret : t) :
  Tot (result (hashmap_List_t t))
  (decreases (hashmap_HashMap_get_mut_in_list_loop_decreases t ls key))
  =
  begin match ls with
  | Hashmap_List_Cons ckey cvalue tl ->
    if ckey = key
    then Return (Hashmap_List_Cons ckey ret tl)
    else
      let* tl1 = hashmap_HashMap_get_mut_in_list_loop_back t tl key ret in
      Return (Hashmap_List_Cons ckey cvalue tl1)
  | Hashmap_List_Nil -> Fail Failure
  end

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::get_mut_in_list]: backward function 0
    Source: 'src/hashmap.rs', lines 245:4-245:86 *)
let hashmap_HashMap_get_mut_in_list_back
  (t : Type0) (ls : hashmap_List_t t) (key : usize) (ret : t) :
  result (hashmap_List_t t)
  =
  hashmap_HashMap_get_mut_in_list_loop_back t ls key ret

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::get_mut]: forward function
    Source: 'src/hashmap.rs', lines 257:4-257:67 *)
let hashmap_HashMap_get_mut
  (t : Type0) (self : hashmap_HashMap_t t) (key : usize) : result t =
  let* hash = hashmap_hash_key key in
  let i = alloc_vec_Vec_len (hashmap_List_t t) self.slots in
  let* hash_mod = usize_rem hash i in
  let* l =
    alloc_vec_Vec_index_mut (hashmap_List_t t) usize
      (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t))
      self.slots hash_mod in
  hashmap_HashMap_get_mut_in_list t l key

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::get_mut]: backward function 0
    Source: 'src/hashmap.rs', lines 257:4-257:67 *)
let hashmap_HashMap_get_mut_back
  (t : Type0) (self : hashmap_HashMap_t t) (key : usize) (ret : t) :
  result (hashmap_HashMap_t t)
  =
  let* hash = hashmap_hash_key key in
  let i = alloc_vec_Vec_len (hashmap_List_t t) self.slots in
  let* hash_mod = usize_rem hash i in
  let* l =
    alloc_vec_Vec_index_mut (hashmap_List_t t) usize
      (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t))
      self.slots hash_mod in
  let* l1 = hashmap_HashMap_get_mut_in_list_back t l key ret in
  let* v =
    alloc_vec_Vec_index_mut_back (hashmap_List_t t) usize
      (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t))
      self.slots hash_mod l1 in
  Return { self with slots = v }

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::remove_from_list]: loop 0: forward function
    Source: 'src/hashmap.rs', lines 265:4-291:5 *)
let rec hashmap_HashMap_remove_from_list_loop
  (t : Type0) (key : usize) (ls : hashmap_List_t t) :
  Tot (result (option t))
  (decreases (hashmap_HashMap_remove_from_list_loop_decreases t key ls))
  =
  begin match ls with
  | Hashmap_List_Cons ckey x tl ->
    if ckey = key
    then
      let mv_ls =
        core_mem_replace (hashmap_List_t t) (Hashmap_List_Cons ckey x tl)
          Hashmap_List_Nil in
      begin match mv_ls with
      | Hashmap_List_Cons _ cvalue _ -> Return (Some cvalue)
      | Hashmap_List_Nil -> Fail Failure
      end
    else hashmap_HashMap_remove_from_list_loop t key tl
  | Hashmap_List_Nil -> Return None
  end

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::remove_from_list]: forward function
    Source: 'src/hashmap.rs', lines 265:4-265:69 *)
let hashmap_HashMap_remove_from_list
  (t : Type0) (key : usize) (ls : hashmap_List_t t) : result (option t) =
  hashmap_HashMap_remove_from_list_loop t key ls

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::remove_from_list]: loop 0: backward function 1
    Source: 'src/hashmap.rs', lines 265:4-291:5 *)
let rec hashmap_HashMap_remove_from_list_loop_back
  (t : Type0) (key : usize) (ls : hashmap_List_t t) :
  Tot (result (hashmap_List_t t))
  (decreases (hashmap_HashMap_remove_from_list_loop_decreases t key ls))
  =
  begin match ls with
  | Hashmap_List_Cons ckey x tl ->
    if ckey = key
    then
      let mv_ls =
        core_mem_replace (hashmap_List_t t) (Hashmap_List_Cons ckey x tl)
          Hashmap_List_Nil in
      begin match mv_ls with
      | Hashmap_List_Cons _ _ tl1 -> Return tl1
      | Hashmap_List_Nil -> Fail Failure
      end
    else
      let* tl1 = hashmap_HashMap_remove_from_list_loop_back t key tl in
      Return (Hashmap_List_Cons ckey x tl1)
  | Hashmap_List_Nil -> Return Hashmap_List_Nil
  end

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::remove_from_list]: backward function 1
    Source: 'src/hashmap.rs', lines 265:4-265:69 *)
let hashmap_HashMap_remove_from_list_back
  (t : Type0) (key : usize) (ls : hashmap_List_t t) :
  result (hashmap_List_t t)
  =
  hashmap_HashMap_remove_from_list_loop_back t key ls

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::remove]: forward function
    Source: 'src/hashmap.rs', lines 294:4-294:52 *)
let hashmap_HashMap_remove
  (t : Type0) (self : hashmap_HashMap_t t) (key : usize) : result (option t) =
  let* hash = hashmap_hash_key key in
  let i = alloc_vec_Vec_len (hashmap_List_t t) self.slots in
  let* hash_mod = usize_rem hash i in
  let* l =
    alloc_vec_Vec_index_mut (hashmap_List_t t) usize
      (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t))
      self.slots hash_mod in
  let* x = hashmap_HashMap_remove_from_list t key l in
  begin match x with
  | None -> Return None
  | Some x1 -> let* _ = usize_sub self.num_entries 1 in Return (Some x1)
  end

(** [hashmap_main::hashmap::{hashmap_main::hashmap::HashMap<T>}::remove]: backward function 0
    Source: 'src/hashmap.rs', lines 294:4-294:52 *)
let hashmap_HashMap_remove_back
  (t : Type0) (self : hashmap_HashMap_t t) (key : usize) :
  result (hashmap_HashMap_t t)
  =
  let* hash = hashmap_hash_key key in
  let i = alloc_vec_Vec_len (hashmap_List_t t) self.slots in
  let* hash_mod = usize_rem hash i in
  let* l =
    alloc_vec_Vec_index_mut (hashmap_List_t t) usize
      (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t))
      self.slots hash_mod in
  let* x = hashmap_HashMap_remove_from_list t key l in
  begin match x with
  | None ->
    let* l1 = hashmap_HashMap_remove_from_list_back t key l in
    let* v =
      alloc_vec_Vec_index_mut_back (hashmap_List_t t) usize
        (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t))
        self.slots hash_mod l1 in
    Return { self with slots = v }
  | Some _ ->
    let* i1 = usize_sub self.num_entries 1 in
    let* l1 = hashmap_HashMap_remove_from_list_back t key l in
    let* v =
      alloc_vec_Vec_index_mut_back (hashmap_List_t t) usize
        (core_slice_index_SliceIndexUsizeSliceTInst (hashmap_List_t t))
        self.slots hash_mod l1 in
    Return { self with num_entries = i1; slots = v }
  end

(** [hashmap_main::hashmap::test1]: forward function
    Source: 'src/hashmap.rs', lines 315:0-315:10 *)
let hashmap_test1 : result unit =
  let* hm = hashmap_HashMap_new u64 in
  let* hm1 = hashmap_HashMap_insert u64 hm 0 42 in
  let* hm2 = hashmap_HashMap_insert u64 hm1 128 18 in
  let* hm3 = hashmap_HashMap_insert u64 hm2 1024 138 in
  let* hm4 = hashmap_HashMap_insert u64 hm3 1056 256 in
  let* i = hashmap_HashMap_get u64 hm4 128 in
  if not (i = 18)
  then Fail Failure
  else
    let* hm5 = hashmap_HashMap_get_mut_back u64 hm4 1024 56 in
    let* i1 = hashmap_HashMap_get u64 hm5 1024 in
    if not (i1 = 56)
    then Fail Failure
    else
      let* x = hashmap_HashMap_remove u64 hm5 1024 in
      begin match x with
      | None -> Fail Failure
      | Some x1 ->
        if not (x1 = 56)
        then Fail Failure
        else
          let* hm6 = hashmap_HashMap_remove_back u64 hm5 1024 in
          let* i2 = hashmap_HashMap_get u64 hm6 0 in
          if not (i2 = 42)
          then Fail Failure
          else
            let* i3 = hashmap_HashMap_get u64 hm6 128 in
            if not (i3 = 18)
            then Fail Failure
            else
              let* i4 = hashmap_HashMap_get u64 hm6 1056 in
              if not (i4 = 256) then Fail Failure else Return ()
      end

(** [hashmap_main::insert_on_disk]: forward function
    Source: 'src/hashmap_main.rs', lines 7:0-7:43 *)
let insert_on_disk
  (key : usize) (value : u64) (st : state) : result (state & unit) =
  let* (st1, hm) = hashmap_utils_deserialize st in
  let* hm1 = hashmap_HashMap_insert u64 hm key value in
  let* (st2, _) = hashmap_utils_serialize hm1 st1 in
  Return (st2, ())

(** [hashmap_main::main]: forward function
    Source: 'src/hashmap_main.rs', lines 16:0-16:13 *)
let main : result unit =
  Return ()

