-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [long_subtraction]: function definitions
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

set_option maxHeartbeats 2000000

/- [long_subtraction::sub_borrow]:
   Source: 'src/main.rs', lines 5:0-13:1 -/
def sub_borrow
  (b0 : U8) (src1 : U64) (src2 : U64) (dst : U64) : Result (U8 × U64) := do
  let i ← (↑(UScalar.cast .U64 b0) : Result U64)
  let tmp1 ← (↑(core.num.U64.wrapping_sub src1 i) : Result U64)
  let b1 ← if tmp1 > src1
             then ok 1#u8
             else ok 0#u8
  let tmp2 ← (↑(core.num.U64.wrapping_sub tmp1 src2) : Result U64)
  let b2 ← if tmp2 > tmp1
             then ok 1#u8
             else ok 0#u8
  let i1 ← b1 + b2
  ok (i1, tmp2)

/- [long_subtraction::sub]:
   Source: 'src/main.rs', lines 15:0-21:1 -/
def sub
  (b0 : U8) (src1 : Array U64 4#usize) (src2 : Array U64 4#usize)
  (dst : Array U64 4#usize) :
  Result (U8 × (Array U64 4#usize))
  := do
  let i ← Array.index_usize src1 0#usize
  let i1 ← Array.index_usize src2 0#usize
  let (i2, index_mut_back) ← Array.index_mut_usize dst 0#usize
  let (b1, i3) ← sub_borrow b0 i i1 i2
  let i4 ← Array.index_usize src1 1#usize
  let i5 ← Array.index_usize src2 1#usize
  let dst1 := index_mut_back i3
  let (i6, index_mut_back1) ← Array.index_mut_usize dst1 1#usize
  let (b2, i7) ← sub_borrow b1 i4 i5 i6
  let i8 ← Array.index_usize src1 2#usize
  let i9 ← Array.index_usize src2 2#usize
  let dst2 := index_mut_back1 i7
  let (i10, index_mut_back2) ← Array.index_mut_usize dst2 2#usize
  let (b3, i11) ← sub_borrow b2 i8 i9 i10
  let i12 ← Array.index_usize src1 3#usize
  let i13 ← Array.index_usize src2 3#usize
  let dst3 := index_mut_back2 i11
  let (i14, index_mut_back3) ← Array.index_mut_usize dst3 3#usize
  let (b4, i15) ← sub_borrow b3 i12 i13 i14
  let dst4 := index_mut_back3 i15
  ok (b4, dst4)

def BigInt := Array U64 4#usize

@[simp, coe]
def toNat (x: BigInt) :=
  let x0: Nat := x.val[0]
  let x1: Nat := x.val[1]
  let x2: Nat := x.val[2]
  let x3: Nat := x.val[3]
  x0 + x1 * 2^64 + x2 * 2^(64*2) + x3 * 2^(64*3)

@[progress]
theorem sub_borrow_spec (b0: U8) (src1 src2 dst: U64) (h: b0.val = 0 ∨ b0.val = 1):
  ∃ b1 r, sub_borrow b0 src1 src2 dst = ok (b1, r) ∧
  r.val - b1 * (2 ^ 64) = src1.val - src2.val - b0.val
:= by
  unfold sub_borrow
  progress*
  <;> simp_all
  <;> simp_scalar

-- TODO: make this work and move it (the issue is that `existsAndEq` is a simproc: I need
-- to add a `progress_simps_proc` attribute)
-- attribute [progress_simps] existsAndEq true_and

/- If you need to refer to the variable names and precise hypotheses, the best is simply to
   use `progress*?` to generate a proof script.

  Otherwise you can use `rename` and `rename_i`, but for big goals it might not be convenient.
-/
theorem sub_spec1
  (b0 : U8) (src1 : Array U64 4#usize) (src2 : Array U64 4#usize)
  (dst : Array U64 4#usize) (h: b0.val = 0 ∨ b0.val = 1):
  ∃ b1 r, sub b0 src1 src2 dst = ok (b1, r) ∧
  toNat r - 2 ^ (64 * 4) * b1.val = toNat src1 - toNat src2 - b0.val
:= by
  unfold sub
  /- One can use progress*? to generate a proof script.
  In the ideal world it should give you everything you need. In practice I need
  to improve some of the generated names (there is an issue linked to the way
  patterns involving tuples, like `let (x, y) ← ...`, get desugared), linking to
  names such as `__discr`. It probably just requires a bit of engineering, but I never
  found the time to do it.

  As a side note, I intend to mention the desugaring issue during the hackaton.
  -/
  simp only [progress_simps]
  let* ⟨ i, i_post ⟩ ← Array.index_usize_spec
  let* ⟨ i1, i1_post ⟩ ← Array.index_usize_spec
  let* ⟨ i2, i2_post ⟩ ← Array.index_mut_usize_spec
  let* ⟨ b1, i3, b1_post ⟩ ← sub_borrow_spec
  let* ⟨ i4, i4_post ⟩ ← Array.index_usize_spec
  let* ⟨ i5, i5_post ⟩ ← Array.index_usize_spec
  let* ⟨ i6, i6_post ⟩ ← Array.index_mut_usize_spec
  let* ⟨ b2, i7, b2_post ⟩ ← sub_borrow_spec
  · sorry
  let* ⟨ i8, i8_post ⟩ ← Array.index_usize_spec
  let* ⟨ i9, i9_post ⟩ ← Array.index_usize_spec
  let* ⟨ i10, i10_post ⟩ ← Array.index_mut_usize_spec
  let* ⟨ b3, i11, b3_post ⟩ ← sub_borrow_spec
  · sorry
  let* ⟨ i12, i12_post ⟩ ← Array.index_usize_spec
  let* ⟨ i13, i13_post ⟩ ← Array.index_usize_spec
  let* ⟨ i14, i14_post ⟩ ← Array.index_mut_usize_spec
  let* ⟨ b4, i15, i15_post ⟩ ← sub_borrow_spec
  · sorry
  -- It is possible to control the simps being applied
  -- A way to do it is to do `simp?` and then cleanup the lemmas which appear.
  -- Another possibility is to group all the lemmas we want into a simp set, typically
  -- progress_simps. I can't do that right now due to technical reasons, but I'll make a PR.
  simp only [existsAndEq, true_and]
  -- Side remark: the big terms appear because of `Nat.reducePow`, which reduce `2 ^ 64`
  simp [-Nat.reducePow]
  -- TODO: progress simplified the post of `sub_borrow_spec` which is not a desired behavior:
  -- I will update this. In the meantime:
  have : 18446744073709551616 = 2^64 := by simp
  simp only [this] at *
  clear this
  --
  simp_all [-Nat.reducePow]
  sorry

/- As a side note, when manipulating ℕ (rather than ℤ) it is better not to write
subtractions, because it is a partial operation. In particular, it makes it easier to
do simplifications (because `+` is associative and commutative). I'm doing those proofs below.

Remark: looking at it, the post of the theorem above might actually be wrong because of this (a fix would be
to go to ℤ rather than ℕ - i.e., define a `toInt` function rather than a `toNat` function).

Remark: `grind` will likely allow us to lift the constraints about the way we write specifications
- I need to merge Aymeric's PR. -/

-- Deactivating the theorem above
attribute [-progress] sub_borrow_spec

-- Proving a new theorem for `sub_borrow`
@[progress]
theorem sub_borrow_spec' (b0: U8) (src1 src2 dst: U64) (h: b0.val = 0 ∨ b0.val = 1):
  ∃ b1 r, sub_borrow b0 src1 src2 dst = ok (b1, r) ∧
  -- Note: only additions
  r.val + src2.val + b0.val = src1.val + b1 * (2 ^ 64)
:= by
  unfold sub_borrow
  progress*
  <;> simp_all
  <;> simp_scalar

/- TODO: the time necessary to solve the preconditions with grind seems to be exponential
   (it explodes for the last function calls) -/
-- set_option trace.profiler true in
theorem sub_spec2
  (b0 : U8) (src1 : Array U64 4#usize) (src2 : Array U64 4#usize)
  (dst : Array U64 4#usize) (h: b0.val = 0 ∨ b0.val = 1):
  ∃ b1 r, sub b0 src1 src2 dst = ok (b1, r) ∧
  -- Note that I modified the post-condition here to remove subtractions,
  -- but in practice for this one we don't need to do it (see below) though
  -- it may make the theorem hard to use to verify functions which call `sub`)
  toNat src1 + 2 ^ (64 * 4) * b1.val = toNat src2 + b0.val + toNat r
:= by
  unfold sub
  simp only
  progress*
  -- TODO: I guess `grind` would solve the goal here once I merge Aymeric's PR
  grind
  grind
  extract_goal1
  grind -- this one takes quite a while
  sorry

-- I isolated the problematic proof obligation below:
example
  (b0 : U8)
  (src1 : Aeneas.Std.Array U64 4#usize)
  (src2 : Aeneas.Std.Array U64 4#usize)
  (dst : Aeneas.Std.Array U64 4#usize)
  (h : (↑b0 : ℕ) = 0 ∨ (↑b0 : ℕ) = 1)
  (i : U64)
  (__14 : [> let i ← src1.index_usize 0#usize <])
  (i_post : i = (↑src1 : List U64)[0]!)
  (i1 : U64)
  (__13 : [> let i1 ← src2.index_usize 0#usize <])
  (i1_post : i1 = (↑src2 : List U64)[0]!)
  (__discr_5 : U64)
  (__12 : [> let(__discr_5, dst.set 0#usize) ← dst.index_mut_usize 0#usize <])
  (__discr_post_6 : __discr_5 = (↑dst : List U64)[0]!)
  (__discr_1_2 : U8)
  (__discr_2_2 : U64)
  (__11 : [> let(__discr_1_2, __discr_2_2) ← sub_borrow b0 i i1 __discr_5 <])
  (__discr_post_5 : (↑__discr_2_2 : ℕ) + (↑i1 : ℕ) + (↑b0 : ℕ) = (↑i : ℕ) + (↑__discr_1_2 : ℕ) * 18446744073709551616)
  (i4 : U64)
  (__10 : [> let i4 ← src1.index_usize 1#usize <])
  (i4_post : i4 = (↑src1 : List U64)[1]!)
  (i5 : U64)
  (__9 : [> let i5 ← src2.index_usize 1#usize <])
  (i5_post : i5 = (↑src2 : List U64)[1]!)
  (__discr_4 : U64)
  (__8 : [> let(__discr_4, (dst.set 0#usize __discr_2_2).set 1#usize) ←
  (dst.set 0#usize __discr_2_2).index_mut_usize 1#usize <])
  (__discr_post_4 : __discr_4 = (↑(dst.set 0#usize __discr_2_2) : List U64)[1]!)
  (__discr_1_1 : U8)
  (__discr_2_1 : U64)
  (__7 : [> let(__discr_1_1, __discr_2_1) ← sub_borrow __discr_1_2 i4 i5 __discr_4 <])
  (__discr_post_3 : (↑__discr_2_1 : ℕ) + (↑i5 : ℕ) + (↑__discr_1_2 : ℕ) =
  (↑i4 : ℕ) + (↑__discr_1_1 : ℕ) * 18446744073709551616)
  (i8 : U64)
  (__6 : [> let i8 ← src1.index_usize 2#usize <])
  (i8_post : i8 = (↑src1 : List U64)[2]!)
  (i9 : U64)
  (__5 : [> let i9 ← src2.index_usize 2#usize <])
  (i9_post : i9 = (↑src2 : List U64)[2]!)
  (__discr_3 : U64)
  (__4 : [> let(__discr_3, ((dst.set 0#usize __discr_2_2).set 1#usize __discr_2_1).set 2#usize) ←
  ((dst.set 0#usize __discr_2_2).set 1#usize __discr_2_1).index_mut_usize 2#usize <])
  (__discr_post_2 : __discr_3 = (↑((dst.set 0#usize __discr_2_2).set 1#usize __discr_2_1) : List U64)[2]!)
  (__discr_1 : U8)
  (__discr_2 : U64)
  (__3 : [> let(__discr_1, __discr_2) ← sub_borrow __discr_1_1 i8 i9 __discr_3 <])
  (__discr_post_1 : (↑__discr_2 : ℕ) + (↑i9 : ℕ) + (↑__discr_1_1 : ℕ) =
  (↑i8 : ℕ) + (↑__discr_1 : ℕ) * 18446744073709551616)
  (i12 : U64)
  (__2 : [> let i12 ← src1.index_usize 3#usize <])
  (i12_post : i12 = (↑src1 : List U64)[3]!)
  (i13 : U64)
  (__1 : [> let i13 ← src2.index_usize 3#usize <])
  (i13_post : i13 = (↑src2 : List U64)[3]!)
  (__discr : U64)
  (_ : [> let(__discr, (((dst.set 0#usize __discr_2_2).set 1#usize __discr_2_1).set 2#usize __discr_2).set 3#usize) ←
  (((dst.set 0#usize __discr_2_2).set 1#usize __discr_2_1).set 2#usize __discr_2).index_mut_usize 3#usize <])
  (__discr_post : __discr =
  (↑(((dst.set 0#usize __discr_2_2).set 1#usize __discr_2_1).set 2#usize __discr_2) : List U64)[3]!) :
  (↑__discr_1 : ℕ) = 0 ∨ (↑__discr_1 : ℕ) = 1
  := by grind

-- It also works with the original post
theorem sub_spec3
  (b0 : U8) (src1 : Array U64 4#usize) (src2 : Array U64 4#usize)
  (dst : Array U64 4#usize) (h: b0.val = 0 ∨ b0.val = 1):
  ∃ b1 r, sub b0 src1 src2 dst = ok (b1, r) ∧
  toNat r - 2 ^ (64 * 4) * b1.val = toNat src1 - toNat src2 - b0.val
:= by
  unfold sub
  progress*
  simp_all
  scalar_tac
