-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [loops_rec]
import Aeneas
open Aeneas Aeneas.Std Result ControlFlow Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

/- You can set the `maxHeartbeats` value with the `-max-heartbeats` CLI option -/
set_option maxHeartbeats 1000000

namespace loops_rec

/- [loops_rec::iter]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 8:4-10:5 -/
def iter_loop (max : Std.U32) (i : Std.U32) : Result Std.U32 := do
  if i < max
  then let i1 ← i + 1#u32
       iter_loop max i1
  else ok i
partial_fixpoint

/- [loops_rec::iter]:
   Source: 'tests/src/loops-rec.rs', lines 6:0-13:1 -/
@[reducible]
def iter (max : Std.U32) : Result Std.U32 := do
  iter_loop max 0#u32

/- [loops_rec::sum]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 19:4-22:5 -/
def sum_loop (max : Std.U32) (i : Std.U32) (s : Std.U32) : Result Std.U32 := do
  if i < max
  then let s1 ← s + i
       let i1 ← i + 1#u32
       sum_loop max i1 s1
  else ok s
partial_fixpoint

/- [loops_rec::sum]:
   Source: 'tests/src/loops-rec.rs', lines 16:0-26:1 -/
def sum (max : Std.U32) : Result Std.U32 := do
  let s ← sum_loop max 0#u32 0#u32
  s * 2#u32

/- [loops_rec::sum_with_mut_borrows]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 34:4-39:5 -/
def sum_with_mut_borrows_loop
  (max : Std.U32) (i : Std.U32) (s : Std.U32) : Result Std.U32 := do
  if i < max
  then
    let ms ← s + i
    let mi ← i + 1#u32
    sum_with_mut_borrows_loop max mi ms
  else ok s
partial_fixpoint

/- [loops_rec::sum_with_mut_borrows]:
   Source: 'tests/src/loops-rec.rs', lines 31:0-43:1 -/
def sum_with_mut_borrows (max : Std.U32) : Result Std.U32 := do
  let s ← sum_with_mut_borrows_loop max 0#u32 0#u32
  s * 2#u32

/- [loops_rec::sum_with_shared_borrows]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 49:4-56:5 -/
def sum_with_shared_borrows_loop
  (max : Std.U32) (i : Std.U32) (s : Std.U32) : Result Std.U32 := do
  if i < max
  then
    let i1 ← i + 1#u32
    let s1 ← s + i1
    sum_with_shared_borrows_loop max i1 s1
  else ok s
partial_fixpoint

/- [loops_rec::sum_with_shared_borrows]:
   Source: 'tests/src/loops-rec.rs', lines 46:0-60:1 -/
def sum_with_shared_borrows (max : Std.U32) : Result Std.U32 := do
  let s ← sum_with_shared_borrows_loop max 0#u32 0#u32
  s * 2#u32

/- [loops_rec::sum_array]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 65:4-68:5 -/
def sum_array_loop
  {N : Std.Usize} (a : Array Std.U32 N) (i : Std.Usize) (s : Std.U32) :
  Result Std.U32
  := do
  if i < N
  then
    let i1 ← Array.index_usize a i
    let s1 ← s + i1
    let i2 ← i + 1#usize
    sum_array_loop a i2 s1
  else ok s
partial_fixpoint

/- [loops_rec::sum_array]:
   Source: 'tests/src/loops-rec.rs', lines 62:0-70:1 -/
@[reducible]
def sum_array {N : Std.Usize} (a : Array Std.U32 N) : Result Std.U32 := do
  sum_array_loop a 0#usize 0#u32

/- [loops_rec::clear]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 76:4-79:5 -/
def clear_loop
  (v : alloc.vec.Vec Std.U32) (i : Std.Usize) :
  Result (alloc.vec.Vec Std.U32)
  := do
  let i1 := alloc.vec.Vec.len v
  if i < i1
  then
    let (_, index_mut_back) ←
      alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSlice Std.U32) v
        i
    let i2 ← i + 1#usize
    let v1 := index_mut_back 0#u32
    clear_loop v1 i2
  else ok v
partial_fixpoint

/- [loops_rec::clear]:
   Source: 'tests/src/loops-rec.rs', lines 74:0-80:1 -/
@[reducible]
def clear (v : alloc.vec.Vec Std.U32) : Result (alloc.vec.Vec Std.U32) := do
  clear_loop v 0#usize

/- [loops_rec::List]
   Source: 'tests/src/loops-rec.rs', lines 82:0-85:1 -/
@[discriminant isize]
inductive List (T : Type) where
| Cons : T → List T → List T
| Nil : List T

/- [loops_rec::list_mem]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 89:4-97:1 -/
def list_mem_loop (x : Std.U32) (ls : List Std.U32) : Result Bool := do
  match ls with
  | List.Cons y tl => if y = x
                      then ok true
                      else list_mem_loop x tl
  | List.Nil => ok false
partial_fixpoint

/- [loops_rec::list_mem]:
   Source: 'tests/src/loops-rec.rs', lines 88:0-97:1 -/
@[reducible]
def list_mem (x : Std.U32) (ls : List Std.U32) : Result Bool := do
  list_mem_loop x ls

/- [loops_rec::list_nth_mut]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 100:4-109:1 -/
def list_nth_mut_loop
  {T : Type} (ls : List T) (i : Std.U32) : Result (T × (T → List T)) := do
  match ls with
  | List.Cons x tl =>
    if i = 0#u32
    then ok (x, fun t => List.Cons t tl)
    else
      let i1 ← i - 1#u32
      let (t, back) ← list_nth_mut_loop tl i1
      let back1 := fun t1 => let l := back t1
                             List.Cons x l
      ok (t, back1)
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::list_nth_mut]:
   Source: 'tests/src/loops-rec.rs', lines 99:0-109:1 -/
@[reducible]
def list_nth_mut
  {T : Type} (ls : List T) (i : Std.U32) : Result (T × (T → List T)) := do
  list_nth_mut_loop ls i

/- [loops_rec::list_nth_shared]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 113:4-122:1 -/
def list_nth_shared_loop
  {T : Type} (ls : List T) (i : Std.U32) : Result T := do
  match ls with
  | List.Cons x tl =>
    if i = 0#u32
    then ok x
    else let i1 ← i - 1#u32
         list_nth_shared_loop tl i1
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::list_nth_shared]:
   Source: 'tests/src/loops-rec.rs', lines 112:0-122:1 -/
@[reducible]
def list_nth_shared {T : Type} (ls : List T) (i : Std.U32) : Result T := do
  list_nth_shared_loop ls i

/- [loops_rec::get_elem_mut]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 126:4-138:1 -/
def get_elem_mut_loop
  (x : Std.Usize) (ls : List Std.Usize) :
  Result (Std.Usize × (Std.Usize → List Std.Usize))
  := do
  match ls with
  | List.Cons y tl =>
    if y = x
    then ok (y, fun i => List.Cons i tl)
    else
      let (i, back) ← get_elem_mut_loop x tl
      let back1 := fun i1 => let l := back i1
                             List.Cons y l
      ok (i, back1)
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::get_elem_mut]:
   Source: 'tests/src/loops-rec.rs', lines 124:0-138:1 -/
def get_elem_mut
  (slots : alloc.vec.Vec (List Std.Usize)) (x : Std.Usize) :
  Result (Std.Usize × (Std.Usize → alloc.vec.Vec (List Std.Usize)))
  := do
  let (ls, index_mut_back) ←
    alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSlice (List
      Std.Usize)) slots 0#usize
  let (i, back) ← get_elem_mut_loop x ls
  let back1 := fun i1 => let l := back i1
                         index_mut_back l
  ok (i, back1)

/- [loops_rec::get_elem_shared]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 142:4-154:1 -/
def get_elem_shared_loop
  (x : Std.Usize) (ls : List Std.Usize) : Result Std.Usize := do
  match ls with
  | List.Cons y tl => if y = x
                      then ok y
                      else get_elem_shared_loop x tl
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::get_elem_shared]:
   Source: 'tests/src/loops-rec.rs', lines 140:0-154:1 -/
def get_elem_shared
  (slots : alloc.vec.Vec (List Std.Usize)) (x : Std.Usize) :
  Result Std.Usize
  := do
  let ls ←
    alloc.vec.Vec.index (core.slice.index.SliceIndexUsizeSlice (List
      Std.Usize)) slots 0#usize
  get_elem_shared_loop x ls

/- [loops_rec::id_mut]:
   Source: 'tests/src/loops-rec.rs', lines 156:0-158:1 -/
def id_mut
  {T : Type} (ls : List T) : Result ((List T) × (List T → List T)) := do
  ok (ls, fun ls1 => ls1)

/- [loops_rec::id_shared]:
   Source: 'tests/src/loops-rec.rs', lines 160:0-162:1 -/
def id_shared {T : Type} (ls : List T) : Result (List T) := do
  ok ls

/- [loops_rec::list_nth_mut_with_id]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 167:4-176:1 -/
def list_nth_mut_with_id_loop
  {T : Type} (i : Std.U32) (ls : List T) : Result (T × (T → List T)) := do
  match ls with
  | List.Cons x tl =>
    if i = 0#u32
    then ok (x, fun t => List.Cons t tl)
    else
      let i1 ← i - 1#u32
      let (t, back) ← list_nth_mut_with_id_loop i1 tl
      let back1 := fun t1 => let l := back t1
                             List.Cons x l
      ok (t, back1)
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::list_nth_mut_with_id]:
   Source: 'tests/src/loops-rec.rs', lines 165:0-176:1 -/
def list_nth_mut_with_id
  {T : Type} (ls : List T) (i : Std.U32) : Result (T × (T → List T)) := do
  let (ls1, id_mut_back) ← id_mut ls
  let (t, back) ← list_nth_mut_with_id_loop i ls1
  let back1 := fun t1 => let l := back t1
                         id_mut_back l
  ok (t, back1)

/- [loops_rec::list_nth_shared_with_id]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 181:4-190:1 -/
def list_nth_shared_with_id_loop
  {T : Type} (i : Std.U32) (ls : List T) : Result T := do
  match ls with
  | List.Cons x tl =>
    if i = 0#u32
    then ok x
    else let i1 ← i - 1#u32
         list_nth_shared_with_id_loop i1 tl
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::list_nth_shared_with_id]:
   Source: 'tests/src/loops-rec.rs', lines 179:0-190:1 -/
def list_nth_shared_with_id
  {T : Type} (ls : List T) (i : Std.U32) : Result T := do
  let ls1 ← id_shared ls
  list_nth_shared_with_id_loop i ls1

/- [loops_rec::list_nth_mut_pair]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 200:4-216:1 -/
def list_nth_mut_pair_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result (T × T × (T → List T) × (T → List T))
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1, fun t => List.Cons t tl0, fun t => List.Cons t tl1)
      else
        let i1 ← i - 1#u32
        let (t, t1, back, back1) ← list_nth_mut_pair_loop tl0 tl1 i1
        let back2 := fun t2 => let l := back t2
                               List.Cons x0 l
        let back3 := fun t2 => let l := back1 t2
                               List.Cons x1 l
        ok (t, t1, back2, back3)
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::list_nth_mut_pair]:
   Source: 'tests/src/loops-rec.rs', lines 195:0-216:1 -/
def list_nth_mut_pair
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result ((T × T) × (T → List T) × (T → List T))
  := do
  let (t, t1, back, back1) ← list_nth_mut_pair_loop ls0 ls1 i
  ok ((t, t1), back, back1)

/- [loops_rec::list_nth_shared_pair]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 224:4-240:1 -/
def list_nth_shared_pair_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result (T × T)
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1)
      else let i1 ← i - 1#u32
           list_nth_shared_pair_loop tl0 tl1 i1
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::list_nth_shared_pair]:
   Source: 'tests/src/loops-rec.rs', lines 219:0-240:1 -/
@[reducible]
def list_nth_shared_pair
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result (T × T)
  := do
  list_nth_shared_pair_loop ls0 ls1 i

/- [loops_rec::list_nth_mut_pair_merge]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 249:4-259:1 -/
def list_nth_mut_pair_merge_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result (T × T × (T → List T) × (T → List T))
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1, fun t => List.Cons t tl0, fun t => List.Cons t tl1)
      else
        let i1 ← i - 1#u32
        let (t, t1, back, back1) ← list_nth_mut_pair_merge_loop tl0 tl1 i1
        let back2 := fun t2 => let l := back t2
                               List.Cons x0 l
        let back3 := fun t2 => let l := back1 t2
                               List.Cons x1 l
        ok (t, t1, back2, back3)
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::list_nth_mut_pair_merge]:
   Source: 'tests/src/loops-rec.rs', lines 244:0-259:1 -/
def list_nth_mut_pair_merge
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result ((T × T) × ((T × T) → ((List T) × (List T))))
  := do
  let (t, t1, back, back1) ← list_nth_mut_pair_merge_loop ls0 ls1 i
  let back2 :=
    fun p =>
      let (t2, t3) := p
      let ls01 := back t2
      let ls11 := back1 t3
      (ls01, ls11)
  ok ((t, t1), back2)

/- [loops_rec::list_nth_shared_pair_merge]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 267:4-277:1 -/
def list_nth_shared_pair_merge_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result (T × T)
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1)
      else let i1 ← i - 1#u32
           list_nth_shared_pair_merge_loop tl0 tl1 i1
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::list_nth_shared_pair_merge]:
   Source: 'tests/src/loops-rec.rs', lines 262:0-277:1 -/
@[reducible]
def list_nth_shared_pair_merge
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result (T × T)
  := do
  list_nth_shared_pair_merge_loop ls0 ls1 i

/- [loops_rec::list_nth_mut_shared_pair]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 285:4-295:1 -/
def list_nth_mut_shared_pair_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result (T × T × (T → List T))
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1, fun t => List.Cons t tl0)
      else
        let i1 ← i - 1#u32
        let (t, t1, back) ← list_nth_mut_shared_pair_loop tl0 tl1 i1
        let back1 := fun t2 => let l := back t2
                               List.Cons x0 l
        ok (t, t1, back1)
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::list_nth_mut_shared_pair]:
   Source: 'tests/src/loops-rec.rs', lines 280:0-295:1 -/
def list_nth_mut_shared_pair
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result ((T × T) × (T → List T))
  := do
  let (t, t1, back) ← list_nth_mut_shared_pair_loop ls0 ls1 i
  ok ((t, t1), back)

/- [loops_rec::list_nth_mut_shared_pair_merge]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 304:4-314:1 -/
def list_nth_mut_shared_pair_merge_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result (T × T × (T → List T))
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1, fun t => List.Cons t tl0)
      else
        let i1 ← i - 1#u32
        let (t, t1, back) ← list_nth_mut_shared_pair_merge_loop tl0 tl1 i1
        let back1 := fun t2 => let l := back t2
                               List.Cons x0 l
        ok (t, t1, back1)
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::list_nth_mut_shared_pair_merge]:
   Source: 'tests/src/loops-rec.rs', lines 299:0-314:1 -/
def list_nth_mut_shared_pair_merge
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result ((T × T) × (T → List T))
  := do
  let (t, t1, back) ← list_nth_mut_shared_pair_merge_loop ls0 ls1 i
  ok ((t, t1), back)

/- [loops_rec::list_nth_shared_mut_pair]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 323:4-333:1 -/
def list_nth_shared_mut_pair_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result (T × T × (T → List T))
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1, fun t => List.Cons t tl1)
      else
        let i1 ← i - 1#u32
        let (t, t1, back) ← list_nth_shared_mut_pair_loop tl0 tl1 i1
        let back1 := fun t2 => let l := back t2
                               List.Cons x1 l
        ok (t, t1, back1)
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::list_nth_shared_mut_pair]:
   Source: 'tests/src/loops-rec.rs', lines 318:0-333:1 -/
def list_nth_shared_mut_pair
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result ((T × T) × (T → List T))
  := do
  let (t, t1, back) ← list_nth_shared_mut_pair_loop ls0 ls1 i
  ok ((t, t1), back)

/- [loops_rec::list_nth_shared_mut_pair_merge]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 342:4-352:1 -/
def list_nth_shared_mut_pair_merge_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result (T × T × (T → List T))
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1, fun t => List.Cons t tl1)
      else
        let i1 ← i - 1#u32
        let (t, t1, back) ← list_nth_shared_mut_pair_merge_loop tl0 tl1 i1
        let back1 := fun t2 => let l := back t2
                               List.Cons x1 l
        ok (t, t1, back1)
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops_rec::list_nth_shared_mut_pair_merge]:
   Source: 'tests/src/loops-rec.rs', lines 337:0-352:1 -/
def list_nth_shared_mut_pair_merge
  {T : Type} (ls0 : List T) (ls1 : List T) (i : Std.U32) :
  Result ((T × T) × (T → List T))
  := do
  let (t, t1, back) ← list_nth_shared_mut_pair_merge_loop ls0 ls1 i
  ok ((t, t1), back)

/- [loops_rec::ignore_input_mut_borrow]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 357:4-359:5 -/
def ignore_input_mut_borrow_loop (i : Std.U32) : Result Unit := do
  if i > 0#u32
  then let i1 ← i - 1#u32
       ignore_input_mut_borrow_loop i1
  else ok ()
partial_fixpoint

/- [loops_rec::ignore_input_mut_borrow]:
   Source: 'tests/src/loops-rec.rs', lines 356:0-360:1 -/
def ignore_input_mut_borrow (_a : Std.U32) (i : Std.U32) : Result Std.U32 := do
  ignore_input_mut_borrow_loop i
  ok _a

/- [loops_rec::incr_ignore_input_mut_borrow]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 366:4-368:5 -/
def incr_ignore_input_mut_borrow_loop (i : Std.U32) : Result Unit := do
  if i > 0#u32
  then let i1 ← i - 1#u32
       incr_ignore_input_mut_borrow_loop i1
  else ok ()
partial_fixpoint

/- [loops_rec::incr_ignore_input_mut_borrow]:
   Source: 'tests/src/loops-rec.rs', lines 364:0-369:1 -/
def incr_ignore_input_mut_borrow
  (a : Std.U32) (i : Std.U32) : Result Std.U32 := do
  let a1 ← a + 1#u32
  incr_ignore_input_mut_borrow_loop i
  ok a1

/- [loops_rec::ignore_input_shared_borrow]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 374:4-376:5 -/
def ignore_input_shared_borrow_loop (i : Std.U32) : Result Unit := do
  if i > 0#u32
  then let i1 ← i - 1#u32
       ignore_input_shared_borrow_loop i1
  else ok ()
partial_fixpoint

/- [loops_rec::ignore_input_shared_borrow]:
   Source: 'tests/src/loops-rec.rs', lines 373:0-377:1 -/
def ignore_input_shared_borrow
  (_a : Std.U32) (i : Std.U32) : Result Std.U32 := do
  ignore_input_shared_borrow_loop i
  ok _a

/- [loops_rec::issue500_1::bar]:
   Source: 'tests/src/loops-rec.rs', lines 381:4-381:28 -/
def issue500_1.bar (_a : Bool) : Result Bool := do
  ok _a

/- [loops_rec::issue500_1]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 384:4-386:5 -/
def issue500_1_loop (a : Bool) : Result Bool := do
  if 0#i32 < 0#i32
  then let a1 ← issue500_1.bar a
       issue500_1_loop a1
  else ok a
partial_fixpoint

/- [loops_rec::issue500_1]:
   Source: 'tests/src/loops-rec.rs', lines 380:0-388:1 -/
@[reducible] def issue500_1 (s : Bool) : Result Bool := do
               issue500_1_loop s

/- [loops_rec::issue500_2::bar]:
   Source: 'tests/src/loops-rec.rs', lines 393:4-393:33 -/
def issue500_2.bar
  (_a : Array Bool 1#usize) : Result (Array Bool 1#usize) := do
  ok _a

/- [loops_rec::issue500_2::A]
   Source: 'tests/src/loops-rec.rs', lines 392:4-392:24 -/
@[reducible]
def issue500_2.A := Array Bool 1#usize

/- [loops_rec::issue500_2]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 396:4-398:5 -/
def issue500_2_loop : Result Unit := do
  ok ()

/- [loops_rec::issue500_2]:
   Source: 'tests/src/loops-rec.rs', lines 391:0-400:1 -/
def issue500_2 (s : Array Bool 1#usize) : Result (Array Bool 1#usize) := do
  issue500_2_loop
  ok s

/- [loops_rec::issue500_3::A]
   Source: 'tests/src/loops-rec.rs', lines 404:4-404:24 -/
@[reducible]
def issue500_3.A := Array Bool 1#usize

/- [loops_rec::issue500_3]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 406:4-406:18 -/
def issue500_3_loop : Result Unit := do
  if 0#i32 < 0#i32
  then issue500_3_loop
  else ok ()
partial_fixpoint

/- [loops_rec::issue500_3]:
   Source: 'tests/src/loops-rec.rs', lines 403:0-408:1 -/
def issue500_3 (s : Array Bool 1#usize) : Result (Array Bool 1#usize) := do
  issue500_3_loop
  ok s

/- [loops_rec::issue351]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 413:4-416:5 -/
def issue351_loop (t : List Std.U8) (last : Std.U8) : Result Std.U8 := do
  match t with
  | List.Cons ht tt => issue351_loop tt ht
  | List.Nil => ok last
partial_fixpoint

/- [loops_rec::issue351]:
   Source: 'tests/src/loops-rec.rs', lines 411:0-418:1 -/
@[reducible]
def issue351 (h : Std.U8) (t : List Std.U8) : Result Std.U8 := do
  issue351_loop t h

/- [loops_rec::issue270::box_get_borrow]:
   Source: 'tests/src/loops-rec.rs', lines 422:4-424:5 -/
def issue270.box_get_borrow {T : Type} (x : T) : Result T := do
  ok x

/- [loops_rec::issue270]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 428:8-431:9 -/
def issue270_loop
  (t : List (List Std.U8)) (last : List Std.U8) : Result (List Std.U8) := do
  match t with
  | List.Cons ht tt =>
    let t1 ← issue270.box_get_borrow tt
    issue270_loop t1 ht
  | List.Nil => ok last
partial_fixpoint

/- [loops_rec::issue270]:
   Source: 'tests/src/loops-rec.rs', lines 421:0-436:1 -/
def issue270 (v : List (List Std.U8)) : Result (Option (List Std.U8)) := do
  match v with
  | List.Cons h t =>
    let t1 ← issue270.box_get_borrow t
    let last ← issue270_loop t1 h
    ok (some last)
  | List.Nil => ok none

/- [loops_rec::issue400_1]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 442:4-449:5 -/
def issue400_1_loop
  (back : Std.I32 → (Std.I32 × Std.I32)) (cond : Bool) (y : Std.I32)
  (i : Std.I32) :
  Result (Std.I32 × Std.I32)
  := do
  if i < 32#i32
  then
    let (y1, back1) ←
      if cond
      then let (a, b) := back y
           ok (a, fun i1 => (i1, b))
      else let (a, b) := back y
           ok (b, fun i1 => (a, i1))
    let i1 ← i + 1#i32
    issue400_1_loop back1 cond y1 i1
  else ok (back y)
partial_fixpoint

/- [loops_rec::issue400_1]:
   Source: 'tests/src/loops-rec.rs', lines 439:0-450:1 -/
@[reducible]
def issue400_1
  (a : Std.I32) (b : Std.I32) (cond : Bool) : Result (Std.I32 × Std.I32) := do
  issue400_1_loop (fun i => (i, b)) cond a 0#i32

/- [loops_rec::issue400_2]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 457:4-466:5 -/
def issue400_2_loop
  (back : Std.I32 → Std.I32 → (Std.I32 × Std.I32 × Std.I32))
  (conds : Slice Bool) (y : Std.I32) (z : Std.I32) (i : Std.Usize) :
  Result (Std.I32 × Std.I32 × (Std.I32 → Std.I32 → (Std.I32 × Std.I32 ×
    Std.I32)))
  := do
  let i1 := Slice.len conds
  if i < i1
  then
    let b ← Slice.index_usize conds i
    let (y1, z1, back1) ←
      if b
      then let (a, b1, c) := back y z
           ok (a, b1, fun i2 i3 => (i2, i3, c))
      else let (a, b1, c) := back y z
           ok (b1, c, fun i2 i3 => (a, i2, i3))
    let i2 ← i + 1#usize
    issue400_2_loop back1 conds y1 z1 i2
  else ok (y, z, back)
partial_fixpoint

/- [loops_rec::issue400_2]:
   Source: 'tests/src/loops-rec.rs', lines 453:0-469:1 -/
def issue400_2
  (a : Std.I32) (b : Std.I32) (c : Std.I32) (conds : Slice Bool) :
  Result (Std.I32 × Std.I32 × Std.I32)
  := do
  let (y, z, back) ←
    issue400_2_loop (fun i i1 => (i, i1, c)) conds a b 0#usize
  let y1 ← y + 3#i32
  let z1 ← z + 5#i32
  ok (back y1 z1)

/- [loops_rec::copy_carray::CARRAY]
   Source: 'tests/src/loops-rec.rs', lines 473:4-473:36 -/
@[global_simps, irreducible]
def copy_carray.CARRAY : Array Std.U32 2#usize :=
  Array.make 2#usize [ 0#u32, 1#u32 ]

/- [loops_rec::copy_carray]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 475:4-478:5 -/
def copy_carray_loop
  (a : Array Std.U32 2#usize) (i : Std.Usize) :
  Result (Array Std.U32 2#usize)
  := do
  if i < 2#usize
  then
    let i1 ← Array.index_usize copy_carray.CARRAY i
    let a1 ← Array.update a i i1
    let i2 ← i + 1#usize
    copy_carray_loop a1 i2
  else ok a
partial_fixpoint

/- [loops_rec::copy_carray]:
   Source: 'tests/src/loops-rec.rs', lines 472:0-479:1 -/
@[reducible]
def copy_carray
  (a : Array Std.U32 2#usize) : Result (Array Std.U32 2#usize) := do
  copy_carray_loop a 0#usize

/- [loops_rec::iter_local_mut_borrow]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 485:4-492:5 -/
def iter_local_mut_borrow_loop (p : Std.I32) : Result Unit := do
  let p1 ← p + 1#i32
  if p1 = 10#i32
  then ok ()
  else iter_local_mut_borrow_loop p1
partial_fixpoint

/- [loops_rec::iter_local_mut_borrow]:
   Source: 'tests/src/loops-rec.rs', lines 482:0-493:1 -/
@[reducible]
def iter_local_mut_borrow : Result Unit := do
  iter_local_mut_borrow_loop 0#i32

/- [loops_rec::iter_local_shared_borrow]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 499:4-505:5 -/
def iter_local_shared_borrow_loop : Result Unit := do
  if 0#i32 = 0#i32
  then ok ()
  else iter_local_shared_borrow_loop
partial_fixpoint

/- [loops_rec::iter_local_shared_borrow]:
   Source: 'tests/src/loops-rec.rs', lines 496:0-506:1 -/
@[reducible]
def iter_local_shared_borrow : Result Unit := do
  iter_local_shared_borrow_loop

/- [loops_rec::AList]
   Source: 'tests/src/loops-rec.rs', lines 508:0-511:1 -/
@[discriminant isize]
inductive AList (T : Type) where
| Cons : Std.Usize → T → AList T → AList T
| Nil : AList T

/- [loops_rec::insert_in_list]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 1:0-530:5 -/
def insert_in_list_loop
  {T : Type} (key : Std.Usize) (value : T) (ls : AList T) :
  Result (Bool × (AList T))
  := do
  match ls with
  | AList.Cons ckey cvalue tl =>
    if ckey = key
    then ok (false, AList.Cons ckey value tl)
    else
      let (b, back) ← insert_in_list_loop key value tl
      let back1 := AList.Cons ckey cvalue back
      ok (b, back1)
  | AList.Nil => ok (true, AList.Cons key value AList.Nil)
partial_fixpoint

/- [loops_rec::insert_in_list]:
   Source: 'tests/src/loops-rec.rs', lines 514:0-531:1 -/
@[reducible]
def insert_in_list
  {T : Type} (key : Std.Usize) (value : T) (ls : AList T) :
  Result (Bool × (AList T))
  := do
  insert_in_list_loop key value ls

/- [loops_rec::reborrow_const::reborrow]:
   Source: 'tests/src/loops-rec.rs', lines 536:4-540:5 -/
def reborrow_const.reborrow (x : Std.U64) : Result Std.U64 := do
  ok x

/- [loops_rec::reborrow_const]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 0:0-544:5 -/
def reborrow_const_loop : Result Unit := do
  if 0#i32 < 5#i32
  then let _ ← reborrow_const.reborrow 0#u64
       reborrow_const_loop
  else ok ()
partial_fixpoint

/- [loops_rec::reborrow_const]:
   Source: 'tests/src/loops-rec.rs', lines 535:0-545:1 -/
@[reducible] def reborrow_const : Result Unit := do
               reborrow_const_loop

/- [loops_rec::decode]: loop 1:
   Source: 'tests/src/loops-rec.rs', lines 554:8-554:32 -/
def decode_loop0_loop0 (dst_coeff : Std.U8) : Result Unit := do
  if dst_coeff > 32#u8
  then decode_loop0_loop0 dst_coeff
  else ok ()
partial_fixpoint

/- [loops_rec::decode]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 552:4-565:1 -/
def decode_loop0
  (pe_dst : Slice Std.U8) (i : Std.Usize) :
  Result (Bool × (Slice Std.U8))
  := do
  if i < 128#usize
  then
    let (dst_coeff, index_mut_back) ← Slice.index_mut_usize pe_dst i
    decode_loop0_loop0 dst_coeff
    if dst_coeff > 32#u8
    then let s := index_mut_back dst_coeff
         ok (true, s)
    else let i1 ← i + 1#usize
         let s := index_mut_back 0#u8
         decode_loop0 s i1
  else ok (false, pe_dst)
partial_fixpoint

/- [loops_rec::decode]:
   Source: 'tests/src/loops-rec.rs', lines 548:0-565:1 -/
@[reducible]
def decode (pe_dst : Slice Std.U8) : Result (Bool × (Slice Std.U8)) := do
  decode_loop0 pe_dst 0#usize

/- [loops_rec::as_radix_minimized]: loop 0:
   Source: 'tests/src/loops-rec.rs', lines 571:4-578:5 -/
def as_radix_minimized_loop
  (scalar : Array Std.U64 4#usize) (i : Std.Usize) : Result Unit := do
  if i < 4#usize
  then
    let _ ←
      if i = 0#usize
      then let i1 ← Array.index_usize scalar i
           i1 >>> 1#i32
      else
        let i1 ← Array.index_usize scalar i
        let i2 ← i1 >>> 1#i32
        let i3 ← i1 <<< 63#i32
        ok (i2 ||| i3)
    let i1 ← i + 1#usize
    as_radix_minimized_loop scalar i1
  else ok ()
partial_fixpoint

/- [loops_rec::as_radix_minimized]:
   Source: 'tests/src/loops-rec.rs', lines 568:0-579:1 -/
def as_radix_minimized : Result Unit := do
  let scalar := Array.repeat 4#usize 0#u64
  as_radix_minimized_loop scalar 0#usize

end loops_rec
