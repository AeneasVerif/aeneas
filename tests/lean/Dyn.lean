-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [dyn]
import Aeneas
open Aeneas Aeneas.Std Result ControlFlow Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

/- You can set the `maxHeartbeats` value with the `-max-heartbeats` CLI option -/
set_option maxHeartbeats 1000000

namespace dyn

/- Trait declaration: [dyn::Trait]
   Source: 'tests/src/dyn.rs', lines 3:0-5:1 -/
structure Trait (Self : Type) where
  get : Self → Result Std.U32

/- [dyn::{dyn::Trait for u32}::get]:
   Source: 'tests/src/dyn.rs', lines 8:4-10:5 -/
def U32.Insts.DynTrait.get (self : Std.U32) : Result Std.U32 := do
  ok self

/- Trait implementation: [dyn::{dyn::Trait for u32}]
   Source: 'tests/src/dyn.rs', lines 7:0-11:1 -/
@[reducible]
def U32.Insts.DynTrait : Trait Std.U32 := {
  get := U32.Insts.DynTrait.get
}

/- [dyn::{dyn::Trait for bool}::get]:
   Source: 'tests/src/dyn.rs', lines 14:4-16:5 -/
def Bool.Insts.DynTrait.get (self : Bool) : Result Std.U32 := do
  ok (UScalar.cast_fromBool .U32 self)

/- Trait implementation: [dyn::{dyn::Trait for bool}]
   Source: 'tests/src/dyn.rs', lines 13:0-17:1 -/
@[reducible]
def Bool.Insts.DynTrait : Trait Bool := {
  get := Bool.Insts.DynTrait.get
}

/- [dyn::bool_to_trait]:
   Source: 'tests/src/dyn.rs', lines 19:0-21:1 -/
def bool_to_trait (b : Bool) : Result Bool := do
  ok b

/- [dyn::mk_trait]:
   Source: 'tests/src/dyn.rs', lines 23:0-29:1 -/
def mk_trait (b : Bool) : Result (Dyn (fun _dyn => Trait _dyn)) := do
  if b
  then ok (Dyn.mk _ Bool.Insts.DynTrait true)
  else ok (Dyn.mk _ U32.Insts.DynTrait 0#u32)

/- Trait declaration: [dyn::Into]
   Source: 'tests/src/dyn.rs', lines 31:0-33:1 -/
structure Into (Self : Type) (T : Type) where
  into : Self → Result T

/- [dyn::mk_into]:
   Source: 'tests/src/dyn.rs', lines 36:0-46:1 -/
def mk_into
  (U : Type) {V : Type} {T : Type} {W : Type} (IntoInst : Into T V) (IntoInst1
  : Into W V) (b : Bool) (x : T) (y : W) :
  Result (Dyn (fun _dyn => Into _dyn V))
  := do
  if b
  then ok (Dyn.mk _ IntoInst x)
  else ok (Dyn.mk _ IntoInst1 y)

/- Trait declaration: [dyn::Trivial]
   Source: 'tests/src/dyn.rs', lines 48:0-48:16 -/
structure Trivial (Self : Type) where

/- [dyn::dyn_closure::closure]
   Source: 'tests/src/dyn.rs', lines 51:12-51:33 -/
@[reducible]
def dyn_closure.closure {T0 : Type} (TrivialInst : Trivial T0) := Unit

/- [dyn::dyn_closure]:
   Source: 'tests/src/dyn.rs', lines 50:0-52:1 -/
def dyn_closure
  {T0 : Type} (TrivialInst : Trivial T0) (t : T0) : Result Unit := do
  ok ()

/- [dyn::dyn_closure::{core::ops::function::Fn<(u32), u32> for dyn::dyn_closure::closure<T0>[TraitClause@0]}::call]:
   Source: 'tests/src/dyn.rs', lines 51:12-51:33 -/
def dyn_closure.closure.Insts.CoreOpsFunctionFnTupleU32U32.call
  {T0 : Type} (TrivialInst : Trivial T0) (c : dyn_closure.closure TrivialInst)
  (tupled_args : Std.U32) :
  Result Std.U32
  := do
  ok tupled_args

/- [dyn::dyn_closure::{core::ops::function::FnMut<(u32), u32> for dyn::dyn_closure::closure<T0>[TraitClause@0]}::call_mut]:
   Source: 'tests/src/dyn.rs', lines 51:12-51:33 -/
def dyn_closure.closure.Insts.CoreOpsFunctionFnMutTupleU32U32.call_mut
  {T0 : Type} (TrivialInst : Trivial T0)
  (state : dyn_closure.closure TrivialInst) (args : Std.U32) :
  Result (Std.U32 × (dyn_closure.closure TrivialInst))
  := do
  let i ←
    dyn_closure.closure.Insts.CoreOpsFunctionFnTupleU32U32.call TrivialInst
      state args
  ok (i, state)

/- [dyn::dyn_closure::{core::ops::function::FnOnce<(u32), u32> for dyn::dyn_closure::closure<T0>[TraitClause@0]}::call_once]:
   Source: 'tests/src/dyn.rs', lines 51:12-51:33 -/
def dyn_closure.closure.Insts.CoreOpsFunctionFnOnceTupleU32U32.call_once
  {T0 : Type} (TrivialInst : Trivial T0) (c : dyn_closure.closure TrivialInst)
  (i : Std.U32) :
  Result Std.U32
  := do
  let (i1, _) ←
    dyn_closure.closure.Insts.CoreOpsFunctionFnMutTupleU32U32.call_mut
      TrivialInst c i
  ok i1

/- Trait implementation: [dyn::dyn_closure::{core::ops::function::FnOnce<(u32), u32> for dyn::dyn_closure::closure<T0>[TraitClause@0]}]
   Source: 'tests/src/dyn.rs', lines 51:12-51:33 -/
@[reducible]
def dyn_closure.closure.Insts.CoreOpsFunctionFnOnceTupleU32U32 {T0 : Type}
  (TrivialInst : Trivial T0) : core.ops.function.FnOnce (dyn_closure.closure
  TrivialInst) Std.U32 Std.U32 := {
  call_once :=
    dyn_closure.closure.Insts.CoreOpsFunctionFnOnceTupleU32U32.call_once
    TrivialInst
}

/- Trait implementation: [dyn::dyn_closure::{core::ops::function::FnMut<(u32), u32> for dyn::dyn_closure::closure<T0>[TraitClause@0]}]
   Source: 'tests/src/dyn.rs', lines 51:12-51:33 -/
@[reducible]
def dyn_closure.closure.Insts.CoreOpsFunctionFnMutTupleU32U32 {T0 : Type}
  (TrivialInst : Trivial T0) : core.ops.function.FnMut (dyn_closure.closure
  TrivialInst) Std.U32 Std.U32 := {
  FnOnceInst := dyn_closure.closure.Insts.CoreOpsFunctionFnOnceTupleU32U32
    TrivialInst
  call_mut :=
    dyn_closure.closure.Insts.CoreOpsFunctionFnMutTupleU32U32.call_mut
    TrivialInst
}

/- Trait implementation: [dyn::dyn_closure::{core::ops::function::Fn<(u32), u32> for dyn::dyn_closure::closure<T0>[TraitClause@0]}]
   Source: 'tests/src/dyn.rs', lines 51:12-51:33 -/
@[reducible]
def dyn_closure.closure.Insts.CoreOpsFunctionFnTupleU32U32 {T0 : Type}
  (TrivialInst : Trivial T0) : core.ops.function.Fn (dyn_closure.closure
  TrivialInst) Std.U32 Std.U32 := {
  FnMutInst := dyn_closure.closure.Insts.CoreOpsFunctionFnMutTupleU32U32
    TrivialInst
  call := dyn_closure.closure.Insts.CoreOpsFunctionFnTupleU32U32.call
    TrivialInst
}

end dyn
