-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [hashmap]: function definitions
import Aeneas
import Hashmap.Types
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace hashmap

/- [hashmap::hash_key]:
   Source: 'tests/src/hashmap.rs', lines 36:0-41:1 -/
def hash_key (k : Usize) : Result Usize := do
  ok k

/- [hashmap::{core::clone::Clone for hashmap::Fraction}::clone]:
   Source: 'tests/src/hashmap.rs', lines 43:9-43:14 -/
def ClonehashmapFraction.clone (self : Fraction) : Result Fraction := do
  ok self

/- [hashmap::{core::clone::Clone for hashmap::Fraction}::clone_from]:
   Source: 'tests/src/hashmap.rs', lines 43:9-43:14 -/
def ClonehashmapFraction.clone_from
  (self : Fraction) (source : Fraction) : Result Fraction := do
  ClonehashmapFraction.clone source

/- Trait implementation: [hashmap::{core::clone::Clone for hashmap::Fraction}]
   Source: 'tests/src/hashmap.rs', lines 43:9-43:14 -/
@[reducible]
def core.clone.ClonehashmapFraction : core.clone.Clone Fraction := {
  clone := ClonehashmapFraction.clone
  clone_from := ClonehashmapFraction.clone_from
}

/- Trait implementation: [hashmap::{core::marker::Copy for hashmap::Fraction}]
   Source: 'tests/src/hashmap.rs', lines 43:16-43:20 -/
@[reducible]
def core.marker.CopyhashmapFraction : core.marker.Copy Fraction := {
  cloneInst := core.clone.ClonehashmapFraction
}

/- [hashmap::{hashmap::HashMap<T>}::allocate_slots]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 68:8-71:9 -/
def HashMap.allocate_slots_loop
  {T : Type} (slots : alloc.vec.Vec (AList T)) (n : Usize) :
  Result (alloc.vec.Vec (AList T))
  := do
  if n > 0#usize
  then
    let slots1 ← alloc.vec.Vec.push slots AList.Nil
    let n1 ← n - 1#usize
    HashMap.allocate_slots_loop slots1 n1
  else ok slots
partial_fixpoint

/- [hashmap::{hashmap::HashMap<T>}::allocate_slots]:
   Source: 'tests/src/hashmap.rs', lines 67:4-73:5 -/
@[reducible]
def HashMap.allocate_slots
  {T : Type} (slots : alloc.vec.Vec (AList T)) (n : Usize) :
  Result (alloc.vec.Vec (AList T))
  := do
  HashMap.allocate_slots_loop slots n

/- [hashmap::{hashmap::HashMap<T>}::new_with_capacity]:
   Source: 'tests/src/hashmap.rs', lines 76:4-87:5 -/
def HashMap.new_with_capacity
  (T : Type) (capacity : Usize) (max_load_factor : Fraction) :
  Result (HashMap T)
  := do
  let slots ← HashMap.allocate_slots (alloc.vec.Vec.new (AList T)) capacity
  let i ← capacity * max_load_factor.dividend
  let i1 ← i / max_load_factor.divisor
  ok
    {
      num_entries := 0#usize,
      max_load_factor,
      max_load := i1,
      saturated := false,
      slots
    }

/- [hashmap::{hashmap::HashMap<T>}::new]:
   Source: 'tests/src/hashmap.rs', lines 89:4-98:5 -/
def HashMap.new (T : Type) : Result (HashMap T) := do
  HashMap.new_with_capacity T 32#usize
    { dividend := 4#usize, divisor := 5#usize }

/- [hashmap::{hashmap::HashMap<T>}::clear]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 104:8-107:9 -/
def HashMap.clear_loop
  {T : Type} (slots : alloc.vec.Vec (AList T)) (i : Usize) :
  Result (alloc.vec.Vec (AList T))
  := do
  let i1 := alloc.vec.Vec.len slots
  if i < i1
  then
    let (_, index_mut_back) ←
      alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSlice (AList T))
        slots i
    let i2 ← i + 1#usize
    let slots1 := index_mut_back AList.Nil
    HashMap.clear_loop slots1 i2
  else ok slots
partial_fixpoint

/- [hashmap::{hashmap::HashMap<T>}::clear]:
   Source: 'tests/src/hashmap.rs', lines 100:4-108:5 -/
def HashMap.clear {T : Type} (self : HashMap T) : Result (HashMap T) := do
  let slots ← HashMap.clear_loop self.slots 0#usize
  ok { self with num_entries := 0#usize, slots }

/- [hashmap::{hashmap::HashMap<T>}::len]:
   Source: 'tests/src/hashmap.rs', lines 110:4-112:5 -/
def HashMap.len {T : Type} (self : HashMap T) : Result Usize := do
  ok self.num_entries

/- [hashmap::{hashmap::HashMap<T>}::insert_in_list]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 1:0-133:9 -/
def HashMap.insert_in_list_loop
  {T : Type} (key : Usize) (value : T) (ls : AList T) :
  Result (Bool × (AList T))
  := do
  match ls with
  | AList.Cons ckey cvalue tl =>
    if ckey = key
    then ok (false, AList.Cons ckey value tl)
    else
      let (b, back) ← HashMap.insert_in_list_loop key value tl
      let back1 := AList.Cons ckey cvalue back
      ok (b, back1)
  | AList.Nil => ok (true, AList.Cons key value AList.Nil)
partial_fixpoint

/- [hashmap::{hashmap::HashMap<T>}::insert_in_list]:
   Source: 'tests/src/hashmap.rs', lines 117:4-134:5 -/
@[reducible]
def HashMap.insert_in_list
  {T : Type} (key : Usize) (value : T) (ls : AList T) :
  Result (Bool × (AList T))
  := do
  HashMap.insert_in_list_loop key value ls

/- [hashmap::{hashmap::HashMap<T>}::insert_no_resize]:
   Source: 'tests/src/hashmap.rs', lines 137:4-145:5 -/
def HashMap.insert_no_resize
  {T : Type} (self : HashMap T) (key : Usize) (value : T) :
  Result (HashMap T)
  := do
  let hash ← hash_key key
  let i := alloc.vec.Vec.len self.slots
  let hash_mod ← hash % i
  let (a, index_mut_back) ←
    alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSlice (AList T))
      self.slots hash_mod
  let (inserted, a1) ← HashMap.insert_in_list key value a
  if inserted
  then
    let i1 ← self.num_entries + 1#usize
    let v := index_mut_back a1
    ok { self with num_entries := i1, slots := v }
  else let v := index_mut_back a1
       ok { self with slots := v }

/- [hashmap::{hashmap::HashMap<T>}::move_elements_from_list]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 199:12-206:17 -/
def HashMap.move_elements_from_list_loop
  {T : Type} (ntable : HashMap T) (ls : AList T) : Result (HashMap T) := do
  match ls with
  | AList.Cons k v tl =>
    let ntable1 ← HashMap.insert_no_resize ntable k v
    HashMap.move_elements_from_list_loop ntable1 tl
  | AList.Nil => ok ntable
partial_fixpoint

/- [hashmap::{hashmap::HashMap<T>}::move_elements_from_list]:
   Source: 'tests/src/hashmap.rs', lines 196:4-209:5 -/
@[reducible]
def HashMap.move_elements_from_list
  {T : Type} (ntable : HashMap T) (ls : AList T) : Result (HashMap T) := do
  HashMap.move_elements_from_list_loop ntable ls

/- [hashmap::{hashmap::HashMap<T>}::move_elements]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 185:8-192:9 -/
def HashMap.move_elements_loop
  {T : Type} (ntable : HashMap T) (slots : alloc.vec.Vec (AList T)) (i : Usize)
  :
  Result ((HashMap T) × (alloc.vec.Vec (AList T)))
  := do
  let i1 := alloc.vec.Vec.len slots
  if i < i1
  then
    let (a, index_mut_back) ←
      alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSlice (AList T))
        slots i
    let (ls, a1) := core.mem.replace a AList.Nil
    let ntable1 ← HashMap.move_elements_from_list ntable ls
    let i2 ← i + 1#usize
    let slots1 := index_mut_back a1
    HashMap.move_elements_loop ntable1 slots1 i2
  else ok (ntable, slots)
partial_fixpoint

/- [hashmap::{hashmap::HashMap<T>}::move_elements]:
   Source: 'tests/src/hashmap.rs', lines 183:4-193:5 -/
@[reducible]
def HashMap.move_elements
  {T : Type} (ntable : HashMap T) (slots : alloc.vec.Vec (AList T)) :
  Result ((HashMap T) × (alloc.vec.Vec (AList T)))
  := do
  HashMap.move_elements_loop ntable slots 0#usize

/- [hashmap::{hashmap::HashMap<T>}::try_resize]:
   Source: 'tests/src/hashmap.rs', lines 160:4-179:5 -/
def HashMap.try_resize {T : Type} (self : HashMap T) : Result (HashMap T) := do
  let capacity := alloc.vec.Vec.len self.slots
  let n1 ← core.num.Usize.MAX / 2#usize
  let i ← n1 / self.max_load_factor.dividend
  if capacity <= i
  then
    let i1 ← capacity * 2#usize
    let ntable ← HashMap.new_with_capacity T i1 self.max_load_factor
    let (ntable1, _) ← HashMap.move_elements ntable self.slots
    ok { self with max_load := ntable1.max_load, slots := ntable1.slots }
  else ok { self with saturated := true }

/- [hashmap::{hashmap::HashMap<T>}::insert]:
   Source: 'tests/src/hashmap.rs', lines 149:4-156:5 -/
def HashMap.insert
  {T : Type} (self : HashMap T) (key : Usize) (value : T) :
  Result (HashMap T)
  := do
  let self1 ← HashMap.insert_no_resize self key value
  let i ← HashMap.len self1
  if i > self1.max_load
  then if self1.saturated
       then ok self1
       else HashMap.try_resize self1
  else ok self1

/- [hashmap::{hashmap::HashMap<T>}::contains_key_in_list]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 1:0-231:9 -/
def HashMap.contains_key_in_list_loop
  {T : Type} (key : Usize) (ls : AList T) : Result Bool := do
  match ls with
  | AList.Cons ckey _ tl =>
    if ckey = key
    then ok true
    else HashMap.contains_key_in_list_loop key tl
  | AList.Nil => ok false
partial_fixpoint

/- [hashmap::{hashmap::HashMap<T>}::contains_key_in_list]:
   Source: 'tests/src/hashmap.rs', lines 219:4-232:5 -/
@[reducible]
def HashMap.contains_key_in_list
  {T : Type} (key : Usize) (ls : AList T) : Result Bool := do
  HashMap.contains_key_in_list_loop key ls

/- [hashmap::{hashmap::HashMap<T>}::contains_key]:
   Source: 'tests/src/hashmap.rs', lines 212:4-216:5 -/
def HashMap.contains_key
  {T : Type} (self : HashMap T) (key : Usize) : Result Bool := do
  let hash ← hash_key key
  let i := alloc.vec.Vec.len self.slots
  let hash_mod ← hash % i
  let a ←
    alloc.vec.Vec.index (core.slice.index.SliceIndexUsizeSlice (AList T))
      self.slots hash_mod
  HashMap.contains_key_in_list key a

/- [hashmap::{hashmap::HashMap<T>}::get_in_list]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 238:8-246:5 -/
def HashMap.get_in_list_loop
  {T : Type} (key : Usize) (ls : AList T) : Result (Option T) := do
  match ls with
  | AList.Cons ckey cvalue tl =>
    if ckey = key
    then ok (some cvalue)
    else HashMap.get_in_list_loop key tl
  | AList.Nil => ok none
partial_fixpoint

/- [hashmap::{hashmap::HashMap<T>}::get_in_list]:
   Source: 'tests/src/hashmap.rs', lines 237:4-246:5 -/
@[reducible]
def HashMap.get_in_list
  {T : Type} (key : Usize) (ls : AList T) : Result (Option T) := do
  HashMap.get_in_list_loop key ls

/- [hashmap::{hashmap::HashMap<T>}::get]:
   Source: 'tests/src/hashmap.rs', lines 248:4-252:5 -/
def HashMap.get
  {T : Type} (self : HashMap T) (key : Usize) : Result (Option T) := do
  let hash ← hash_key key
  let i := alloc.vec.Vec.len self.slots
  let hash_mod ← hash % i
  let a ←
    alloc.vec.Vec.index (core.slice.index.SliceIndexUsizeSlice (AList T))
      self.slots hash_mod
  HashMap.get_in_list key a

/- [hashmap::{hashmap::HashMap<T>}::get_mut_in_list]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 255:8-263:5 -/
def HashMap.get_mut_in_list_loop
  {T : Type} (ls : AList T) (key : Usize) :
  Result ((Option T) × (Option T → AList T))
  := do
  match ls with
  | AList.Cons ckey cvalue tl =>
    if ckey = key
    then
      ok (some cvalue,
        fun ret =>
          let t := match ret with
                   | some t1 => t1
                   | _ => cvalue
          AList.Cons ckey t tl)
    else
      let (o, back) ← HashMap.get_mut_in_list_loop tl key
      let back1 := fun ret => let a := back ret
                              AList.Cons ckey cvalue a
      ok (o, back1)
  | AList.Nil => ok (none, fun ret => AList.Nil)
partial_fixpoint

/- [hashmap::{hashmap::HashMap<T>}::get_mut_in_list]:
   Source: 'tests/src/hashmap.rs', lines 254:4-263:5 -/
@[reducible]
def HashMap.get_mut_in_list
  {T : Type} (ls : AList T) (key : Usize) :
  Result ((Option T) × (Option T → AList T))
  := do
  HashMap.get_mut_in_list_loop ls key

/- [hashmap::{hashmap::HashMap<T>}::get_mut]:
   Source: 'tests/src/hashmap.rs', lines 266:4-270:5 -/
def HashMap.get_mut
  {T : Type} (self : HashMap T) (key : Usize) :
  Result ((Option T) × (Option T → HashMap T))
  := do
  let hash ← hash_key key
  let i := alloc.vec.Vec.len self.slots
  let hash_mod ← hash % i
  let (a, index_mut_back) ←
    alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSlice (AList T))
      self.slots hash_mod
  let (o, get_mut_in_list_back) ← HashMap.get_mut_in_list a key
  let back :=
    fun ret =>
      let a1 := get_mut_in_list_back ret
      let v := index_mut_back a1
      { self with slots := v }
  ok (o, back)

/- [hashmap::{hashmap::HashMap<T>}::remove_from_list]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 1:0-297:17 -/
def HashMap.remove_from_list_loop
  {T : Type} (key : Usize) (ls : AList T) :
  Result ((Option T) × (AList T))
  := do
  match ls with
  | AList.Cons ckey t tl =>
    if ckey = key
    then
      let (mv_ls, _) := core.mem.replace ls AList.Nil
      match mv_ls with
      | AList.Cons _ cvalue tl1 => ok (some cvalue, tl1)
      | AList.Nil => fail panic
    else
      let (o, back) ← HashMap.remove_from_list_loop key tl
      let back1 := AList.Cons ckey t back
      ok (o, back1)
  | AList.Nil => ok (none, AList.Nil)
partial_fixpoint

/- [hashmap::{hashmap::HashMap<T>}::remove_from_list]:
   Source: 'tests/src/hashmap.rs', lines 274:4-300:5 -/
@[reducible]
def HashMap.remove_from_list
  {T : Type} (key : Usize) (ls : AList T) :
  Result ((Option T) × (AList T))
  := do
  HashMap.remove_from_list_loop key ls

/- [hashmap::{hashmap::HashMap<T>}::remove]:
   Source: 'tests/src/hashmap.rs', lines 303:4-315:5 -/
def HashMap.remove
  {T : Type} (self : HashMap T) (key : Usize) :
  Result ((Option T) × (HashMap T))
  := do
  let hash ← hash_key key
  let i := alloc.vec.Vec.len self.slots
  let hash_mod ← hash % i
  let (a, index_mut_back) ←
    alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSlice (AList T))
      self.slots hash_mod
  let (x, a1) ← HashMap.remove_from_list key a
  match x with
  | none => let v := index_mut_back a1
            ok (none, { self with slots := v })
  | some _ =>
    let i1 ← self.num_entries - 1#usize
    let v := index_mut_back a1
    ok (x, { self with num_entries := i1, slots := v })

end hashmap
