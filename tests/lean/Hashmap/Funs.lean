-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [hashmap]: function definitions
import Base
import Hashmap.Types
import Hashmap.FunsExternal
open Primitives

namespace hashmap

/- [hashmap::hash_key]:
   Source: 'tests/src/hashmap.rs', lines 37:0-37:32 -/
def hash_key (k : Usize) : Result Usize :=
  Result.ok k

/- [hashmap::{hashmap::HashMap<T>}::allocate_slots]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 60:4-66:5 -/
divergent def HashMap.allocate_slots_loop
  (T : Type) (slots : alloc.vec.Vec (List T)) (n : Usize) :
  Result (alloc.vec.Vec (List T))
  :=
  if n > 0usize
  then
    do
    let slots1 ← alloc.vec.Vec.push (List T) slots List.Nil
    let n1 ← n - 1usize
    HashMap.allocate_slots_loop T slots1 n1
  else Result.ok slots

/- [hashmap::{hashmap::HashMap<T>}::allocate_slots]:
   Source: 'tests/src/hashmap.rs', lines 60:4-60:76 -/
def HashMap.allocate_slots
  (T : Type) (slots : alloc.vec.Vec (List T)) (n : Usize) :
  Result (alloc.vec.Vec (List T))
  :=
  HashMap.allocate_slots_loop T slots n

/- [hashmap::{hashmap::HashMap<T>}::new_with_capacity]:
   Source: 'tests/src/hashmap.rs', lines 69:4-73:13 -/
def HashMap.new_with_capacity
  (T : Type) (capacity : Usize) (max_load_dividend : Usize)
  (max_load_divisor : Usize) :
  Result (HashMap T)
  :=
  do
  let slots ← HashMap.allocate_slots T (alloc.vec.Vec.new (List T)) capacity
  let i ← capacity * max_load_dividend
  let i1 ← i / max_load_divisor
  Result.ok
    {
      num_entries := 0usize,
      max_load_factor := (max_load_dividend, max_load_divisor),
      max_load := i1,
      slots := slots
    }

/- [hashmap::{hashmap::HashMap<T>}::new]:
   Source: 'tests/src/hashmap.rs', lines 85:4-85:24 -/
def HashMap.new (T : Type) : Result (HashMap T) :=
  HashMap.new_with_capacity T 32usize 4usize 5usize

/- [hashmap::{hashmap::HashMap<T>}::clear]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 90:4-98:5 -/
divergent def HashMap.clear_loop
  (T : Type) (slots : alloc.vec.Vec (List T)) (i : Usize) :
  Result (alloc.vec.Vec (List T))
  :=
  let i1 := alloc.vec.Vec.len (List T) slots
  if i < i1
  then
    do
    let (_, index_mut_back) ←
      alloc.vec.Vec.index_mut (List T) Usize
        (core.slice.index.SliceIndexUsizeSliceTInst (List T)) slots i
    let i2 ← i + 1usize
    let slots1 ← index_mut_back List.Nil
    HashMap.clear_loop T slots1 i2
  else Result.ok slots

/- [hashmap::{hashmap::HashMap<T>}::clear]:
   Source: 'tests/src/hashmap.rs', lines 90:4-90:27 -/
def HashMap.clear (T : Type) (self : HashMap T) : Result (HashMap T) :=
  do
  let hm ← HashMap.clear_loop T self.slots 0usize
  Result.ok { self with num_entries := 0usize, slots := hm }

/- [hashmap::{hashmap::HashMap<T>}::len]:
   Source: 'tests/src/hashmap.rs', lines 100:4-100:30 -/
def HashMap.len (T : Type) (self : HashMap T) : Result Usize :=
  Result.ok self.num_entries

/- [hashmap::{hashmap::HashMap<T>}::insert_in_list]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 107:4-124:5 -/
divergent def HashMap.insert_in_list_loop
  (T : Type) (key : Usize) (value : T) (ls : List T) :
  Result (Bool × (List T))
  :=
  match ls with
  | List.Cons ckey cvalue tl =>
    if ckey = key
    then Result.ok (false, List.Cons ckey value tl)
    else
      do
      let (b, tl1) ← HashMap.insert_in_list_loop T key value tl
      Result.ok (b, List.Cons ckey cvalue tl1)
  | List.Nil => Result.ok (true, List.Cons key value List.Nil)

/- [hashmap::{hashmap::HashMap<T>}::insert_in_list]:
   Source: 'tests/src/hashmap.rs', lines 107:4-107:71 -/
def HashMap.insert_in_list
  (T : Type) (key : Usize) (value : T) (ls : List T) :
  Result (Bool × (List T))
  :=
  HashMap.insert_in_list_loop T key value ls

/- [hashmap::{hashmap::HashMap<T>}::insert_no_resize]:
   Source: 'tests/src/hashmap.rs', lines 127:4-127:54 -/
def HashMap.insert_no_resize
  (T : Type) (self : HashMap T) (key : Usize) (value : T) :
  Result (HashMap T)
  :=
  do
  let hash ← hash_key key
  let i := alloc.vec.Vec.len (List T) self.slots
  let hash_mod ← hash % i
  let (l, index_mut_back) ←
    alloc.vec.Vec.index_mut (List T) Usize
      (core.slice.index.SliceIndexUsizeSliceTInst (List T)) self.slots hash_mod
  let (inserted, l1) ← HashMap.insert_in_list T key value l
  if inserted
  then
    do
    let i1 ← self.num_entries + 1usize
    let v ← index_mut_back l1
    Result.ok { self with num_entries := i1, slots := v }
  else do
       let v ← index_mut_back l1
       Result.ok { self with slots := v }

/- [hashmap::{hashmap::HashMap<T>}::move_elements_from_list]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 193:4-206:5 -/
divergent def HashMap.move_elements_from_list_loop
  (T : Type) (ntable : HashMap T) (ls : List T) : Result (HashMap T) :=
  match ls with
  | List.Cons k v tl =>
    do
    let ntable1 ← HashMap.insert_no_resize T ntable k v
    HashMap.move_elements_from_list_loop T ntable1 tl
  | List.Nil => Result.ok ntable

/- [hashmap::{hashmap::HashMap<T>}::move_elements_from_list]:
   Source: 'tests/src/hashmap.rs', lines 193:4-193:72 -/
def HashMap.move_elements_from_list
  (T : Type) (ntable : HashMap T) (ls : List T) : Result (HashMap T) :=
  HashMap.move_elements_from_list_loop T ntable ls

/- [hashmap::{hashmap::HashMap<T>}::move_elements]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 181:4-190:5 -/
divergent def HashMap.move_elements_loop
  (T : Type) (ntable : HashMap T) (slots : alloc.vec.Vec (List T)) (i : Usize)
  :
  Result ((HashMap T) × (alloc.vec.Vec (List T)))
  :=
  let i1 := alloc.vec.Vec.len (List T) slots
  if i < i1
  then
    do
    let (l, index_mut_back) ←
      alloc.vec.Vec.index_mut (List T) Usize
        (core.slice.index.SliceIndexUsizeSliceTInst (List T)) slots i
    let (ls, l1) := core.mem.replace (List T) l List.Nil
    let ntable1 ← HashMap.move_elements_from_list T ntable ls
    let i2 ← i + 1usize
    let slots1 ← index_mut_back l1
    HashMap.move_elements_loop T ntable1 slots1 i2
  else Result.ok (ntable, slots)

/- [hashmap::{hashmap::HashMap<T>}::move_elements]:
   Source: 'tests/src/hashmap.rs', lines 181:4-181:95 -/
def HashMap.move_elements
  (T : Type) (ntable : HashMap T) (slots : alloc.vec.Vec (List T)) (i : Usize)
  :
  Result ((HashMap T) × (alloc.vec.Vec (List T)))
  :=
  HashMap.move_elements_loop T ntable slots i

/- [hashmap::{hashmap::HashMap<T>}::try_resize]:
   Source: 'tests/src/hashmap.rs', lines 150:4-150:28 -/
def HashMap.try_resize (T : Type) (self : HashMap T) : Result (HashMap T) :=
  do
  let max_usize ← Scalar.cast .Usize core_u32_max
  let capacity := alloc.vec.Vec.len (List T) self.slots
  let n1 ← max_usize / 2usize
  let (i, i1) := self.max_load_factor
  let i2 ← n1 / i
  if capacity <= i2
  then
    do
    let i3 ← capacity * 2usize
    let ntable ← HashMap.new_with_capacity T i3 i i1
    let p ← HashMap.move_elements T ntable self.slots 0usize
    let (ntable1, _) := p
    Result.ok
      {
        ntable1
          with
          num_entries := self.num_entries, max_load_factor := (i, i1)
      }
  else Result.ok { self with max_load_factor := (i, i1) }

/- [hashmap::{hashmap::HashMap<T>}::insert]:
   Source: 'tests/src/hashmap.rs', lines 139:4-139:48 -/
def HashMap.insert
  (T : Type) (self : HashMap T) (key : Usize) (value : T) :
  Result (HashMap T)
  :=
  do
  let self1 ← HashMap.insert_no_resize T self key value
  let i ← HashMap.len T self1
  if i > self1.max_load
  then HashMap.try_resize T self1
  else Result.ok self1

/- [hashmap::{hashmap::HashMap<T>}::contains_key_in_list]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 216:4-229:5 -/
divergent def HashMap.contains_key_in_list_loop
  (T : Type) (key : Usize) (ls : List T) : Result Bool :=
  match ls with
  | List.Cons ckey _ tl =>
    if ckey = key
    then Result.ok true
    else HashMap.contains_key_in_list_loop T key tl
  | List.Nil => Result.ok false

/- [hashmap::{hashmap::HashMap<T>}::contains_key_in_list]:
   Source: 'tests/src/hashmap.rs', lines 216:4-216:68 -/
def HashMap.contains_key_in_list
  (T : Type) (key : Usize) (ls : List T) : Result Bool :=
  HashMap.contains_key_in_list_loop T key ls

/- [hashmap::{hashmap::HashMap<T>}::contains_key]:
   Source: 'tests/src/hashmap.rs', lines 209:4-209:49 -/
def HashMap.contains_key
  (T : Type) (self : HashMap T) (key : Usize) : Result Bool :=
  do
  let hash ← hash_key key
  let i := alloc.vec.Vec.len (List T) self.slots
  let hash_mod ← hash % i
  let l ←
    alloc.vec.Vec.index (List T) Usize
      (core.slice.index.SliceIndexUsizeSliceTInst (List T)) self.slots hash_mod
  HashMap.contains_key_in_list T key l

/- [hashmap::{hashmap::HashMap<T>}::get_in_list]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 234:4-247:5 -/
divergent def HashMap.get_in_list_loop
  (T : Type) (key : Usize) (ls : List T) : Result T :=
  match ls with
  | List.Cons ckey cvalue tl =>
    if ckey = key
    then Result.ok cvalue
    else HashMap.get_in_list_loop T key tl
  | List.Nil => Result.fail .panic

/- [hashmap::{hashmap::HashMap<T>}::get_in_list]:
   Source: 'tests/src/hashmap.rs', lines 234:4-234:70 -/
def HashMap.get_in_list (T : Type) (key : Usize) (ls : List T) : Result T :=
  HashMap.get_in_list_loop T key ls

/- [hashmap::{hashmap::HashMap<T>}::get]:
   Source: 'tests/src/hashmap.rs', lines 249:4-249:55 -/
def HashMap.get (T : Type) (self : HashMap T) (key : Usize) : Result T :=
  do
  let hash ← hash_key key
  let i := alloc.vec.Vec.len (List T) self.slots
  let hash_mod ← hash % i
  let l ←
    alloc.vec.Vec.index (List T) Usize
      (core.slice.index.SliceIndexUsizeSliceTInst (List T)) self.slots hash_mod
  HashMap.get_in_list T key l

/- [hashmap::{hashmap::HashMap<T>}::get_mut_in_list]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 255:4-264:5 -/
divergent def HashMap.get_mut_in_list_loop
  (T : Type) (ls : List T) (key : Usize) :
  Result (T × (T → Result (List T)))
  :=
  match ls with
  | List.Cons ckey cvalue tl =>
    if ckey = key
    then
      let back := fun ret => Result.ok (List.Cons ckey ret tl)
      Result.ok (cvalue, back)
    else
      do
      let (t, back) ← HashMap.get_mut_in_list_loop T tl key
      let back1 :=
        fun ret =>
          do
          let tl1 ← back ret
          Result.ok (List.Cons ckey cvalue tl1)
      Result.ok (t, back1)
  | List.Nil => Result.fail .panic

/- [hashmap::{hashmap::HashMap<T>}::get_mut_in_list]:
   Source: 'tests/src/hashmap.rs', lines 255:4-255:86 -/
def HashMap.get_mut_in_list
  (T : Type) (ls : List T) (key : Usize) :
  Result (T × (T → Result (List T)))
  :=
  HashMap.get_mut_in_list_loop T ls key

/- [hashmap::{hashmap::HashMap<T>}::get_mut]:
   Source: 'tests/src/hashmap.rs', lines 267:4-267:67 -/
def HashMap.get_mut
  (T : Type) (self : HashMap T) (key : Usize) :
  Result (T × (T → Result (HashMap T)))
  :=
  do
  let hash ← hash_key key
  let i := alloc.vec.Vec.len (List T) self.slots
  let hash_mod ← hash % i
  let (l, index_mut_back) ←
    alloc.vec.Vec.index_mut (List T) Usize
      (core.slice.index.SliceIndexUsizeSliceTInst (List T)) self.slots hash_mod
  let (t, get_mut_in_list_back) ← HashMap.get_mut_in_list T l key
  let back :=
    fun ret =>
      do
      let l1 ← get_mut_in_list_back ret
      let v ← index_mut_back l1
      Result.ok { self with slots := v }
  Result.ok (t, back)

/- [hashmap::{hashmap::HashMap<T>}::remove_from_list]: loop 0:
   Source: 'tests/src/hashmap.rs', lines 275:4-301:5 -/
divergent def HashMap.remove_from_list_loop
  (T : Type) (key : Usize) (ls : List T) : Result ((Option T) × (List T)) :=
  match ls with
  | List.Cons ckey t tl =>
    if ckey = key
    then
      let (mv_ls, _) :=
        core.mem.replace (List T) (List.Cons ckey t tl) List.Nil
      match mv_ls with
      | List.Cons _ cvalue tl1 => Result.ok (some cvalue, tl1)
      | List.Nil => Result.fail .panic
    else
      do
      let (o, tl1) ← HashMap.remove_from_list_loop T key tl
      Result.ok (o, List.Cons ckey t tl1)
  | List.Nil => Result.ok (none, List.Nil)

/- [hashmap::{hashmap::HashMap<T>}::remove_from_list]:
   Source: 'tests/src/hashmap.rs', lines 275:4-275:69 -/
def HashMap.remove_from_list
  (T : Type) (key : Usize) (ls : List T) : Result ((Option T) × (List T)) :=
  HashMap.remove_from_list_loop T key ls

/- [hashmap::{hashmap::HashMap<T>}::remove]:
   Source: 'tests/src/hashmap.rs', lines 304:4-304:52 -/
def HashMap.remove
  (T : Type) (self : HashMap T) (key : Usize) :
  Result ((Option T) × (HashMap T))
  :=
  do
  let hash ← hash_key key
  let i := alloc.vec.Vec.len (List T) self.slots
  let hash_mod ← hash % i
  let (l, index_mut_back) ←
    alloc.vec.Vec.index_mut (List T) Usize
      (core.slice.index.SliceIndexUsizeSliceTInst (List T)) self.slots hash_mod
  let (x, l1) ← HashMap.remove_from_list T key l
  match x with
  | none =>
    do
    let v ← index_mut_back l1
    Result.ok (none, { self with slots := v })
  | some x1 =>
    do
    let i1 ← self.num_entries - 1usize
    let v ← index_mut_back l1
    Result.ok (some x1, { self with num_entries := i1, slots := v })

/- [hashmap::insert_on_disk]:
   Source: 'tests/src/hashmap.rs', lines 335:0-335:43 -/
def insert_on_disk
  (key : Usize) (value : U64) (st : State) : Result (State × Unit) :=
  do
  let (st1, hm) ← utils.deserialize st
  let hm1 ← HashMap.insert U64 hm key value
  utils.serialize hm1 st1

/- [hashmap::test1]:
   Source: 'tests/src/hashmap.rs', lines 350:0-350:10 -/
def test1 : Result Unit :=
  do
  let hm ← HashMap.new U64
  let hm1 ← HashMap.insert U64 hm 0usize 42u64
  let hm2 ← HashMap.insert U64 hm1 128usize 18u64
  let hm3 ← HashMap.insert U64 hm2 1024usize 138u64
  let hm4 ← HashMap.insert U64 hm3 1056usize 256u64
  let i ← HashMap.get U64 hm4 128usize
  if i = 18u64
  then
    do
    let (_, get_mut_back) ← HashMap.get_mut U64 hm4 1024usize
    let hm5 ← get_mut_back 56u64
    let i1 ← HashMap.get U64 hm5 1024usize
    if i1 = 56u64
    then
      do
      let (x, hm6) ← HashMap.remove U64 hm5 1024usize
      match x with
      | none => Result.fail .panic
      | some x1 =>
        if x1 = 56u64
        then
          do
          let i2 ← HashMap.get U64 hm6 0usize
          if i2 = 42u64
          then
            do
            let i3 ← HashMap.get U64 hm6 128usize
            if i3 = 18u64
            then
              do
              let i4 ← HashMap.get U64 hm6 1056usize
              if i4 = 256u64
              then Result.ok ()
              else Result.fail .panic
            else Result.fail .panic
          else Result.fail .panic
        else Result.fail .panic
    else Result.fail .panic
  else Result.fail .panic

end hashmap
