-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [loops]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace loops

/- [loops::iter]: loop 0:
   Source: 'tests/src/loops.rs', lines 6:4-8:5 -/
def iter_loop (max : U32) (i : U32) : Result U32 := do
  if i < max
  then let i1 ← i + 1#u32
       iter_loop max i1
  else ok i
partial_fixpoint

/- [loops::iter]:
   Source: 'tests/src/loops.rs', lines 4:0-11:1 -/
@[reducible] def iter (max : U32) : Result U32 := do
               iter_loop max 0#u32

/- [loops::sum]: loop 0:
   Source: 'tests/src/loops.rs', lines 17:4-20:5 -/
def sum_loop (max : U32) (i : U32) (s : U32) : Result U32 := do
  if i < max
  then let s1 ← s + i
       let i1 ← i + 1#u32
       sum_loop max i1 s1
  else ok s
partial_fixpoint

/- [loops::sum]:
   Source: 'tests/src/loops.rs', lines 14:0-24:1 -/
def sum (max : U32) : Result U32 := do
  let s ← sum_loop max 0#u32 0#u32
  s * 2#u32

/- [loops::sum_with_mut_borrows]: loop 0:
   Source: 'tests/src/loops.rs', lines 32:4-37:5 -/
def sum_with_mut_borrows_loop
  (max : U32) (i : U32) (s : U32) : Result U32 := do
  if i < max
  then
    let ms ← s + i
    let mi ← i + 1#u32
    sum_with_mut_borrows_loop max mi ms
  else ok s
partial_fixpoint

/- [loops::sum_with_mut_borrows]:
   Source: 'tests/src/loops.rs', lines 29:0-41:1 -/
def sum_with_mut_borrows (max : U32) : Result U32 := do
  let s ← sum_with_mut_borrows_loop max 0#u32 0#u32
  s * 2#u32

/- [loops::sum_with_shared_borrows]: loop 0:
   Source: 'tests/src/loops.rs', lines 47:4-54:5 -/
def sum_with_shared_borrows_loop
  (max : U32) (i : U32) (s : U32) : Result U32 := do
  if i < max
  then
    let i1 ← i + 1#u32
    let s1 ← s + i1
    sum_with_shared_borrows_loop max i1 s1
  else ok s
partial_fixpoint

/- [loops::sum_with_shared_borrows]:
   Source: 'tests/src/loops.rs', lines 44:0-58:1 -/
def sum_with_shared_borrows (max : U32) : Result U32 := do
  let s ← sum_with_shared_borrows_loop max 0#u32 0#u32
  s * 2#u32

/- [loops::sum_array]: loop 0:
   Source: 'tests/src/loops.rs', lines 63:4-66:5 -/
def sum_array_loop
  {N : Usize} (a : Array U32 N) (i : Usize) (s : U32) : Result U32 := do
  if i < N
  then
    let i1 ← Array.index_usize a i
    let s1 ← s + i1
    let i2 ← i + 1#usize
    sum_array_loop a i2 s1
  else ok s
partial_fixpoint

/- [loops::sum_array]:
   Source: 'tests/src/loops.rs', lines 60:0-68:1 -/
@[reducible]
def sum_array {N : Usize} (a : Array U32 N) : Result U32 := do
  sum_array_loop a 0#usize 0#u32

/- [loops::clear]: loop 0:
   Source: 'tests/src/loops.rs', lines 74:4-77:5 -/
def clear_loop
  (v : alloc.vec.Vec U32) (i : Usize) : Result (alloc.vec.Vec U32) := do
  let i1 := alloc.vec.Vec.len v
  if i < i1
  then
    let (_, index_mut_back) ←
      alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSlice U32) v i
    let i2 ← i + 1#usize
    let v1 := index_mut_back 0#u32
    clear_loop v1 i2
  else ok v
partial_fixpoint

/- [loops::clear]:
   Source: 'tests/src/loops.rs', lines 72:0-78:1 -/
@[reducible]
def clear (v : alloc.vec.Vec U32) : Result (alloc.vec.Vec U32) := do
  clear_loop v 0#usize

/- [loops::List]
   Source: 'tests/src/loops.rs', lines 80:0-83:1 -/
inductive List (T : Type) where
| Cons : T → List T → List T
| Nil : List T

/- [loops::list_mem]: loop 0:
   Source: 'tests/src/loops.rs', lines 87:4-95:1 -/
def list_mem_loop (x : U32) (ls : List U32) : Result Bool := do
  match ls with
  | List.Cons y tl => if y = x
                      then ok true
                      else list_mem_loop x tl
  | List.Nil => ok false
partial_fixpoint

/- [loops::list_mem]:
   Source: 'tests/src/loops.rs', lines 86:0-95:1 -/
@[reducible]
def list_mem (x : U32) (ls : List U32) : Result Bool := do
  list_mem_loop x ls

/- [loops::list_nth_mut]: loop 0:
   Source: 'tests/src/loops.rs', lines 98:4-107:1 -/
def list_nth_mut_loop
  {T : Type} (ls : List T) (i : U32) : Result (T × (T → List T)) := do
  match ls with
  | List.Cons x tl =>
    if i = 0#u32
    then ok (x, fun ret => List.Cons ret tl)
    else
      let i1 ← i - 1#u32
      let (t, back) ← list_nth_mut_loop tl i1
      let back1 := fun ret => let l := back ret
                              List.Cons x l
      ok (t, back1)
  | List.Nil => fail panic
partial_fixpoint

/- [loops::list_nth_mut]:
   Source: 'tests/src/loops.rs', lines 97:0-107:1 -/
@[reducible]
def list_nth_mut
  {T : Type} (ls : List T) (i : U32) : Result (T × (T → List T)) := do
  list_nth_mut_loop ls i

/- [loops::list_nth_shared]: loop 0:
   Source: 'tests/src/loops.rs', lines 111:4-120:1 -/
def list_nth_shared_loop {T : Type} (ls : List T) (i : U32) : Result T := do
  match ls with
  | List.Cons x tl =>
    if i = 0#u32
    then ok x
    else let i1 ← i - 1#u32
         list_nth_shared_loop tl i1
  | List.Nil => fail panic
partial_fixpoint

/- [loops::list_nth_shared]:
   Source: 'tests/src/loops.rs', lines 110:0-120:1 -/
@[reducible]
def list_nth_shared {T : Type} (ls : List T) (i : U32) : Result T := do
  list_nth_shared_loop ls i

/- [loops::get_elem_mut]: loop 0:
   Source: 'tests/src/loops.rs', lines 124:4-136:1 -/
def get_elem_mut_loop
  (x : Usize) (ls : List Usize) :
  Result (Usize × (Usize → List Usize))
  := do
  match ls with
  | List.Cons y tl =>
    if y = x
    then ok (y, fun i => List.Cons i tl)
    else
      let (i, back) ← get_elem_mut_loop x tl
      let back1 := fun i1 => let l := back i1
                             List.Cons y l
      ok (i, back1)
  | List.Nil => fail panic
partial_fixpoint

/- [loops::get_elem_mut]:
   Source: 'tests/src/loops.rs', lines 122:0-136:1 -/
def get_elem_mut
  (slots : alloc.vec.Vec (List Usize)) (x : Usize) :
  Result (Usize × (Usize → alloc.vec.Vec (List Usize)))
  := do
  let (ls, index_mut_back) ←
    alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSlice (List
      Usize)) slots 0#usize
  let (i, back) ← get_elem_mut_loop x ls
  let back1 := fun ret => let l := back ret
                          index_mut_back l
  ok (i, back1)

/- [loops::get_elem_shared]: loop 0:
   Source: 'tests/src/loops.rs', lines 140:4-152:1 -/
def get_elem_shared_loop (x : Usize) (ls : List Usize) : Result Usize := do
  match ls with
  | List.Cons y tl => if y = x
                      then ok y
                      else get_elem_shared_loop x tl
  | List.Nil => fail panic
partial_fixpoint

/- [loops::get_elem_shared]:
   Source: 'tests/src/loops.rs', lines 138:0-152:1 -/
def get_elem_shared
  (slots : alloc.vec.Vec (List Usize)) (x : Usize) : Result Usize := do
  let ls ←
    alloc.vec.Vec.index (core.slice.index.SliceIndexUsizeSlice (List Usize))
      slots 0#usize
  get_elem_shared_loop x ls

/- [loops::id_mut]:
   Source: 'tests/src/loops.rs', lines 154:0-156:1 -/
def id_mut
  {T : Type} (ls : List T) : Result ((List T) × (List T → List T)) := do
  ok (ls, fun ret => ret)

/- [loops::id_shared]:
   Source: 'tests/src/loops.rs', lines 158:0-160:1 -/
def id_shared {T : Type} (ls : List T) : Result (List T) := do
  ok ls

/- [loops::list_nth_mut_with_id]: loop 0:
   Source: 'tests/src/loops.rs', lines 165:4-174:1 -/
def list_nth_mut_with_id_loop
  {T : Type} (i : U32) (ls : List T) : Result (T × (T → List T)) := do
  match ls with
  | List.Cons x tl =>
    if i = 0#u32
    then ok (x, fun t => List.Cons t tl)
    else
      let i1 ← i - 1#u32
      let (t, back) ← list_nth_mut_with_id_loop i1 tl
      let back1 := fun t1 => let l := back t1
                             List.Cons x l
      ok (t, back1)
  | List.Nil => fail panic
partial_fixpoint

/- [loops::list_nth_mut_with_id]:
   Source: 'tests/src/loops.rs', lines 163:0-174:1 -/
def list_nth_mut_with_id
  {T : Type} (ls : List T) (i : U32) : Result (T × (T → List T)) := do
  let (ls1, id_mut_back) ← id_mut ls
  let (t, back) ← list_nth_mut_with_id_loop i ls1
  let back1 := fun ret => let l := back ret
                          id_mut_back l
  ok (t, back1)

/- [loops::list_nth_shared_with_id]: loop 0:
   Source: 'tests/src/loops.rs', lines 179:4-188:1 -/
def list_nth_shared_with_id_loop
  {T : Type} (i : U32) (ls : List T) : Result T := do
  match ls with
  | List.Cons x tl =>
    if i = 0#u32
    then ok x
    else let i1 ← i - 1#u32
         list_nth_shared_with_id_loop i1 tl
  | List.Nil => fail panic
partial_fixpoint

/- [loops::list_nth_shared_with_id]:
   Source: 'tests/src/loops.rs', lines 177:0-188:1 -/
def list_nth_shared_with_id {T : Type} (ls : List T) (i : U32) : Result T := do
  let ls1 ← id_shared ls
  list_nth_shared_with_id_loop i ls1

/- [loops::list_nth_mut_pair]: loop 0:
   Source: 'tests/src/loops.rs', lines 199:8-199:24 -/
def list_nth_mut_pair_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) :
  Result (T × T × (T → List T) × (T → List T))
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1, fun t => List.Cons t tl0, fun t => List.Cons t tl1)
      else
        let i1 ← i - 1#u32
        let (t, t1, back, back1) ← list_nth_mut_pair_loop tl0 tl1 i1
        let back2 := fun t2 => let l := back t2
                               List.Cons x0 l
        let back3 := fun t2 => let l := back1 t2
                               List.Cons x1 l
        ok (t, t1, back2, back3)
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops::list_nth_mut_pair]:
   Source: 'tests/src/loops.rs', lines 193:0-214:1 -/
def list_nth_mut_pair
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) :
  Result ((T × T) × (T → List T) × (T → List T))
  := do
  let (t, t1, back, back1) ← list_nth_mut_pair_loop ls0 ls1 i
  ok ((t, t1), back, back1)

/- [loops::list_nth_shared_pair]: loop 0:
   Source: 'tests/src/loops.rs', lines 223:8-223:24 -/
def list_nth_shared_pair_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) : Result (T × T) := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1)
      else let i1 ← i - 1#u32
           list_nth_shared_pair_loop tl0 tl1 i1
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops::list_nth_shared_pair]:
   Source: 'tests/src/loops.rs', lines 217:0-238:1 -/
@[reducible]
def list_nth_shared_pair
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) : Result (T × T) := do
  list_nth_shared_pair_loop ls0 ls1 i

/- [loops::list_nth_mut_pair_merge]: loop 0:
   Source: 'tests/src/loops.rs', lines 247:4-257:1 -/
def list_nth_mut_pair_merge_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) :
  Result (T × T × (T → List T) × (T → List T))
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1, fun t => List.Cons t tl0, fun t => List.Cons t tl1)
      else
        let i1 ← i - 1#u32
        let (t, t1, back, back1) ← list_nth_mut_pair_merge_loop tl0 tl1 i1
        let back2 := fun t2 => let l := back t2
                               List.Cons x0 l
        let back3 := fun t2 => let l := back1 t2
                               List.Cons x1 l
        ok (t, t1, back2, back3)
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops::list_nth_mut_pair_merge]:
   Source: 'tests/src/loops.rs', lines 242:0-257:1 -/
def list_nth_mut_pair_merge
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) :
  Result ((T × T) × ((T × T) → ((List T) × (List T))))
  := do
  let (t, t1, back, back1) ← list_nth_mut_pair_merge_loop ls0 ls1 i
  let back2 :=
    fun ret =>
      let (t2, t3) := ret
      let ls01 := back t2
      let ls11 := back1 t3
      (ls01, ls11)
  ok ((t, t1), back2)

/- [loops::list_nth_shared_pair_merge]: loop 0:
   Source: 'tests/src/loops.rs', lines 265:4-275:1 -/
def list_nth_shared_pair_merge_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) : Result (T × T) := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1)
      else let i1 ← i - 1#u32
           list_nth_shared_pair_merge_loop tl0 tl1 i1
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops::list_nth_shared_pair_merge]:
   Source: 'tests/src/loops.rs', lines 260:0-275:1 -/
@[reducible]
def list_nth_shared_pair_merge
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) : Result (T × T) := do
  list_nth_shared_pair_merge_loop ls0 ls1 i

/- [loops::list_nth_mut_shared_pair]: loop 0:
   Source: 'tests/src/loops.rs', lines 283:4-293:1 -/
def list_nth_mut_shared_pair_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) :
  Result (T × T × (T → List T))
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1, fun t => List.Cons t tl0)
      else
        let i1 ← i - 1#u32
        let (t, t1, back) ← list_nth_mut_shared_pair_loop tl0 tl1 i1
        let back1 := fun t2 => let l := back t2
                               List.Cons x0 l
        ok (t, t1, back1)
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops::list_nth_mut_shared_pair]:
   Source: 'tests/src/loops.rs', lines 278:0-293:1 -/
def list_nth_mut_shared_pair
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) :
  Result ((T × T) × (T → List T))
  := do
  let (t, t1, back) ← list_nth_mut_shared_pair_loop ls0 ls1 i
  ok ((t, t1), back)

/- [loops::list_nth_mut_shared_pair_merge]: loop 0:
   Source: 'tests/src/loops.rs', lines 302:4-312:1 -/
def list_nth_mut_shared_pair_merge_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) :
  Result (T × T × (T → List T))
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1, fun t => List.Cons t tl0)
      else
        let i1 ← i - 1#u32
        let (t, t1, back) ← list_nth_mut_shared_pair_merge_loop tl0 tl1 i1
        let back1 := fun t2 => let l := back t2
                               List.Cons x0 l
        ok (t, t1, back1)
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops::list_nth_mut_shared_pair_merge]:
   Source: 'tests/src/loops.rs', lines 297:0-312:1 -/
def list_nth_mut_shared_pair_merge
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) :
  Result ((T × T) × (T → List T))
  := do
  let (t, t1, back) ← list_nth_mut_shared_pair_merge_loop ls0 ls1 i
  ok ((t, t1), back)

/- [loops::list_nth_shared_mut_pair]: loop 0:
   Source: 'tests/src/loops.rs', lines 321:4-331:1 -/
def list_nth_shared_mut_pair_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) :
  Result (T × T × (T → List T))
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1, fun t => List.Cons t tl1)
      else
        let i1 ← i - 1#u32
        let (t, t1, back) ← list_nth_shared_mut_pair_loop tl0 tl1 i1
        let back1 := fun t2 => let l := back t2
                               List.Cons x1 l
        ok (t, t1, back1)
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops::list_nth_shared_mut_pair]:
   Source: 'tests/src/loops.rs', lines 316:0-331:1 -/
def list_nth_shared_mut_pair
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) :
  Result ((T × T) × (T → List T))
  := do
  let (t, t1, back) ← list_nth_shared_mut_pair_loop ls0 ls1 i
  ok ((t, t1), back)

/- [loops::list_nth_shared_mut_pair_merge]: loop 0:
   Source: 'tests/src/loops.rs', lines 340:4-350:1 -/
def list_nth_shared_mut_pair_merge_loop
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) :
  Result (T × T × (T → List T))
  := do
  match ls0 with
  | List.Cons x0 tl0 =>
    match ls1 with
    | List.Cons x1 tl1 =>
      if i = 0#u32
      then ok (x0, x1, fun t => List.Cons t tl1)
      else
        let i1 ← i - 1#u32
        let (t, t1, back) ← list_nth_shared_mut_pair_merge_loop tl0 tl1 i1
        let back1 := fun t2 => let l := back t2
                               List.Cons x1 l
        ok (t, t1, back1)
    | List.Nil => fail panic
  | List.Nil => fail panic
partial_fixpoint

/- [loops::list_nth_shared_mut_pair_merge]:
   Source: 'tests/src/loops.rs', lines 335:0-350:1 -/
def list_nth_shared_mut_pair_merge
  {T : Type} (ls0 : List T) (ls1 : List T) (i : U32) :
  Result ((T × T) × (T → List T))
  := do
  let (t, t1, back) ← list_nth_shared_mut_pair_merge_loop ls0 ls1 i
  ok ((t, t1), back)

/- [loops::ignore_input_mut_borrow]: loop 0:
   Source: 'tests/src/loops.rs', lines 355:4-357:5 -/
def ignore_input_mut_borrow_loop (i : U32) : Result Unit := do
  if i > 0#u32
  then let i1 ← i - 1#u32
       ignore_input_mut_borrow_loop i1
  else ok ()
partial_fixpoint

/- [loops::ignore_input_mut_borrow]:
   Source: 'tests/src/loops.rs', lines 354:0-358:1 -/
def ignore_input_mut_borrow (_a : U32) (i : U32) : Result U32 := do
  ignore_input_mut_borrow_loop i
  ok _a

/- [loops::incr_ignore_input_mut_borrow]: loop 0:
   Source: 'tests/src/loops.rs', lines 364:4-366:5 -/
def incr_ignore_input_mut_borrow_loop (i : U32) : Result Unit := do
  if i > 0#u32
  then let i1 ← i - 1#u32
       incr_ignore_input_mut_borrow_loop i1
  else ok ()
partial_fixpoint

/- [loops::incr_ignore_input_mut_borrow]:
   Source: 'tests/src/loops.rs', lines 362:0-367:1 -/
def incr_ignore_input_mut_borrow (a : U32) (i : U32) : Result U32 := do
  let a1 ← a + 1#u32
  incr_ignore_input_mut_borrow_loop i
  ok a1

/- [loops::ignore_input_shared_borrow]: loop 0:
   Source: 'tests/src/loops.rs', lines 372:4-374:5 -/
def ignore_input_shared_borrow_loop (i : U32) : Result Unit := do
  if i > 0#u32
  then let i1 ← i - 1#u32
       ignore_input_shared_borrow_loop i1
  else ok ()
partial_fixpoint

/- [loops::ignore_input_shared_borrow]:
   Source: 'tests/src/loops.rs', lines 371:0-375:1 -/
def ignore_input_shared_borrow (_a : U32) (i : U32) : Result U32 := do
  ignore_input_shared_borrow_loop i
  ok _a

/- [loops::issue500_1::bar]:
   Source: 'tests/src/loops.rs', lines 379:4-379:28 -/
def issue500_1.bar (_a : Bool) : Result Bool := do
  ok _a

/- [loops::issue500_1]: loop 0:
   Source: 'tests/src/loops.rs', lines 382:4-384:5 -/
def issue500_1_loop (a : Bool) : Result Bool := do
  if 0#i32 < 0#i32
  then let a1 ← issue500_1.bar a
       issue500_1_loop a1
  else ok a
partial_fixpoint

/- [loops::issue500_1]:
   Source: 'tests/src/loops.rs', lines 378:0-386:1 -/
@[reducible] def issue500_1 (s : Bool) : Result Bool := do
               issue500_1_loop s

/- [loops::issue500_2::A]
   Source: 'tests/src/loops.rs', lines 390:4-390:24 -/
@[reducible]
def issue500_2.A := Array Bool 1#usize

/- [loops::issue500_2::bar]:
   Source: 'tests/src/loops.rs', lines 391:4-391:33 -/
def issue500_2.bar
  (_a : Array Bool 1#usize) : Result (Array Bool 1#usize) := do
  ok _a

/- [loops::issue500_2]: loop 0:
   Source: 'tests/src/loops.rs', lines 394:4-396:5 -/
def issue500_2_loop : Result Unit := do
  ok ()

/- [loops::issue500_2]:
   Source: 'tests/src/loops.rs', lines 389:0-398:1 -/
def issue500_2 (s : Array Bool 1#usize) : Result (Array Bool 1#usize) := do
  issue500_2_loop
  ok s

/- [loops::issue500_3::A]
   Source: 'tests/src/loops.rs', lines 402:4-402:24 -/
@[reducible]
def issue500_3.A := Array Bool 1#usize

/- [loops::issue500_3]: loop 0:
   Source: 'tests/src/loops.rs', lines 404:4-404:18 -/
def issue500_3_loop : Result Unit := do
  if 0#i32 < 0#i32
  then issue500_3_loop
  else ok ()
partial_fixpoint

/- [loops::issue500_3]:
   Source: 'tests/src/loops.rs', lines 401:0-406:1 -/
def issue500_3 (s : Array Bool 1#usize) : Result (Array Bool 1#usize) := do
  issue500_3_loop
  ok s

/- [loops::issue351]: loop 0:
   Source: 'tests/src/loops.rs', lines 411:4-414:5 -/
def issue351_loop (t : List U8) (last : U8) : Result U8 := do
  match t with
  | List.Cons ht tt => issue351_loop tt ht
  | List.Nil => ok last
partial_fixpoint

/- [loops::issue351]:
   Source: 'tests/src/loops.rs', lines 409:0-416:1 -/
@[reducible]
def issue351 (h : U8) (t : List U8) : Result U8 := do
  issue351_loop t h

/- [loops::issue270::box_get_borrow]:
   Source: 'tests/src/loops.rs', lines 420:4-422:5 -/
def issue270.box_get_borrow {T : Type} (x : T) : Result T := do
  ok x

/- [loops::issue270]: loop 0:
   Source: 'tests/src/loops.rs', lines 426:8-429:9 -/
def issue270_loop
  (t : List (List U8)) (last : List U8) : Result (List U8) := do
  match t with
  | List.Cons ht tt =>
    let t1 ← issue270.box_get_borrow tt
    issue270_loop t1 ht
  | List.Nil => ok last
partial_fixpoint

/- [loops::issue270]:
   Source: 'tests/src/loops.rs', lines 419:0-434:1 -/
def issue270 (v : List (List U8)) : Result (Option (List U8)) := do
  match v with
  | List.Cons h t =>
    let t1 ← issue270.box_get_borrow t
    let last ← issue270_loop t1 h
    ok (some last)
  | List.Nil => ok none

/- [loops::issue400_1]: loop 0:
   Source: 'tests/src/loops.rs', lines 440:4-447:5 -/
def issue400_1_loop
  (back : I32 → (I32 × I32)) (cond : Bool) (y : I32) (i : I32) :
  Result (I32 × I32)
  := do
  if i < 32#i32
  then
    let (y1, back1) ←
      if cond
      then let (a, b) := back y
           ok (a, fun i1 => (i1, b))
      else let (a, b) := back y
           ok (b, fun i1 => (a, i1))
    let i1 ← i + 1#i32
    issue400_1_loop back1 cond y1 i1
  else ok (back y)
partial_fixpoint

/- [loops::issue400_1]:
   Source: 'tests/src/loops.rs', lines 437:0-448:1 -/
@[reducible]
def issue400_1 (a : I32) (b : I32) (cond : Bool) : Result (I32 × I32) := do
  issue400_1_loop (fun i => (i, b)) cond a 0#i32

/- [loops::issue400_2]: loop 0:
   Source: 'tests/src/loops.rs', lines 455:4-464:5 -/
def issue400_2_loop
  (back : I32 → I32 → (I32 × I32 × I32)) (conds : Slice Bool) (y : I32)
  (z : I32) (i : Usize) :
  Result (I32 × I32 × (I32 → I32 → (I32 × I32 × I32)))
  := do
  let i1 := Slice.len conds
  if i < i1
  then
    let b ← Slice.index_usize conds i
    let (y1, z1, back1) ←
      if b
      then let (a, b1, c) := back y z
           ok (a, b1, fun i2 i3 => (i2, i3, c))
      else let (a, b1, c) := back y z
           ok (b1, c, fun i2 i3 => (a, i2, i3))
    let i2 ← i + 1#usize
    issue400_2_loop back1 conds y1 z1 i2
  else ok (y, z, back)
partial_fixpoint

/- [loops::issue400_2]:
   Source: 'tests/src/loops.rs', lines 451:0-467:1 -/
def issue400_2
  (a : I32) (b : I32) (c : I32) (conds : Slice Bool) :
  Result (I32 × I32 × I32)
  := do
  let (y, z, back) ←
    issue400_2_loop (fun i i1 => (i, i1, c)) conds a b 0#usize
  let y1 ← y + 3#i32
  let z1 ← z + 5#i32
  ok (back y1 z1)

/- [loops::copy_carray::CARRAY]
   Source: 'tests/src/loops.rs', lines 471:4-471:36 -/
@[global_simps]
def copy_carray.CARRAY_body : Result (Array U32 2#usize) := do
  ok (Array.make 2#usize [ 0#u32, 1#u32 ])
@[global_simps, irreducible]
def copy_carray.CARRAY : Array U32 2#usize :=
  eval_global copy_carray.CARRAY_body

/- [loops::copy_carray]: loop 0:
   Source: 'tests/src/loops.rs', lines 473:4-476:5 -/
def copy_carray_loop
  (a : Array U32 2#usize) (i : Usize) : Result (Array U32 2#usize) := do
  if i < 2#usize
  then
    let i1 ← Array.index_usize copy_carray.CARRAY i
    let a1 ← Array.update a i i1
    let i2 ← i + 1#usize
    copy_carray_loop a1 i2
  else ok a
partial_fixpoint

/- [loops::copy_carray]:
   Source: 'tests/src/loops.rs', lines 470:0-477:1 -/
@[reducible]
def copy_carray (a : Array U32 2#usize) : Result (Array U32 2#usize) := do
  copy_carray_loop a 0#usize

/- [loops::iter_local_mut_borrow]: loop 0:
   Source: 'tests/src/loops.rs', lines 483:4-490:5 -/
def iter_local_mut_borrow_loop (p : I32) : Result Unit := do
  let p1 ← p + 1#i32
  if p1 = 10#i32
  then ok ()
  else iter_local_mut_borrow_loop p1
partial_fixpoint

/- [loops::iter_local_mut_borrow]:
   Source: 'tests/src/loops.rs', lines 480:0-491:1 -/
@[reducible]
def iter_local_mut_borrow : Result Unit := do
  iter_local_mut_borrow_loop 0#i32

/- [loops::iter_local_shared_borrow]: loop 0:
   Source: 'tests/src/loops.rs', lines 497:4-503:5 -/
def iter_local_shared_borrow_loop : Result Unit := do
  if 0#i32 = 0#i32
  then ok ()
  else iter_local_shared_borrow_loop
partial_fixpoint

/- [loops::iter_local_shared_borrow]:
   Source: 'tests/src/loops.rs', lines 494:0-504:1 -/
@[reducible]
def iter_local_shared_borrow : Result Unit := do
  iter_local_shared_borrow_loop

/- [loops::AList]
   Source: 'tests/src/loops.rs', lines 506:0-509:1 -/
inductive AList (T : Type) where
| Cons : Usize → T → AList T → AList T
| Nil : AList T

/- [loops::insert_in_list]: loop 0:
   Source: 'tests/src/loops.rs', lines 1:0-528:5 -/
def insert_in_list_loop
  {T : Type} (key : Usize) (value : T) (ls : AList T) :
  Result (Bool × (AList T))
  := do
  match ls with
  | AList.Cons ckey cvalue tl =>
    if ckey = key
    then ok (false, AList.Cons ckey value tl)
    else
      let (b, back) ← insert_in_list_loop key value tl
      let back1 := AList.Cons ckey cvalue back
      ok (b, back1)
  | AList.Nil => ok (true, AList.Cons key value AList.Nil)
partial_fixpoint

/- [loops::insert_in_list]:
   Source: 'tests/src/loops.rs', lines 512:0-529:1 -/
@[reducible]
def insert_in_list
  {T : Type} (key : Usize) (value : T) (ls : AList T) :
  Result (Bool × (AList T))
  := do
  insert_in_list_loop key value ls

/- [loops::reborrow_const::reborrow]:
   Source: 'tests/src/loops.rs', lines 534:4-538:5 -/
def reborrow_const.reborrow (x : U64) : Result U64 := do
  ok x

/- [loops::reborrow_const]: loop 0:
   Source: 'tests/src/loops.rs', lines 0:0-542:5 -/
def reborrow_const_loop : Result Unit := do
  if 0#i32 < 5#i32
  then let _ ← reborrow_const.reborrow 0#u64
       reborrow_const_loop
  else ok ()
partial_fixpoint

/- [loops::reborrow_const]:
   Source: 'tests/src/loops.rs', lines 533:0-543:1 -/
@[reducible] def reborrow_const : Result Unit := do
               reborrow_const_loop

end loops
