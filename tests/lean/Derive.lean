-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [derive]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace derive

/- [derive::Enum]
   Source: 'tests/src/derive.rs', lines 5:0-11:1 -/
inductive Enum (T : Type) where
| Variant0 : Enum T
| Variant1 : Bool → Enum T
| Variant2 : U32 → Enum T
| Variant3 : T → Enum T
| Variant4 : alloc.vec.Vec T → Enum T

/- [derive::{core::clone::Clone for derive::Enum<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 4:9-4:14 -/
def ClonederiveEnum.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : Enum T) :
  Result (Enum T)
  := do
  match self with
  | Enum.Variant0 => ok Enum.Variant0
  | Enum.Variant1 __self_0 =>
    let b ← (↑(core.clone.impls.CloneBool.clone __self_0) : Result Bool)
    ok (Enum.Variant1 b)
  | Enum.Variant2 __self_0 =>
    let i ← (↑(core.clone.impls.CloneU32.clone __self_0) : Result U32)
    ok (Enum.Variant2 i)
  | Enum.Variant3 __self_0 =>
    let t ← corecloneCloneInst.clone __self_0
    ok (Enum.Variant3 t)
  | Enum.Variant4 __self_0 =>
    let v ← alloc.vec.CloneVec.clone corecloneCloneInst __self_0
    ok (Enum.Variant4 v)

/- Trait implementation: [derive::{core::clone::Clone for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 4:9-4:14 -/
@[reducible]
def core.clone.ClonederiveEnum {T : Type} (corecloneCloneInst :
  core.clone.Clone T) : core.clone.Clone (Enum T) := {
  clone := ClonederiveEnum.clone corecloneCloneInst
}

/- [derive::List]
   Source: 'tests/src/derive.rs', lines 14:0-18:1 -/
inductive List (T : Type) where
| Nil : List T
| Cons : T → List T → List T

/- [derive::{core::clone::Clone for derive::List<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 13:9-13:14 -/
def ClonederiveList.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : List T) :
  Result (List T)
  := do
  match self with
  | List.Nil => ok List.Nil
  | List.Cons __self_0 __self_1 =>
    let t ← corecloneCloneInst.clone __self_0
    let l ← ClonederiveList.clone corecloneCloneInst __self_1
    ok (List.Cons t l)
partial_fixpoint

/- Trait implementation: [derive::{core::clone::Clone for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 13:9-13:14 -/
@[reducible]
def core.clone.ClonederiveList {T : Type} (corecloneCloneInst :
  core.clone.Clone T) : core.clone.Clone (List T) := {
  clone := ClonederiveList.clone corecloneCloneInst
}

/- [derive::Struct]
   Source: 'tests/src/derive.rs', lines 21:0-27:1 -/
structure Struct (T : Type) where
  f0 : Unit
  f1 : Bool
  f2 : U32
  f3 : T
  f4 : alloc.vec.Vec T

/- [derive::{core::clone::Clone for derive::Struct<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 20:9-20:14 -/
def ClonederiveStruct.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : Struct T) :
  Result (Struct T)
  := do
  (BuiltinClone Unit).clone ()
  let b ← (↑(core.clone.impls.CloneBool.clone self.f1) : Result Bool)
  let i ← (↑(core.clone.impls.CloneU32.clone self.f2) : Result U32)
  let t ← corecloneCloneInst.clone self.f3
  let v ← alloc.vec.CloneVec.clone corecloneCloneInst self.f4
  ok { f0 := (), f1 := b, f2 := i, f3 := t, f4 := v }

/- Trait implementation: [derive::{core::clone::Clone for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 20:9-20:14 -/
@[reducible]
def core.clone.ClonederiveStruct {T : Type} (corecloneCloneInst :
  core.clone.Clone T) : core.clone.Clone (Struct T) := {
  clone := ClonederiveStruct.clone corecloneCloneInst
}

end derive
