-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [derive]
import Aeneas
open Aeneas Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace derive

/- [derive::CopyEnumOneVariant]
   Source: 'tests/src/derive.rs', lines 4:0-6:1 -/
@[discriminant]
inductive CopyEnumOneVariant where
| Variant : Bool → CopyEnumOneVariant

/- [derive::{core::clone::Clone for derive::CopyEnumOneVariant}::clone]:
   Source: 'tests/src/derive.rs', lines 3:9-3:14 -/
def CloneCopyEnumOneVariant.clone
  (self : CopyEnumOneVariant) : Result CopyEnumOneVariant := do
  ok self

/- Trait implementation: [derive::{core::clone::Clone for derive::CopyEnumOneVariant}]
   Source: 'tests/src/derive.rs', lines 3:9-3:14 -/
@[reducible]
def core.clone.CloneCopyEnumOneVariant : core.clone.Clone CopyEnumOneVariant
  := {
  clone := CloneCopyEnumOneVariant.clone
}

/- Trait implementation: [derive::{core::marker::Copy for derive::CopyEnumOneVariant}]
   Source: 'tests/src/derive.rs', lines 3:16-3:20 -/
@[reducible]
def core.marker.CopyCopyEnumOneVariant : core.marker.Copy CopyEnumOneVariant
  := {
  cloneInst := core.clone.CloneCopyEnumOneVariant
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::CopyEnumOneVariant}]
   Source: 'tests/src/derive.rs', lines 3:22-3:31 -/
@[reducible]
def core.marker.StructuralPartialEqCopyEnumOneVariant :
  core.marker.StructuralPartialEq CopyEnumOneVariant := {
}

/- [derive::{core::cmp::PartialEq<derive::CopyEnumOneVariant> for derive::CopyEnumOneVariant}::eq]:
   Source: 'tests/src/derive.rs', lines 3:22-3:31 -/
def PartialEqCopyEnumOneVariantCopyEnumOneVariant.eq
  (self : CopyEnumOneVariant) (other : CopyEnumOneVariant) : Result Bool := do
  let ⟨ __self_0 ⟩ := self
  let ⟨ __arg1_0 ⟩ := other
  core.cmp.impls.PartialEqBool.eq __self_0 __arg1_0

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::CopyEnumOneVariant> for derive::CopyEnumOneVariant}]
   Source: 'tests/src/derive.rs', lines 3:22-3:31 -/
@[reducible]
def core.cmp.PartialEqCopyEnumOneVariantCopyEnumOneVariant : core.cmp.PartialEq
  CopyEnumOneVariant CopyEnumOneVariant := {
  eq := PartialEqCopyEnumOneVariantCopyEnumOneVariant.eq
}

/- [derive::{core::cmp::Eq for derive::CopyEnumOneVariant}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 3:33-3:35 -/
def EqCopyEnumOneVariant.assert_receiver_is_total_eq
  (self : CopyEnumOneVariant) : Result Unit := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::CopyEnumOneVariant}]
   Source: 'tests/src/derive.rs', lines 3:33-3:35 -/
@[reducible]
def core.cmp.EqCopyEnumOneVariant : core.cmp.Eq CopyEnumOneVariant := {
  partialEqInst := core.cmp.PartialEqCopyEnumOneVariantCopyEnumOneVariant
  assert_receiver_is_total_eq :=
    EqCopyEnumOneVariant.assert_receiver_is_total_eq
}

/- [derive::{core::fmt::Debug for derive::CopyEnumOneVariant}::fmt]:
   Source: 'tests/src/derive.rs', lines 3:37-3:42 -/
def DebugCopyEnumOneVariant.fmt
  (self : CopyEnumOneVariant) (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  let ⟨ __self_0 ⟩ := self
  let __self_01 := Dyn.mk _ (core.fmt.DebugShared core.fmt.DebugBool) __self_0
  core.fmt.Formatter.debug_tuple_field1_finish f "Variant" __self_01

/- Trait implementation: [derive::{core::fmt::Debug for derive::CopyEnumOneVariant}]
   Source: 'tests/src/derive.rs', lines 3:37-3:42 -/
@[reducible]
def core.fmt.DebugCopyEnumOneVariant : core.fmt.Debug CopyEnumOneVariant := {
  fmt := DebugCopyEnumOneVariant.fmt
}

/- [derive::ScalarEnum]
   Source: 'tests/src/derive.rs', lines 9:0-14:1 -/
@[discriminant [2,4,8,16]]
inductive ScalarEnum where
| Variant0 : ScalarEnum
| Variant1 : ScalarEnum
| Variant2 : ScalarEnum
| Variant3 : ScalarEnum

/- [derive::{core::clone::Clone for derive::ScalarEnum}::clone]:
   Source: 'tests/src/derive.rs', lines 8:9-8:14 -/
def CloneScalarEnum.clone (self : ScalarEnum) : Result ScalarEnum := do
  ok self

/- Trait implementation: [derive::{core::clone::Clone for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 8:9-8:14 -/
@[reducible]
def core.clone.CloneScalarEnum : core.clone.Clone ScalarEnum := {
  clone := CloneScalarEnum.clone
}

/- Trait implementation: [derive::{core::marker::Copy for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 8:16-8:20 -/
@[reducible]
def core.marker.CopyScalarEnum : core.marker.Copy ScalarEnum := {
  cloneInst := core.clone.CloneScalarEnum
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 8:22-8:31 -/
@[reducible]
def core.marker.StructuralPartialEqScalarEnum : core.marker.StructuralPartialEq
  ScalarEnum := {
}

/- [derive::{core::cmp::PartialEq<derive::ScalarEnum> for derive::ScalarEnum}::eq]:
   Source: 'tests/src/derive.rs', lines 8:22-8:31 -/
def PartialEqScalarEnumScalarEnum.eq
  (self : ScalarEnum) (other : ScalarEnum) : Result Bool := do
  let self1 := read_discriminant self
  let other1 := read_discriminant other
  ok (self1 = other1)

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::ScalarEnum> for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 8:22-8:31 -/
@[reducible]
def core.cmp.PartialEqScalarEnumScalarEnum : core.cmp.PartialEq ScalarEnum
  ScalarEnum := {
  eq := PartialEqScalarEnumScalarEnum.eq
}

/- [derive::{core::cmp::Eq for derive::ScalarEnum}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 8:33-8:35 -/
def EqScalarEnum.assert_receiver_is_total_eq
  (self : ScalarEnum) : Result Unit := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 8:33-8:35 -/
@[reducible]
def core.cmp.EqScalarEnum : core.cmp.Eq ScalarEnum := {
  partialEqInst := core.cmp.PartialEqScalarEnumScalarEnum
  assert_receiver_is_total_eq := EqScalarEnum.assert_receiver_is_total_eq
}

/- [derive::{core::fmt::Debug for derive::ScalarEnum}::fmt]:
   Source: 'tests/src/derive.rs', lines 8:37-8:42 -/
def DebugScalarEnum.fmt
  (self : ScalarEnum) (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  match self with
  | ScalarEnum.Variant0 => core.fmt.Formatter.write_str f "Variant0"
  | ScalarEnum.Variant1 => core.fmt.Formatter.write_str f "Variant1"
  | ScalarEnum.Variant2 => core.fmt.Formatter.write_str f "Variant2"
  | ScalarEnum.Variant3 => core.fmt.Formatter.write_str f "Variant3"

/- Trait implementation: [derive::{core::fmt::Debug for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 8:37-8:42 -/
@[reducible]
def core.fmt.DebugScalarEnum : core.fmt.Debug ScalarEnum := {
  fmt := DebugScalarEnum.fmt
}

/- [derive::CopyEnum]
   Source: 'tests/src/derive.rs', lines 17:0-22:1 -/
@[discriminant]
inductive CopyEnum (T : Type) where
| Variant0 : CopyEnum T
| Variant1 : Bool → CopyEnum T
| Variant2 : Std.U32 → CopyEnum T
| Variant3 : T → CopyEnum T

/- [derive::{core::clone::Clone for derive::CopyEnum<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 16:9-16:14 -/
def CloneCopyEnum.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : CopyEnum T) :
  Result (CopyEnum T)
  := do
  match self with
  | CopyEnum.Variant0 => ok CopyEnum.Variant0
  | CopyEnum.Variant1 __self_0 =>
    let b ← (↑(core.clone.impls.CloneBool.clone __self_0) : Result Bool)
    ok (CopyEnum.Variant1 b)
  | CopyEnum.Variant2 __self_0 =>
    let i ← (↑(core.clone.impls.CloneU32.clone __self_0) : Result Std.U32)
    ok (CopyEnum.Variant2 i)
  | CopyEnum.Variant3 __self_0 =>
    let t ← corecloneCloneInst.clone __self_0
    ok (CopyEnum.Variant3 t)

/- Trait implementation: [derive::{core::clone::Clone for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 16:9-16:14 -/
@[reducible]
def core.clone.CloneCopyEnum {T : Type} (corecloneCloneInst : core.clone.Clone
  T) : core.clone.Clone (CopyEnum T) := {
  clone := CloneCopyEnum.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::Copy for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 16:16-16:20 -/
@[reducible]
def core.marker.CopyCopyEnum {T : Type} (coremarkerCopyInst : core.marker.Copy
  T) : core.marker.Copy (CopyEnum T) := {
  cloneInst := core.clone.CloneCopyEnum coremarkerCopyInst.cloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 16:22-16:31 -/
@[reducible]
def core.marker.StructuralPartialEqCopyEnum (T : Type) :
  core.marker.StructuralPartialEq (CopyEnum T) := {
}

/- [derive::{core::cmp::PartialEq<derive::CopyEnum<T>> for derive::CopyEnum<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 16:22-16:31 -/
def PartialEqCopyEnumCopyEnum.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T)
  (self : CopyEnum T) (other : CopyEnum T) :
  Result Bool
  := do
  let self1 := read_discriminant self
  let other1 := read_discriminant other
  if self1 = other1
  then
    match self with
    | CopyEnum.Variant0 => ok true
    | CopyEnum.Variant1 __self_0 =>
      match other with
      | CopyEnum.Variant0 => ok true
      | CopyEnum.Variant1 __arg1_0 =>
        core.cmp.impls.PartialEqBool.eq __self_0 __arg1_0
      | CopyEnum.Variant2 _ => ok true
      | CopyEnum.Variant3 _ => ok true
    | CopyEnum.Variant2 __self_0 =>
      match other with
      | CopyEnum.Variant0 => ok true
      | CopyEnum.Variant1 _ => ok true
      | CopyEnum.Variant2 __arg1_0 =>
        core.cmp.impls.PartialEqU32.eq __self_0 __arg1_0
      | CopyEnum.Variant3 _ => ok true
    | CopyEnum.Variant3 __self_0 =>
      match other with
      | CopyEnum.Variant0 => ok true
      | CopyEnum.Variant1 _ => ok true
      | CopyEnum.Variant2 _ => ok true
      | CopyEnum.Variant3 __arg1_0 =>
        core.cmp.impls.PartialEqShared.eq corecmpPartialEqInst __self_0
          __arg1_0
  else ok false

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::CopyEnum<T>> for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 16:22-16:31 -/
@[reducible]
def core.cmp.PartialEqCopyEnumCopyEnum {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (CopyEnum T) (CopyEnum T) := {
  eq := PartialEqCopyEnumCopyEnum.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::CopyEnum<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 16:33-16:35 -/
def EqCopyEnum.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : CopyEnum T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 16:33-16:35 -/
@[reducible]
def core.cmp.EqCopyEnum {T : Type} (corecmpEqInst : core.cmp.Eq T) :
  core.cmp.Eq (CopyEnum T) := {
  partialEqInst := core.cmp.PartialEqCopyEnumCopyEnum
    corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq := EqCopyEnum.assert_receiver_is_total_eq
    corecmpEqInst
}

/- [derive::{core::fmt::Debug for derive::CopyEnum<T>}::fmt]:
   Source: 'tests/src/derive.rs', lines 16:37-16:42 -/
def DebugCopyEnum.fmt
  {T : Type} (corefmtDebugInst : core.fmt.Debug T) (self : CopyEnum T)
  (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  match self with
  | CopyEnum.Variant0 => core.fmt.Formatter.write_str f "Variant0"
  | CopyEnum.Variant1 __self_0 =>
    let __self_01 :=
      Dyn.mk _ (core.fmt.DebugShared core.fmt.DebugBool) __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f "Variant1" __self_01
  | CopyEnum.Variant2 __self_0 =>
    let __self_01 := Dyn.mk _ (core.fmt.DebugShared core.fmt.DebugU32) __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f "Variant2" __self_01
  | CopyEnum.Variant3 __self_0 =>
    let __self_01 := Dyn.mk _ (core.fmt.DebugShared corefmtDebugInst) __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f "Variant3" __self_01

/- Trait implementation: [derive::{core::fmt::Debug for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 16:37-16:42 -/
@[reducible]
def core.fmt.DebugCopyEnum {T : Type} (corefmtDebugInst : core.fmt.Debug T) :
  core.fmt.Debug (CopyEnum T) := {
  fmt := DebugCopyEnum.fmt corefmtDebugInst
}

/- [derive::Enum]
   Source: 'tests/src/derive.rs', lines 25:0-31:1 -/
@[discriminant]
inductive Enum (T : Type) where
| Variant0 : Enum T
| Variant1 : Bool → Enum T
| Variant2 : Std.U32 → Enum T
| Variant3 : T → Enum T
| Variant4 : alloc.vec.Vec T → Enum T

/- [derive::{core::clone::Clone for derive::Enum<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 24:9-24:14 -/
def CloneEnum.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : Enum T) :
  Result (Enum T)
  := do
  match self with
  | Enum.Variant0 => ok Enum.Variant0
  | Enum.Variant1 __self_0 =>
    let b ← (↑(core.clone.impls.CloneBool.clone __self_0) : Result Bool)
    ok (Enum.Variant1 b)
  | Enum.Variant2 __self_0 =>
    let i ← (↑(core.clone.impls.CloneU32.clone __self_0) : Result Std.U32)
    ok (Enum.Variant2 i)
  | Enum.Variant3 __self_0 =>
    let t ← corecloneCloneInst.clone __self_0
    ok (Enum.Variant3 t)
  | Enum.Variant4 __self_0 =>
    let v ← alloc.vec.CloneVec.clone corecloneCloneInst __self_0
    ok (Enum.Variant4 v)

/- Trait implementation: [derive::{core::clone::Clone for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 24:9-24:14 -/
@[reducible]
def core.clone.CloneEnum {T : Type} (corecloneCloneInst : core.clone.Clone T) :
  core.clone.Clone (Enum T) := {
  clone := CloneEnum.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 24:16-24:25 -/
@[reducible]
def core.marker.StructuralPartialEqEnum (T : Type) :
  core.marker.StructuralPartialEq (Enum T) := {
}

/- [derive::{core::cmp::PartialEq<derive::Enum<T>> for derive::Enum<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 24:16-24:25 -/
def PartialEqEnumEnum.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T) (self : Enum T)
  (other : Enum T) :
  Result Bool
  := do
  let self1 := read_discriminant self
  let other1 := read_discriminant other
  if self1 = other1
  then
    match self with
    | Enum.Variant0 => ok true
    | Enum.Variant1 __self_0 =>
      match other with
      | Enum.Variant0 => ok true
      | Enum.Variant1 __arg1_0 =>
        core.cmp.impls.PartialEqBool.eq __self_0 __arg1_0
      | Enum.Variant2 _ => ok true
      | Enum.Variant3 _ => ok true
      | Enum.Variant4 _ => ok true
    | Enum.Variant2 __self_0 =>
      match other with
      | Enum.Variant0 => ok true
      | Enum.Variant1 _ => ok true
      | Enum.Variant2 __arg1_0 =>
        core.cmp.impls.PartialEqU32.eq __self_0 __arg1_0
      | Enum.Variant3 _ => ok true
      | Enum.Variant4 _ => ok true
    | Enum.Variant3 __self_0 =>
      match other with
      | Enum.Variant0 => ok true
      | Enum.Variant1 _ => ok true
      | Enum.Variant2 _ => ok true
      | Enum.Variant3 __arg1_0 =>
        core.cmp.impls.PartialEqShared.eq corecmpPartialEqInst __self_0
          __arg1_0
      | Enum.Variant4 _ => ok true
    | Enum.Variant4 __self_0 =>
      match other with
      | Enum.Variant0 => ok true
      | Enum.Variant1 _ => ok true
      | Enum.Variant2 _ => ok true
      | Enum.Variant3 _ => ok true
      | Enum.Variant4 __arg1_0 =>
        alloc.vec.partial_eq.PartialEqVec.eq corecmpPartialEqInst __self_0
          __arg1_0
  else ok false

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::Enum<T>> for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 24:16-24:25 -/
@[reducible]
def core.cmp.PartialEqEnumEnum {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (Enum T) (Enum T) := {
  eq := PartialEqEnumEnum.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::Enum<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 24:27-24:29 -/
def EqEnum.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : Enum T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 24:27-24:29 -/
@[reducible]
def core.cmp.EqEnum {T : Type} (corecmpEqInst : core.cmp.Eq T) : core.cmp.Eq
  (Enum T) := {
  partialEqInst := core.cmp.PartialEqEnumEnum corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq := EqEnum.assert_receiver_is_total_eq
    corecmpEqInst
}

/- [derive::{core::fmt::Debug for derive::Enum<T>}::fmt]:
   Source: 'tests/src/derive.rs', lines 24:31-24:36 -/
def DebugEnum.fmt
  {T : Type} (corefmtDebugInst : core.fmt.Debug T) (self : Enum T)
  (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  match self with
  | Enum.Variant0 => core.fmt.Formatter.write_str f "Variant0"
  | Enum.Variant1 __self_0 =>
    let __self_01 :=
      Dyn.mk _ (core.fmt.DebugShared core.fmt.DebugBool) __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f "Variant1" __self_01
  | Enum.Variant2 __self_0 =>
    let __self_01 := Dyn.mk _ (core.fmt.DebugShared core.fmt.DebugU32) __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f "Variant2" __self_01
  | Enum.Variant3 __self_0 =>
    let __self_01 := Dyn.mk _ (core.fmt.DebugShared corefmtDebugInst) __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f "Variant3" __self_01
  | Enum.Variant4 __self_0 =>
    let __self_01 :=
      Dyn.mk _ (core.fmt.DebugShared (core.fmt.DebugVec corefmtDebugInst))
        __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f "Variant4" __self_01

/- Trait implementation: [derive::{core::fmt::Debug for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 24:31-24:36 -/
@[reducible]
def core.fmt.DebugEnum {T : Type} (corefmtDebugInst : core.fmt.Debug T) :
  core.fmt.Debug (Enum T) := {
  fmt := DebugEnum.fmt corefmtDebugInst
}

/- [derive::List]
   Source: 'tests/src/derive.rs', lines 35:0-39:1 -/
@[discriminant]
inductive List (T : Type) where
| Nil : List T
| Cons : T → List T → List T

/- [derive::{core::clone::Clone for derive::List<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 34:9-34:14 -/
def CloneList.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : List T) :
  Result (List T)
  := do
  match self with
  | List.Nil => ok List.Nil
  | List.Cons __self_0 __self_1 =>
    let t ← corecloneCloneInst.clone __self_0
    let l ← CloneList.clone corecloneCloneInst __self_1
    ok (List.Cons t l)
partial_fixpoint

/- Trait implementation: [derive::{core::clone::Clone for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 34:9-34:14 -/
@[reducible]
def core.clone.CloneList {T : Type} (corecloneCloneInst : core.clone.Clone T) :
  core.clone.Clone (List T) := {
  clone := CloneList.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 34:16-34:25 -/
@[reducible]
def core.marker.StructuralPartialEqList (T : Type) :
  core.marker.StructuralPartialEq (List T) := {
}

/- [derive::{core::cmp::PartialEq<derive::List<T>> for derive::List<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 34:16-34:25 -/
def PartialEqListList.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T) (self : List T)
  (other : List T) :
  Result Bool
  := do
  let self1 := read_discriminant self
  let other1 := read_discriminant other
  if self1 = other1
  then
    match self with
    | List.Nil => ok true
    | List.Cons __self_0 __self_1 =>
      match other with
      | List.Nil => ok true
      | List.Cons __arg1_0 __arg1_1 =>
        let b ←
          core.cmp.impls.PartialEqShared.eq corecmpPartialEqInst __self_0
            __arg1_0
        if b
        then PartialEqListList.eq corecmpPartialEqInst __self_1 __arg1_1
        else ok false
  else ok false
partial_fixpoint

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::List<T>> for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 34:16-34:25 -/
@[reducible]
def core.cmp.PartialEqListList {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (List T) (List T) := {
  eq := PartialEqListList.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::List<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 34:27-34:29 -/
def EqList.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : List T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 34:27-34:29 -/
@[reducible]
def core.cmp.EqList {T : Type} (corecmpEqInst : core.cmp.Eq T) : core.cmp.Eq
  (List T) := {
  partialEqInst := core.cmp.PartialEqListList corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq := EqList.assert_receiver_is_total_eq
    corecmpEqInst
}

/- [derive::CopyStruct]
   Source: 'tests/src/derive.rs', lines 42:0-47:1 -/
structure CopyStruct (T : Type) where
  f0 : Unit
  f1 : Bool
  f2 : Std.U32
  f3 : T

/- [derive::{core::clone::Clone for derive::CopyStruct<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 41:9-41:14 -/
def CloneCopyStruct.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : CopyStruct T) :
  Result (CopyStruct T)
  := do
  (BuiltinClone Unit).clone ()
  let b ← (↑(core.clone.impls.CloneBool.clone self.f1) : Result Bool)
  let i ← (↑(core.clone.impls.CloneU32.clone self.f2) : Result Std.U32)
  let t ← corecloneCloneInst.clone self.f3
  ok { f0 := (), f1 := b, f2 := i, f3 := t }

/- Trait implementation: [derive::{core::clone::Clone for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 41:9-41:14 -/
@[reducible]
def core.clone.CloneCopyStruct {T : Type} (corecloneCloneInst :
  core.clone.Clone T) : core.clone.Clone (CopyStruct T) := {
  clone := CloneCopyStruct.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::Copy for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 41:16-41:20 -/
@[reducible]
def core.marker.CopyCopyStruct {T : Type} (coremarkerCopyInst :
  core.marker.Copy T) : core.marker.Copy (CopyStruct T) := {
  cloneInst := core.clone.CloneCopyStruct coremarkerCopyInst.cloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 41:22-41:31 -/
@[reducible]
def core.marker.StructuralPartialEqCopyStruct (T : Type) :
  core.marker.StructuralPartialEq (CopyStruct T) := {
}

/- [derive::{core::cmp::PartialEq<derive::CopyStruct<T>> for derive::CopyStruct<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 41:22-41:31 -/
def PartialEqCopyStructCopyStruct.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T)
  (self : CopyStruct T) (other : CopyStruct T) :
  Result Bool
  := do
  let b ← core.cmp.impls.PartialEqUnit.eq () ()
  if b
  then
    if self.f1 = other.f1
    then
      if self.f2 = other.f2
      then corecmpPartialEqInst.eq self.f3 other.f3
      else ok false
    else ok false
  else ok false

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::CopyStruct<T>> for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 41:22-41:31 -/
@[reducible]
def core.cmp.PartialEqCopyStructCopyStruct {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (CopyStruct T) (CopyStruct T)
  := {
  eq := PartialEqCopyStructCopyStruct.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::CopyStruct<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 41:33-41:35 -/
def EqCopyStruct.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : CopyStruct T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 41:33-41:35 -/
@[reducible]
def core.cmp.EqCopyStruct {T : Type} (corecmpEqInst : core.cmp.Eq T) :
  core.cmp.Eq (CopyStruct T) := {
  partialEqInst := core.cmp.PartialEqCopyStructCopyStruct
    corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq := EqCopyStruct.assert_receiver_is_total_eq
    corecmpEqInst
}

/- [derive::{core::fmt::Debug for derive::CopyStruct<T>}::fmt]:
   Source: 'tests/src/derive.rs', lines 41:37-41:42 -/
def DebugCopyStruct.fmt
  {T : Type} (corefmtDebugInst : core.fmt.Debug T) (self : CopyStruct T)
  (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  let dyn := Dyn.mk _ core.fmt.DebugUnit ()
  let dyn1 := Dyn.mk _ core.fmt.DebugBool self.f1
  let dyn2 := Dyn.mk _ core.fmt.DebugU32 self.f2
  let dyn3 := Dyn.mk _ (core.fmt.DebugShared corefmtDebugInst) self.f3
  core.fmt.Formatter.debug_struct_field4_finish f "CopyStruct" "f0" dyn "f1"
    dyn1 "f2" dyn2 "f3" dyn3

/- Trait implementation: [derive::{core::fmt::Debug for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 41:37-41:42 -/
@[reducible]
def core.fmt.DebugCopyStruct {T : Type} (corefmtDebugInst : core.fmt.Debug T) :
  core.fmt.Debug (CopyStruct T) := {
  fmt := DebugCopyStruct.fmt corefmtDebugInst
}

/- [derive::Struct]
   Source: 'tests/src/derive.rs', lines 50:0-52:1 -/
structure Struct (T : Type) where
  f : alloc.vec.Vec T

/- [derive::{core::clone::Clone for derive::Struct<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 49:9-49:14 -/
def CloneStruct.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : Struct T) :
  Result (Struct T)
  := do
  let v ← alloc.vec.CloneVec.clone corecloneCloneInst self.f
  ok { f := v }

/- Trait implementation: [derive::{core::clone::Clone for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 49:9-49:14 -/
@[reducible]
def core.clone.CloneStruct {T : Type} (corecloneCloneInst : core.clone.Clone T)
  : core.clone.Clone (Struct T) := {
  clone := CloneStruct.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 49:16-49:25 -/
@[reducible]
def core.marker.StructuralPartialEqStruct (T : Type) :
  core.marker.StructuralPartialEq (Struct T) := {
}

/- [derive::{core::cmp::PartialEq<derive::Struct<T>> for derive::Struct<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 49:16-49:25 -/
def PartialEqStructStruct.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T) (self : Struct T)
  (other : Struct T) :
  Result Bool
  := do
  alloc.vec.partial_eq.PartialEqVec.eq corecmpPartialEqInst self.f other.f

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::Struct<T>> for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 49:16-49:25 -/
@[reducible]
def core.cmp.PartialEqStructStruct {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (Struct T) (Struct T) := {
  eq := PartialEqStructStruct.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::Struct<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 49:27-49:29 -/
def EqStruct.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : Struct T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 49:27-49:29 -/
@[reducible]
def core.cmp.EqStruct {T : Type} (corecmpEqInst : core.cmp.Eq T) : core.cmp.Eq
  (Struct T) := {
  partialEqInst := core.cmp.PartialEqStructStruct corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq := EqStruct.assert_receiver_is_total_eq
    corecmpEqInst
}

/- [derive::{core::fmt::Debug for derive::Struct<T>}::fmt]:
   Source: 'tests/src/derive.rs', lines 49:31-49:36 -/
def DebugStruct.fmt
  {T : Type} (corefmtDebugInst : core.fmt.Debug T) (self : Struct T)
  (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  let dyn :=
    Dyn.mk _ (core.fmt.DebugShared (core.fmt.DebugVec corefmtDebugInst)) self.f
  core.fmt.Formatter.debug_struct_field1_finish f "Struct" "f" dyn

/- Trait implementation: [derive::{core::fmt::Debug for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 49:31-49:36 -/
@[reducible]
def core.fmt.DebugStruct {T : Type} (corefmtDebugInst : core.fmt.Debug T) :
  core.fmt.Debug (Struct T) := {
  fmt := DebugStruct.fmt corefmtDebugInst
}

end derive
