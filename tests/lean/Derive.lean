-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [derive]
import Aeneas
open Aeneas Aeneas.Std Result ControlFlow Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

/- You can set the `maxHeartbeats` value with the `-max-heartbeats` CLI option -/
set_option maxHeartbeats 1000000

namespace derive

/- [derive::CopyEnumOneVariant]
   Source: 'tests/src/derive.rs', lines 4:0-6:1 -/
@[discriminant isize]
inductive CopyEnumOneVariant where
| Variant : Bool → CopyEnumOneVariant

/- [derive::{core::clone::Clone for derive::CopyEnumOneVariant}::clone]:
   Source: 'tests/src/derive.rs', lines 3:9-3:14 -/
def CopyEnumOneVariant.Insts.CoreCloneClone.clone
  (self : CopyEnumOneVariant) : Result CopyEnumOneVariant := do
  ok self

/- Trait implementation: [derive::{core::clone::Clone for derive::CopyEnumOneVariant}]
   Source: 'tests/src/derive.rs', lines 3:9-3:14 -/
@[reducible]
def CopyEnumOneVariant.Insts.CoreCloneClone : core.clone.Clone
  CopyEnumOneVariant := {
  clone := CopyEnumOneVariant.Insts.CoreCloneClone.clone
}

/- Trait implementation: [derive::{core::marker::Copy for derive::CopyEnumOneVariant}]
   Source: 'tests/src/derive.rs', lines 3:16-3:20 -/
@[reducible]
def CopyEnumOneVariant.Insts.CoreMarkerCopy : core.marker.Copy
  CopyEnumOneVariant := {
  cloneInst := CopyEnumOneVariant.Insts.CoreCloneClone
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::CopyEnumOneVariant}]
   Source: 'tests/src/derive.rs', lines 3:22-3:31 -/
@[reducible]
def CopyEnumOneVariant.Insts.CoreMarkerStructuralPartialEq :
  core.marker.StructuralPartialEq CopyEnumOneVariant := {
}

/- [derive::{core::cmp::PartialEq<derive::CopyEnumOneVariant> for derive::CopyEnumOneVariant}::eq]:
   Source: 'tests/src/derive.rs', lines 3:22-3:31 -/
def CopyEnumOneVariant.Insts.CoreCmpPartialEqCopyEnumOneVariant.eq
  (self : CopyEnumOneVariant) (other : CopyEnumOneVariant) : Result Bool := do
  let ⟨ __self_0 ⟩ := self
  let ⟨ __arg1_0 ⟩ := other
  core.cmp.impls.PartialEqBool.eq __self_0 __arg1_0

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::CopyEnumOneVariant> for derive::CopyEnumOneVariant}]
   Source: 'tests/src/derive.rs', lines 3:22-3:31 -/
@[reducible]
def CopyEnumOneVariant.Insts.CoreCmpPartialEqCopyEnumOneVariant :
  core.cmp.PartialEq CopyEnumOneVariant CopyEnumOneVariant := {
  eq := CopyEnumOneVariant.Insts.CoreCmpPartialEqCopyEnumOneVariant.eq
}

/- [derive::{core::cmp::Eq for derive::CopyEnumOneVariant}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 3:33-3:35 -/
def CopyEnumOneVariant.Insts.CoreCmpEq.assert_receiver_is_total_eq
  (self : CopyEnumOneVariant) : Result Unit := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::CopyEnumOneVariant}]
   Source: 'tests/src/derive.rs', lines 3:33-3:35 -/
@[reducible]
def CopyEnumOneVariant.Insts.CoreCmpEq : core.cmp.Eq CopyEnumOneVariant := {
  partialEqInst := CopyEnumOneVariant.Insts.CoreCmpPartialEqCopyEnumOneVariant
  assert_receiver_is_total_eq :=
    CopyEnumOneVariant.Insts.CoreCmpEq.assert_receiver_is_total_eq
}

/- [derive::{core::fmt::Debug for derive::CopyEnumOneVariant}::fmt]:
   Source: 'tests/src/derive.rs', lines 3:37-3:42 -/
def CopyEnumOneVariant.Insts.CoreFmtDebug.fmt
  (self : CopyEnumOneVariant) (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  let ⟨ __self_0 ⟩ := self
  let __self_01 := Dyn.mk _ (core.fmt.DebugShared core.fmt.DebugBool) __self_0
  core.fmt.Formatter.debug_tuple_field1_finish f (toStr "Variant") __self_01

/- Trait implementation: [derive::{core::fmt::Debug for derive::CopyEnumOneVariant}]
   Source: 'tests/src/derive.rs', lines 3:37-3:42 -/
@[reducible]
def CopyEnumOneVariant.Insts.CoreFmtDebug : core.fmt.Debug CopyEnumOneVariant
  := {
  fmt := CopyEnumOneVariant.Insts.CoreFmtDebug.fmt
}

/- [derive::ScalarEnum]
   Source: 'tests/src/derive.rs', lines 9:0-14:1 -/
@[discriminant isize [2,4,8,16]]
inductive ScalarEnum where
| Variant0 : ScalarEnum
| Variant1 : ScalarEnum
| Variant2 : ScalarEnum
| Variant3 : ScalarEnum

/- [derive::{core::clone::Clone for derive::ScalarEnum}::clone]:
   Source: 'tests/src/derive.rs', lines 8:9-8:14 -/
def ScalarEnum.Insts.CoreCloneClone.clone
  (self : ScalarEnum) : Result ScalarEnum := do
  ok self

/- Trait implementation: [derive::{core::clone::Clone for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 8:9-8:14 -/
@[reducible]
def ScalarEnum.Insts.CoreCloneClone : core.clone.Clone ScalarEnum := {
  clone := ScalarEnum.Insts.CoreCloneClone.clone
}

/- Trait implementation: [derive::{core::marker::Copy for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 8:16-8:20 -/
@[reducible]
def ScalarEnum.Insts.CoreMarkerCopy : core.marker.Copy ScalarEnum := {
  cloneInst := ScalarEnum.Insts.CoreCloneClone
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 8:22-8:31 -/
@[reducible]
def ScalarEnum.Insts.CoreMarkerStructuralPartialEq :
  core.marker.StructuralPartialEq ScalarEnum := {
}

/- [derive::{core::cmp::PartialEq<derive::ScalarEnum> for derive::ScalarEnum}::eq]:
   Source: 'tests/src/derive.rs', lines 8:22-8:31 -/
def ScalarEnum.Insts.CoreCmpPartialEqScalarEnum.eq
  (self : ScalarEnum) (other : ScalarEnum) : Result Bool := do
  let self1 := read_discriminant self
  let other1 := read_discriminant other
  ok (self1 = other1)

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::ScalarEnum> for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 8:22-8:31 -/
@[reducible]
def ScalarEnum.Insts.CoreCmpPartialEqScalarEnum : core.cmp.PartialEq ScalarEnum
  ScalarEnum := {
  eq := ScalarEnum.Insts.CoreCmpPartialEqScalarEnum.eq
}

/- [derive::{core::cmp::Eq for derive::ScalarEnum}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 8:33-8:35 -/
def ScalarEnum.Insts.CoreCmpEq.assert_receiver_is_total_eq
  (self : ScalarEnum) : Result Unit := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 8:33-8:35 -/
@[reducible]
def ScalarEnum.Insts.CoreCmpEq : core.cmp.Eq ScalarEnum := {
  partialEqInst := ScalarEnum.Insts.CoreCmpPartialEqScalarEnum
  assert_receiver_is_total_eq :=
    ScalarEnum.Insts.CoreCmpEq.assert_receiver_is_total_eq
}

/- [derive::{core::fmt::Debug for derive::ScalarEnum}::fmt]:
   Source: 'tests/src/derive.rs', lines 8:37-8:42 -/
def ScalarEnum.Insts.CoreFmtDebug.fmt
  (self : ScalarEnum) (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  match self with
  | ScalarEnum.Variant0 => core.fmt.Formatter.write_str f (toStr "Variant0")
  | ScalarEnum.Variant1 => core.fmt.Formatter.write_str f (toStr "Variant1")
  | ScalarEnum.Variant2 => core.fmt.Formatter.write_str f (toStr "Variant2")
  | ScalarEnum.Variant3 => core.fmt.Formatter.write_str f (toStr "Variant3")

/- Trait implementation: [derive::{core::fmt::Debug for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 8:37-8:42 -/
@[reducible]
def ScalarEnum.Insts.CoreFmtDebug : core.fmt.Debug ScalarEnum := {
  fmt := ScalarEnum.Insts.CoreFmtDebug.fmt
}

/- [derive::CopyEnum]
   Source: 'tests/src/derive.rs', lines 17:0-22:1 -/
@[discriminant isize]
inductive CopyEnum (T : Type) where
| Variant0 : CopyEnum T
| Variant1 : Bool → CopyEnum T
| Variant2 : Std.U32 → CopyEnum T
| Variant3 : T → CopyEnum T

/- [derive::{core::clone::Clone for derive::CopyEnum<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 16:9-16:14 -/
def CopyEnum.Insts.CoreCloneClone.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : CopyEnum T) :
  Result (CopyEnum T)
  := do
  match self with
  | CopyEnum.Variant0 => ok CopyEnum.Variant0
  | CopyEnum.Variant1 __self_0 =>
    let b ← lift (core.clone.impls.CloneBool.clone __self_0)
    ok (CopyEnum.Variant1 b)
  | CopyEnum.Variant2 __self_0 =>
    let i ← lift (core.clone.impls.CloneU32.clone __self_0)
    ok (CopyEnum.Variant2 i)
  | CopyEnum.Variant3 __self_0 =>
    let t ← corecloneCloneInst.clone __self_0
    ok (CopyEnum.Variant3 t)

/- Trait implementation: [derive::{core::clone::Clone for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 16:9-16:14 -/
@[reducible]
def CopyEnum.Insts.CoreCloneClone {T : Type} (corecloneCloneInst :
  core.clone.Clone T) : core.clone.Clone (CopyEnum T) := {
  clone := CopyEnum.Insts.CoreCloneClone.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::Copy for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 16:16-16:20 -/
@[reducible]
def CopyEnum.Insts.CoreMarkerCopy {T : Type} (coremarkerCopyInst :
  core.marker.Copy T) : core.marker.Copy (CopyEnum T) := {
  cloneInst := CopyEnum.Insts.CoreCloneClone coremarkerCopyInst.cloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 16:22-16:31 -/
@[reducible]
def CopyEnum.Insts.CoreMarkerStructuralPartialEq (T : Type) :
  core.marker.StructuralPartialEq (CopyEnum T) := {
}

/- [derive::{core::cmp::PartialEq<derive::CopyEnum<T>> for derive::CopyEnum<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 16:22-16:31 -/
def CopyEnum.Insts.CoreCmpPartialEqCopyEnum.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T)
  (self : CopyEnum T) (other : CopyEnum T) :
  Result Bool
  := do
  let self1 := read_discriminant self
  let other1 := read_discriminant other
  if self1 = other1
  then
    match self with
    | CopyEnum.Variant0 => ok true
    | CopyEnum.Variant1 __self_0 =>
      match other with
      | CopyEnum.Variant0 => ok true
      | CopyEnum.Variant1 __arg1_0 =>
        core.cmp.impls.PartialEqBool.eq __self_0 __arg1_0
      | CopyEnum.Variant2 _ => ok true
      | CopyEnum.Variant3 _ => ok true
    | CopyEnum.Variant2 __self_0 =>
      match other with
      | CopyEnum.Variant0 => ok true
      | CopyEnum.Variant1 _ => ok true
      | CopyEnum.Variant2 __arg1_0 =>
        lift (core.cmp.impls.PartialEqU32.eq __self_0 __arg1_0)
      | CopyEnum.Variant3 _ => ok true
    | CopyEnum.Variant3 __self_0 =>
      match other with
      | CopyEnum.Variant0 => ok true
      | CopyEnum.Variant1 _ => ok true
      | CopyEnum.Variant2 _ => ok true
      | CopyEnum.Variant3 __arg1_0 =>
        core.cmp.impls.PartialEqShared.eq corecmpPartialEqInst __self_0
          __arg1_0
  else ok false

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::CopyEnum<T>> for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 16:22-16:31 -/
@[reducible]
def CopyEnum.Insts.CoreCmpPartialEqCopyEnum {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (CopyEnum T) (CopyEnum T) := {
  eq := CopyEnum.Insts.CoreCmpPartialEqCopyEnum.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::CopyEnum<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 16:33-16:35 -/
def CopyEnum.Insts.CoreCmpEq.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : CopyEnum T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 16:33-16:35 -/
@[reducible]
def CopyEnum.Insts.CoreCmpEq {T : Type} (corecmpEqInst : core.cmp.Eq T) :
  core.cmp.Eq (CopyEnum T) := {
  partialEqInst := CopyEnum.Insts.CoreCmpPartialEqCopyEnum
    corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq :=
    CopyEnum.Insts.CoreCmpEq.assert_receiver_is_total_eq corecmpEqInst
}

/- [derive::{core::fmt::Debug for derive::CopyEnum<T>}::fmt]:
   Source: 'tests/src/derive.rs', lines 16:37-16:42 -/
def CopyEnum.Insts.CoreFmtDebug.fmt
  {T : Type} (corefmtDebugInst : core.fmt.Debug T) (self : CopyEnum T)
  (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  match self with
  | CopyEnum.Variant0 => core.fmt.Formatter.write_str f (toStr "Variant0")
  | CopyEnum.Variant1 __self_0 =>
    let __self_01 :=
      Dyn.mk _ (core.fmt.DebugShared core.fmt.DebugBool) __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f (toStr "Variant1") __self_01
  | CopyEnum.Variant2 __self_0 =>
    let __self_01 := Dyn.mk _ (core.fmt.DebugShared core.fmt.DebugU32) __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f (toStr "Variant2") __self_01
  | CopyEnum.Variant3 __self_0 =>
    let __self_01 := Dyn.mk _ (core.fmt.DebugShared corefmtDebugInst) __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f (toStr "Variant3") __self_01

/- Trait implementation: [derive::{core::fmt::Debug for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 16:37-16:42 -/
@[reducible]
def CopyEnum.Insts.CoreFmtDebug {T : Type} (corefmtDebugInst : core.fmt.Debug
  T) : core.fmt.Debug (CopyEnum T) := {
  fmt := CopyEnum.Insts.CoreFmtDebug.fmt corefmtDebugInst
}

/- [derive::Enum]
   Source: 'tests/src/derive.rs', lines 25:0-31:1 -/
@[discriminant isize]
inductive Enum (T : Type) where
| Variant0 : Enum T
| Variant1 : Bool → Enum T
| Variant2 : Std.U32 → Enum T
| Variant3 : T → Enum T
| Variant4 : alloc.vec.Vec T → Enum T

/- [derive::{core::clone::Clone for derive::Enum<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 24:9-24:14 -/
def Enum.Insts.CoreCloneClone.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : Enum T) :
  Result (Enum T)
  := do
  match self with
  | Enum.Variant0 => ok Enum.Variant0
  | Enum.Variant1 __self_0 =>
    let b ← lift (core.clone.impls.CloneBool.clone __self_0)
    ok (Enum.Variant1 b)
  | Enum.Variant2 __self_0 =>
    let i ← lift (core.clone.impls.CloneU32.clone __self_0)
    ok (Enum.Variant2 i)
  | Enum.Variant3 __self_0 =>
    let t ← corecloneCloneInst.clone __self_0
    ok (Enum.Variant3 t)
  | Enum.Variant4 __self_0 =>
    let v ← alloc.vec.CloneVec.clone corecloneCloneInst __self_0
    ok (Enum.Variant4 v)

/- Trait implementation: [derive::{core::clone::Clone for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 24:9-24:14 -/
@[reducible]
def Enum.Insts.CoreCloneClone {T : Type} (corecloneCloneInst : core.clone.Clone
  T) : core.clone.Clone (Enum T) := {
  clone := Enum.Insts.CoreCloneClone.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 24:16-24:25 -/
@[reducible]
def Enum.Insts.CoreMarkerStructuralPartialEq (T : Type) :
  core.marker.StructuralPartialEq (Enum T) := {
}

/- [derive::{core::cmp::PartialEq<derive::Enum<T>> for derive::Enum<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 24:16-24:25 -/
def Enum.Insts.CoreCmpPartialEqEnum.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T) (self : Enum T)
  (other : Enum T) :
  Result Bool
  := do
  let self1 := read_discriminant self
  let other1 := read_discriminant other
  if self1 = other1
  then
    match self with
    | Enum.Variant0 => ok true
    | Enum.Variant1 __self_0 =>
      match other with
      | Enum.Variant0 => ok true
      | Enum.Variant1 __arg1_0 =>
        core.cmp.impls.PartialEqBool.eq __self_0 __arg1_0
      | Enum.Variant2 _ => ok true
      | Enum.Variant3 _ => ok true
      | Enum.Variant4 _ => ok true
    | Enum.Variant2 __self_0 =>
      match other with
      | Enum.Variant0 => ok true
      | Enum.Variant1 _ => ok true
      | Enum.Variant2 __arg1_0 =>
        lift (core.cmp.impls.PartialEqU32.eq __self_0 __arg1_0)
      | Enum.Variant3 _ => ok true
      | Enum.Variant4 _ => ok true
    | Enum.Variant3 __self_0 =>
      match other with
      | Enum.Variant0 => ok true
      | Enum.Variant1 _ => ok true
      | Enum.Variant2 _ => ok true
      | Enum.Variant3 __arg1_0 =>
        core.cmp.impls.PartialEqShared.eq corecmpPartialEqInst __self_0
          __arg1_0
      | Enum.Variant4 _ => ok true
    | Enum.Variant4 __self_0 =>
      match other with
      | Enum.Variant0 => ok true
      | Enum.Variant1 _ => ok true
      | Enum.Variant2 _ => ok true
      | Enum.Variant3 _ => ok true
      | Enum.Variant4 __arg1_0 =>
        alloc.vec.partial_eq.PartialEqVec.eq corecmpPartialEqInst __self_0
          __arg1_0
  else ok false

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::Enum<T>> for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 24:16-24:25 -/
@[reducible]
def Enum.Insts.CoreCmpPartialEqEnum {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (Enum T) (Enum T) := {
  eq := Enum.Insts.CoreCmpPartialEqEnum.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::Enum<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 24:27-24:29 -/
def Enum.Insts.CoreCmpEq.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : Enum T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 24:27-24:29 -/
@[reducible]
def Enum.Insts.CoreCmpEq {T : Type} (corecmpEqInst : core.cmp.Eq T) :
  core.cmp.Eq (Enum T) := {
  partialEqInst := Enum.Insts.CoreCmpPartialEqEnum corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq :=
    Enum.Insts.CoreCmpEq.assert_receiver_is_total_eq corecmpEqInst
}

/- [derive::{core::fmt::Debug for derive::Enum<T>}::fmt]:
   Source: 'tests/src/derive.rs', lines 24:31-24:36 -/
def Enum.Insts.CoreFmtDebug.fmt
  {T : Type} (corefmtDebugInst : core.fmt.Debug T) (self : Enum T)
  (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  match self with
  | Enum.Variant0 => core.fmt.Formatter.write_str f (toStr "Variant0")
  | Enum.Variant1 __self_0 =>
    let __self_01 :=
      Dyn.mk _ (core.fmt.DebugShared core.fmt.DebugBool) __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f (toStr "Variant1") __self_01
  | Enum.Variant2 __self_0 =>
    let __self_01 := Dyn.mk _ (core.fmt.DebugShared core.fmt.DebugU32) __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f (toStr "Variant2") __self_01
  | Enum.Variant3 __self_0 =>
    let __self_01 := Dyn.mk _ (core.fmt.DebugShared corefmtDebugInst) __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f (toStr "Variant3") __self_01
  | Enum.Variant4 __self_0 =>
    let __self_01 :=
      Dyn.mk _ (core.fmt.DebugShared (core.fmt.DebugVec corefmtDebugInst))
        __self_0
    core.fmt.Formatter.debug_tuple_field1_finish f (toStr "Variant4") __self_01

/- Trait implementation: [derive::{core::fmt::Debug for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 24:31-24:36 -/
@[reducible]
def Enum.Insts.CoreFmtDebug {T : Type} (corefmtDebugInst : core.fmt.Debug T) :
  core.fmt.Debug (Enum T) := {
  fmt := Enum.Insts.CoreFmtDebug.fmt corefmtDebugInst
}

/- [derive::List]
   Source: 'tests/src/derive.rs', lines 35:0-39:1 -/
@[discriminant isize]
inductive List (T : Type) where
| Nil : List T
| Cons : T → List T → List T

/- [derive::{core::clone::Clone for derive::List<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 34:9-34:14 -/
def List.Insts.CoreCloneClone.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : List T) :
  Result (List T)
  := do
  match self with
  | List.Nil => ok List.Nil
  | List.Cons __self_0 __self_1 =>
    let t ← corecloneCloneInst.clone __self_0
    let l ← List.Insts.CoreCloneClone.clone corecloneCloneInst __self_1
    ok (List.Cons t l)
partial_fixpoint

/- Trait implementation: [derive::{core::clone::Clone for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 34:9-34:14 -/
@[reducible]
def List.Insts.CoreCloneClone {T : Type} (corecloneCloneInst : core.clone.Clone
  T) : core.clone.Clone (List T) := {
  clone := List.Insts.CoreCloneClone.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 34:16-34:25 -/
@[reducible]
def List.Insts.CoreMarkerStructuralPartialEq (T : Type) :
  core.marker.StructuralPartialEq (List T) := {
}

/- [derive::{core::cmp::PartialEq<derive::List<T>> for derive::List<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 34:16-34:25 -/
def List.Insts.CoreCmpPartialEqList.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T) (self : List T)
  (other : List T) :
  Result Bool
  := do
  let self1 := read_discriminant self
  let other1 := read_discriminant other
  if self1 = other1
  then
    match self with
    | List.Nil => ok true
    | List.Cons __self_0 __self_1 =>
      match other with
      | List.Nil => ok true
      | List.Cons __arg1_0 __arg1_1 =>
        let b ←
          core.cmp.impls.PartialEqShared.eq corecmpPartialEqInst __self_0
            __arg1_0
        if b
        then
          List.Insts.CoreCmpPartialEqList.eq corecmpPartialEqInst __self_1
            __arg1_1
        else ok false
  else ok false
partial_fixpoint

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::List<T>> for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 34:16-34:25 -/
@[reducible]
def List.Insts.CoreCmpPartialEqList {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (List T) (List T) := {
  eq := List.Insts.CoreCmpPartialEqList.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::List<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 34:27-34:29 -/
def List.Insts.CoreCmpEq.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : List T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 34:27-34:29 -/
@[reducible]
def List.Insts.CoreCmpEq {T : Type} (corecmpEqInst : core.cmp.Eq T) :
  core.cmp.Eq (List T) := {
  partialEqInst := List.Insts.CoreCmpPartialEqList corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq :=
    List.Insts.CoreCmpEq.assert_receiver_is_total_eq corecmpEqInst
}

/- [derive::CopyStruct]
   Source: 'tests/src/derive.rs', lines 42:0-47:1 -/
structure CopyStruct (T : Type) where
  f0 : Unit
  f1 : Bool
  f2 : Std.U32
  f3 : T

/- [derive::{core::clone::Clone for derive::CopyStruct<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 41:9-41:14 -/
def CopyStruct.Insts.CoreCloneClone.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : CopyStruct T) :
  Result (CopyStruct T)
  := do
  (BuiltinClone Unit).clone ()
  let b ← lift (core.clone.impls.CloneBool.clone self.f1)
  let i ← lift (core.clone.impls.CloneU32.clone self.f2)
  let t ← corecloneCloneInst.clone self.f3
  ok { f0 := (), f1 := b, f2 := i, f3 := t }

/- Trait implementation: [derive::{core::clone::Clone for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 41:9-41:14 -/
@[reducible]
def CopyStruct.Insts.CoreCloneClone {T : Type} (corecloneCloneInst :
  core.clone.Clone T) : core.clone.Clone (CopyStruct T) := {
  clone := CopyStruct.Insts.CoreCloneClone.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::Copy for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 41:16-41:20 -/
@[reducible]
def CopyStruct.Insts.CoreMarkerCopy {T : Type} (coremarkerCopyInst :
  core.marker.Copy T) : core.marker.Copy (CopyStruct T) := {
  cloneInst := CopyStruct.Insts.CoreCloneClone coremarkerCopyInst.cloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 41:22-41:31 -/
@[reducible]
def CopyStruct.Insts.CoreMarkerStructuralPartialEq (T : Type) :
  core.marker.StructuralPartialEq (CopyStruct T) := {
}

/- [derive::{core::cmp::PartialEq<derive::CopyStruct<T>> for derive::CopyStruct<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 41:22-41:31 -/
def CopyStruct.Insts.CoreCmpPartialEqCopyStruct.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T)
  (self : CopyStruct T) (other : CopyStruct T) :
  Result Bool
  := do
  let b ← core.cmp.impls.PartialEqUnit.eq () ()
  if b
  then
    if self.f1 = other.f1
    then
      if self.f2 = other.f2
      then corecmpPartialEqInst.eq self.f3 other.f3
      else ok false
    else ok false
  else ok false

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::CopyStruct<T>> for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 41:22-41:31 -/
@[reducible]
def CopyStruct.Insts.CoreCmpPartialEqCopyStruct {T : Type}
  (corecmpPartialEqInst : core.cmp.PartialEq T T) : core.cmp.PartialEq
  (CopyStruct T) (CopyStruct T) := {
  eq := CopyStruct.Insts.CoreCmpPartialEqCopyStruct.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::CopyStruct<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 41:33-41:35 -/
def CopyStruct.Insts.CoreCmpEq.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : CopyStruct T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 41:33-41:35 -/
@[reducible]
def CopyStruct.Insts.CoreCmpEq {T : Type} (corecmpEqInst : core.cmp.Eq T) :
  core.cmp.Eq (CopyStruct T) := {
  partialEqInst := CopyStruct.Insts.CoreCmpPartialEqCopyStruct
    corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq :=
    CopyStruct.Insts.CoreCmpEq.assert_receiver_is_total_eq corecmpEqInst
}

/- [derive::{core::fmt::Debug for derive::CopyStruct<T>}::fmt]:
   Source: 'tests/src/derive.rs', lines 41:37-41:42 -/
def CopyStruct.Insts.CoreFmtDebug.fmt
  {T : Type} (corefmtDebugInst : core.fmt.Debug T) (self : CopyStruct T)
  (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  let dyn := Dyn.mk _ core.fmt.DebugUnit ()
  let dyn1 := Dyn.mk _ core.fmt.DebugBool self.f1
  let dyn2 := Dyn.mk _ core.fmt.DebugU32 self.f2
  let dyn3 := Dyn.mk _ (core.fmt.DebugShared corefmtDebugInst) self.f3
  core.fmt.Formatter.debug_struct_field4_finish f (toStr "CopyStruct") (toStr
    "f0") dyn (toStr "f1") dyn1 (toStr "f2") dyn2 (toStr "f3") dyn3

/- Trait implementation: [derive::{core::fmt::Debug for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 41:37-41:42 -/
@[reducible]
def CopyStruct.Insts.CoreFmtDebug {T : Type} (corefmtDebugInst : core.fmt.Debug
  T) : core.fmt.Debug (CopyStruct T) := {
  fmt := CopyStruct.Insts.CoreFmtDebug.fmt corefmtDebugInst
}

/- [derive::Struct]
   Source: 'tests/src/derive.rs', lines 50:0-52:1 -/
structure Struct (T : Type) where
  f : alloc.vec.Vec T

/- [derive::{core::clone::Clone for derive::Struct<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 49:9-49:14 -/
def Struct.Insts.CoreCloneClone.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : Struct T) :
  Result (Struct T)
  := do
  let v ← alloc.vec.CloneVec.clone corecloneCloneInst self.f
  ok { f := v }

/- Trait implementation: [derive::{core::clone::Clone for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 49:9-49:14 -/
@[reducible]
def Struct.Insts.CoreCloneClone {T : Type} (corecloneCloneInst :
  core.clone.Clone T) : core.clone.Clone (Struct T) := {
  clone := Struct.Insts.CoreCloneClone.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 49:16-49:25 -/
@[reducible]
def Struct.Insts.CoreMarkerStructuralPartialEq (T : Type) :
  core.marker.StructuralPartialEq (Struct T) := {
}

/- [derive::{core::cmp::PartialEq<derive::Struct<T>> for derive::Struct<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 49:16-49:25 -/
def Struct.Insts.CoreCmpPartialEqStruct.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T) (self : Struct T)
  (other : Struct T) :
  Result Bool
  := do
  alloc.vec.partial_eq.PartialEqVec.eq corecmpPartialEqInst self.f other.f

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::Struct<T>> for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 49:16-49:25 -/
@[reducible]
def Struct.Insts.CoreCmpPartialEqStruct {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (Struct T) (Struct T) := {
  eq := Struct.Insts.CoreCmpPartialEqStruct.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::Struct<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 49:27-49:29 -/
def Struct.Insts.CoreCmpEq.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : Struct T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 49:27-49:29 -/
@[reducible]
def Struct.Insts.CoreCmpEq {T : Type} (corecmpEqInst : core.cmp.Eq T) :
  core.cmp.Eq (Struct T) := {
  partialEqInst := Struct.Insts.CoreCmpPartialEqStruct
    corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq :=
    Struct.Insts.CoreCmpEq.assert_receiver_is_total_eq corecmpEqInst
}

/- [derive::{core::fmt::Debug for derive::Struct<T>}::fmt]:
   Source: 'tests/src/derive.rs', lines 49:31-49:36 -/
def Struct.Insts.CoreFmtDebug.fmt
  {T : Type} (corefmtDebugInst : core.fmt.Debug T) (self : Struct T)
  (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  let dyn :=
    Dyn.mk _ (core.fmt.DebugShared (core.fmt.DebugVec corefmtDebugInst)) self.f
  core.fmt.Formatter.debug_struct_field1_finish f (toStr "Struct") (toStr "f")
    dyn

/- Trait implementation: [derive::{core::fmt::Debug for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 49:31-49:36 -/
@[reducible]
def Struct.Insts.CoreFmtDebug {T : Type} (corefmtDebugInst : core.fmt.Debug T)
  : core.fmt.Debug (Struct T) := {
  fmt := Struct.Insts.CoreFmtDebug.fmt corefmtDebugInst
}

/- [derive::Struct6Fields]
   Source: 'tests/src/derive.rs', lines 55:0-62:1 -/
structure Struct6Fields where
  a : Std.U32
  b : Std.U32
  c : Std.U32
  d : Std.U32
  e : Std.U32
  f : Std.U32

/- [derive::{core::clone::Clone for derive::Struct6Fields}::clone]:
   Source: 'tests/src/derive.rs', lines 54:9-54:14 -/
def Struct6Fields.Insts.CoreCloneClone.clone
  (self : Struct6Fields) : Result Struct6Fields := do
  let i ← lift (core.clone.impls.CloneU32.clone self.a)
  let i1 ← lift (core.clone.impls.CloneU32.clone self.b)
  let i2 ← lift (core.clone.impls.CloneU32.clone self.c)
  let i3 ← lift (core.clone.impls.CloneU32.clone self.d)
  let i4 ← lift (core.clone.impls.CloneU32.clone self.e)
  let i5 ← lift (core.clone.impls.CloneU32.clone self.f)
  ok { a := i, b := i1, c := i2, d := i3, e := i4, f := i5 }

/- Trait implementation: [derive::{core::clone::Clone for derive::Struct6Fields}]
   Source: 'tests/src/derive.rs', lines 54:9-54:14 -/
@[reducible]
def Struct6Fields.Insts.CoreCloneClone : core.clone.Clone Struct6Fields := {
  clone := Struct6Fields.Insts.CoreCloneClone.clone
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::Struct6Fields}]
   Source: 'tests/src/derive.rs', lines 54:16-54:25 -/
@[reducible]
def Struct6Fields.Insts.CoreMarkerStructuralPartialEq :
  core.marker.StructuralPartialEq Struct6Fields := {
}

/- [derive::{core::cmp::PartialEq<derive::Struct6Fields> for derive::Struct6Fields}::eq]:
   Source: 'tests/src/derive.rs', lines 54:16-54:25 -/
def Struct6Fields.Insts.CoreCmpPartialEqStruct6Fields.eq
  (self : Struct6Fields) (other : Struct6Fields) : Result Bool := do
  if self.a = other.a
  then
    if self.b = other.b
    then
      if self.c = other.c
      then
        if self.d = other.d
        then if self.e = other.e
             then ok (self.f = other.f)
             else ok false
        else ok false
      else ok false
    else ok false
  else ok false

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::Struct6Fields> for derive::Struct6Fields}]
   Source: 'tests/src/derive.rs', lines 54:16-54:25 -/
@[reducible]
def Struct6Fields.Insts.CoreCmpPartialEqStruct6Fields : core.cmp.PartialEq
  Struct6Fields Struct6Fields := {
  eq := Struct6Fields.Insts.CoreCmpPartialEqStruct6Fields.eq
}

/- [derive::{core::cmp::Eq for derive::Struct6Fields}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 54:27-54:29 -/
def Struct6Fields.Insts.CoreCmpEq.assert_receiver_is_total_eq
  (self : Struct6Fields) : Result Unit := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::Struct6Fields}]
   Source: 'tests/src/derive.rs', lines 54:27-54:29 -/
@[reducible]
def Struct6Fields.Insts.CoreCmpEq : core.cmp.Eq Struct6Fields := {
  partialEqInst := Struct6Fields.Insts.CoreCmpPartialEqStruct6Fields
  assert_receiver_is_total_eq :=
    Struct6Fields.Insts.CoreCmpEq.assert_receiver_is_total_eq
}

/- [derive::{core::fmt::Debug for derive::Struct6Fields}::fmt]:
   Source: 'tests/src/derive.rs', lines 54:31-54:36 -/
def Struct6Fields.Insts.CoreFmtDebug.fmt
  (self : Struct6Fields) (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  let dyn := Dyn.mk _ core.fmt.DebugU32 self.a
  let dyn1 := Dyn.mk _ core.fmt.DebugU32 self.b
  let dyn2 := Dyn.mk _ core.fmt.DebugU32 self.c
  let dyn3 := Dyn.mk _ core.fmt.DebugU32 self.d
  let dyn4 := Dyn.mk _ core.fmt.DebugU32 self.e
  let dyn5 := Dyn.mk _ (core.fmt.DebugShared core.fmt.DebugU32) self.f
  let values :=
    Array.to_slice (Array.make 6#usize [ dyn, dyn1, dyn2, dyn3, dyn4, dyn5 ])
  let s ←
    lift (Array.to_slice
      (Array.make 6#usize [
        toStr "a", toStr "b", toStr "c", toStr "d", toStr "e", toStr "f"
        ]))
  core.fmt.Formatter.debug_struct_fields_finish f (toStr "Struct6Fields") s
    values

/- Trait implementation: [derive::{core::fmt::Debug for derive::Struct6Fields}]
   Source: 'tests/src/derive.rs', lines 54:31-54:36 -/
@[reducible]
def Struct6Fields.Insts.CoreFmtDebug : core.fmt.Debug Struct6Fields := {
  fmt := Struct6Fields.Insts.CoreFmtDebug.fmt
}

end derive
