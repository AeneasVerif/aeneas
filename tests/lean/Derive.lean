-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [derive]
import Aeneas
open Aeneas Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace derive

/- [derive::ScalarEnum]
   Source: 'tests/src/derive.rs', lines 6:0-11:1 -/
@[discriminant [2,4,8,16]]
inductive ScalarEnum where
| Variant0 : ScalarEnum
| Variant1 : ScalarEnum
| Variant2 : ScalarEnum
| Variant3 : ScalarEnum

/- [derive::{core::fmt::Debug for derive::ScalarEnum}::fmt]:
   Source: 'tests/src/derive.rs', lines 5:9-5:14 -/
def DebugScalarEnum.fmt
  (self : ScalarEnum) (f : core.fmt.Formatter) :
  Result ((core.result.Result Unit core.fmt.Error) × core.fmt.Formatter)
  := do
  match self with
  | ScalarEnum.Variant0 => core.fmt.Formatter.write_str f "Variant0"
  | ScalarEnum.Variant1 => core.fmt.Formatter.write_str f "Variant1"
  | ScalarEnum.Variant2 => core.fmt.Formatter.write_str f "Variant2"
  | ScalarEnum.Variant3 => core.fmt.Formatter.write_str f "Variant3"

/- Trait implementation: [derive::{core::fmt::Debug for derive::ScalarEnum}]
   Source: 'tests/src/derive.rs', lines 5:9-5:14 -/
@[reducible]
def core.fmt.DebugScalarEnum : core.fmt.Debug ScalarEnum := {
  fmt := DebugScalarEnum.fmt
}

/- [derive::CopyEnum]
   Source: 'tests/src/derive.rs', lines 14:0-19:1 -/
@[discriminant]
inductive CopyEnum (T : Type) where
| Variant0 : CopyEnum T
| Variant1 : Bool → CopyEnum T
| Variant2 : Std.U32 → CopyEnum T
| Variant3 : T → CopyEnum T

/- [derive::{core::clone::Clone for derive::CopyEnum<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 13:9-13:14 -/
def CloneCopyEnum.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : CopyEnum T) :
  Result (CopyEnum T)
  := do
  match self with
  | CopyEnum.Variant0 => ok CopyEnum.Variant0
  | CopyEnum.Variant1 __self_0 =>
    let b ← (↑(core.clone.impls.CloneBool.clone __self_0) : Result Bool)
    ok (CopyEnum.Variant1 b)
  | CopyEnum.Variant2 __self_0 =>
    let i ← (↑(core.clone.impls.CloneU32.clone __self_0) : Result Std.U32)
    ok (CopyEnum.Variant2 i)
  | CopyEnum.Variant3 __self_0 =>
    let t ← corecloneCloneInst.clone __self_0
    ok (CopyEnum.Variant3 t)

/- Trait implementation: [derive::{core::clone::Clone for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 13:9-13:14 -/
@[reducible]
def core.clone.CloneCopyEnum {T : Type} (corecloneCloneInst : core.clone.Clone
  T) : core.clone.Clone (CopyEnum T) := {
  clone := CloneCopyEnum.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::Copy for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 13:16-13:20 -/
@[reducible]
def core.marker.CopyCopyEnum {T : Type} (coremarkerCopyInst : core.marker.Copy
  T) : core.marker.Copy (CopyEnum T) := {
  cloneInst := core.clone.CloneCopyEnum coremarkerCopyInst.cloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 13:22-13:31 -/
@[reducible]
def core.marker.StructuralPartialEqCopyEnum (T : Type) :
  core.marker.StructuralPartialEq (CopyEnum T) := {
}

/- [derive::{core::cmp::PartialEq<derive::CopyEnum<T>> for derive::CopyEnum<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 13:22-13:31 -/
def PartialEqCopyEnumCopyEnum.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T)
  (self : CopyEnum T) (other : CopyEnum T) :
  Result Bool
  := do
  let self1 := read_discriminant self
  let other1 := read_discriminant other
  if self1 = other1
  then
    match self with
    | CopyEnum.Variant0 => ok true
    | CopyEnum.Variant1 __self_0 =>
      match other with
      | CopyEnum.Variant0 => ok true
      | CopyEnum.Variant1 __arg1_0 =>
        core.cmp.impls.PartialEqBool.eq __self_0 __arg1_0
      | CopyEnum.Variant2 _ => ok true
      | CopyEnum.Variant3 _ => ok true
    | CopyEnum.Variant2 __self_0 =>
      match other with
      | CopyEnum.Variant0 => ok true
      | CopyEnum.Variant1 _ => ok true
      | CopyEnum.Variant2 __arg1_0 =>
        core.cmp.impls.PartialEqU32.eq __self_0 __arg1_0
      | CopyEnum.Variant3 _ => ok true
    | CopyEnum.Variant3 __self_0 =>
      match other with
      | CopyEnum.Variant0 => ok true
      | CopyEnum.Variant1 _ => ok true
      | CopyEnum.Variant2 _ => ok true
      | CopyEnum.Variant3 __arg1_0 =>
        core.cmp.impls.PartialEqShared.eq corecmpPartialEqInst __self_0
          __arg1_0
  else ok false

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::CopyEnum<T>> for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 13:22-13:31 -/
@[reducible]
def core.cmp.PartialEqCopyEnumCopyEnum {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (CopyEnum T) (CopyEnum T) := {
  eq := PartialEqCopyEnumCopyEnum.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::CopyEnum<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 13:33-13:35 -/
def EqCopyEnum.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : CopyEnum T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::CopyEnum<T>}]
   Source: 'tests/src/derive.rs', lines 13:33-13:35 -/
@[reducible]
def core.cmp.EqCopyEnum {T : Type} (corecmpEqInst : core.cmp.Eq T) :
  core.cmp.Eq (CopyEnum T) := {
  partialEqInst := core.cmp.PartialEqCopyEnumCopyEnum
    corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq := EqCopyEnum.assert_receiver_is_total_eq
    corecmpEqInst
}

/- [derive::Enum]
   Source: 'tests/src/derive.rs', lines 22:0-28:1 -/
@[discriminant]
inductive Enum (T : Type) where
| Variant0 : Enum T
| Variant1 : Bool → Enum T
| Variant2 : Std.U32 → Enum T
| Variant3 : T → Enum T
| Variant4 : alloc.vec.Vec T → Enum T

/- [derive::{core::clone::Clone for derive::Enum<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 21:9-21:14 -/
def CloneEnum.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : Enum T) :
  Result (Enum T)
  := do
  match self with
  | Enum.Variant0 => ok Enum.Variant0
  | Enum.Variant1 __self_0 =>
    let b ← (↑(core.clone.impls.CloneBool.clone __self_0) : Result Bool)
    ok (Enum.Variant1 b)
  | Enum.Variant2 __self_0 =>
    let i ← (↑(core.clone.impls.CloneU32.clone __self_0) : Result Std.U32)
    ok (Enum.Variant2 i)
  | Enum.Variant3 __self_0 =>
    let t ← corecloneCloneInst.clone __self_0
    ok (Enum.Variant3 t)
  | Enum.Variant4 __self_0 =>
    let v ← alloc.vec.CloneVec.clone corecloneCloneInst __self_0
    ok (Enum.Variant4 v)

/- Trait implementation: [derive::{core::clone::Clone for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 21:9-21:14 -/
@[reducible]
def core.clone.CloneEnum {T : Type} (corecloneCloneInst : core.clone.Clone T) :
  core.clone.Clone (Enum T) := {
  clone := CloneEnum.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 21:16-21:25 -/
@[reducible]
def core.marker.StructuralPartialEqEnum (T : Type) :
  core.marker.StructuralPartialEq (Enum T) := {
}

/- [derive::{core::cmp::PartialEq<derive::Enum<T>> for derive::Enum<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 21:16-21:25 -/
def PartialEqEnumEnum.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T) (self : Enum T)
  (other : Enum T) :
  Result Bool
  := do
  let self1 := read_discriminant self
  let other1 := read_discriminant other
  if self1 = other1
  then
    match self with
    | Enum.Variant0 => ok true
    | Enum.Variant1 __self_0 =>
      match other with
      | Enum.Variant0 => ok true
      | Enum.Variant1 __arg1_0 =>
        core.cmp.impls.PartialEqBool.eq __self_0 __arg1_0
      | Enum.Variant2 _ => ok true
      | Enum.Variant3 _ => ok true
      | Enum.Variant4 _ => ok true
    | Enum.Variant2 __self_0 =>
      match other with
      | Enum.Variant0 => ok true
      | Enum.Variant1 _ => ok true
      | Enum.Variant2 __arg1_0 =>
        core.cmp.impls.PartialEqU32.eq __self_0 __arg1_0
      | Enum.Variant3 _ => ok true
      | Enum.Variant4 _ => ok true
    | Enum.Variant3 __self_0 =>
      match other with
      | Enum.Variant0 => ok true
      | Enum.Variant1 _ => ok true
      | Enum.Variant2 _ => ok true
      | Enum.Variant3 __arg1_0 =>
        core.cmp.impls.PartialEqShared.eq corecmpPartialEqInst __self_0
          __arg1_0
      | Enum.Variant4 _ => ok true
    | Enum.Variant4 __self_0 =>
      match other with
      | Enum.Variant0 => ok true
      | Enum.Variant1 _ => ok true
      | Enum.Variant2 _ => ok true
      | Enum.Variant3 _ => ok true
      | Enum.Variant4 __arg1_0 =>
        alloc.vec.partial_eq.PartialEqVec.eq corecmpPartialEqInst __self_0
          __arg1_0
  else ok false

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::Enum<T>> for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 21:16-21:25 -/
@[reducible]
def core.cmp.PartialEqEnumEnum {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (Enum T) (Enum T) := {
  eq := PartialEqEnumEnum.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::Enum<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 21:27-21:29 -/
def EqEnum.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : Enum T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::Enum<T>}]
   Source: 'tests/src/derive.rs', lines 21:27-21:29 -/
@[reducible]
def core.cmp.EqEnum {T : Type} (corecmpEqInst : core.cmp.Eq T) : core.cmp.Eq
  (Enum T) := {
  partialEqInst := core.cmp.PartialEqEnumEnum corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq := EqEnum.assert_receiver_is_total_eq
    corecmpEqInst
}

/- [derive::List]
   Source: 'tests/src/derive.rs', lines 31:0-35:1 -/
@[discriminant]
inductive List (T : Type) where
| Nil : List T
| Cons : T → List T → List T

/- [derive::{core::clone::Clone for derive::List<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 30:9-30:14 -/
def CloneList.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : List T) :
  Result (List T)
  := do
  match self with
  | List.Nil => ok List.Nil
  | List.Cons __self_0 __self_1 =>
    let t ← corecloneCloneInst.clone __self_0
    let l ← CloneList.clone corecloneCloneInst __self_1
    ok (List.Cons t l)
partial_fixpoint

/- Trait implementation: [derive::{core::clone::Clone for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 30:9-30:14 -/
@[reducible]
def core.clone.CloneList {T : Type} (corecloneCloneInst : core.clone.Clone T) :
  core.clone.Clone (List T) := {
  clone := CloneList.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 30:16-30:25 -/
@[reducible]
def core.marker.StructuralPartialEqList (T : Type) :
  core.marker.StructuralPartialEq (List T) := {
}

/- [derive::{core::cmp::PartialEq<derive::List<T>> for derive::List<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 30:16-30:25 -/
def PartialEqListList.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T) (self : List T)
  (other : List T) :
  Result Bool
  := do
  let self1 := read_discriminant self
  let other1 := read_discriminant other
  if self1 = other1
  then
    match self with
    | List.Nil => ok true
    | List.Cons __self_0 __self_1 =>
      match other with
      | List.Nil => ok true
      | List.Cons __arg1_0 __arg1_1 =>
        let b ←
          core.cmp.impls.PartialEqShared.eq corecmpPartialEqInst __self_0
            __arg1_0
        if b
        then PartialEqListList.eq corecmpPartialEqInst __self_1 __arg1_1
        else ok false
  else ok false
partial_fixpoint

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::List<T>> for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 30:16-30:25 -/
@[reducible]
def core.cmp.PartialEqListList {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (List T) (List T) := {
  eq := PartialEqListList.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::List<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 30:27-30:29 -/
def EqList.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : List T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::List<T>}]
   Source: 'tests/src/derive.rs', lines 30:27-30:29 -/
@[reducible]
def core.cmp.EqList {T : Type} (corecmpEqInst : core.cmp.Eq T) : core.cmp.Eq
  (List T) := {
  partialEqInst := core.cmp.PartialEqListList corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq := EqList.assert_receiver_is_total_eq
    corecmpEqInst
}

/- [derive::CopyStruct]
   Source: 'tests/src/derive.rs', lines 38:0-43:1 -/
structure CopyStruct (T : Type) where
  f0 : Unit
  f1 : Bool
  f2 : Std.U32
  f3 : T

/- [derive::{core::clone::Clone for derive::CopyStruct<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 37:9-37:14 -/
def CloneCopyStruct.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : CopyStruct T) :
  Result (CopyStruct T)
  := do
  (BuiltinClone Unit).clone ()
  let b ← (↑(core.clone.impls.CloneBool.clone self.f1) : Result Bool)
  let i ← (↑(core.clone.impls.CloneU32.clone self.f2) : Result Std.U32)
  let t ← corecloneCloneInst.clone self.f3
  ok { f0 := (), f1 := b, f2 := i, f3 := t }

/- Trait implementation: [derive::{core::clone::Clone for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 37:9-37:14 -/
@[reducible]
def core.clone.CloneCopyStruct {T : Type} (corecloneCloneInst :
  core.clone.Clone T) : core.clone.Clone (CopyStruct T) := {
  clone := CloneCopyStruct.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::Copy for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 37:16-37:20 -/
@[reducible]
def core.marker.CopyCopyStruct {T : Type} (coremarkerCopyInst :
  core.marker.Copy T) : core.marker.Copy (CopyStruct T) := {
  cloneInst := core.clone.CloneCopyStruct coremarkerCopyInst.cloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 37:22-37:31 -/
@[reducible]
def core.marker.StructuralPartialEqCopyStruct (T : Type) :
  core.marker.StructuralPartialEq (CopyStruct T) := {
}

/- [derive::{core::cmp::PartialEq<derive::CopyStruct<T>> for derive::CopyStruct<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 37:22-37:31 -/
def PartialEqCopyStructCopyStruct.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T)
  (self : CopyStruct T) (other : CopyStruct T) :
  Result Bool
  := do
  let b ← core.cmp.impls.PartialEqUnit.eq () ()
  if b
  then
    if self.f1 = other.f1
    then
      if self.f2 = other.f2
      then corecmpPartialEqInst.eq self.f3 other.f3
      else ok false
    else ok false
  else ok false

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::CopyStruct<T>> for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 37:22-37:31 -/
@[reducible]
def core.cmp.PartialEqCopyStructCopyStruct {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (CopyStruct T) (CopyStruct T)
  := {
  eq := PartialEqCopyStructCopyStruct.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::CopyStruct<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 37:33-37:35 -/
def EqCopyStruct.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : CopyStruct T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::CopyStruct<T>}]
   Source: 'tests/src/derive.rs', lines 37:33-37:35 -/
@[reducible]
def core.cmp.EqCopyStruct {T : Type} (corecmpEqInst : core.cmp.Eq T) :
  core.cmp.Eq (CopyStruct T) := {
  partialEqInst := core.cmp.PartialEqCopyStructCopyStruct
    corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq := EqCopyStruct.assert_receiver_is_total_eq
    corecmpEqInst
}

/- [derive::Struct]
   Source: 'tests/src/derive.rs', lines 46:0-48:1 -/
structure Struct (T : Type) where
  f : alloc.vec.Vec T

/- [derive::{core::clone::Clone for derive::Struct<T>}::clone]:
   Source: 'tests/src/derive.rs', lines 45:9-45:14 -/
def CloneStruct.clone
  {T : Type} (corecloneCloneInst : core.clone.Clone T) (self : Struct T) :
  Result (Struct T)
  := do
  let v ← alloc.vec.CloneVec.clone corecloneCloneInst self.f
  ok { f := v }

/- Trait implementation: [derive::{core::clone::Clone for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 45:9-45:14 -/
@[reducible]
def core.clone.CloneStruct {T : Type} (corecloneCloneInst : core.clone.Clone T)
  : core.clone.Clone (Struct T) := {
  clone := CloneStruct.clone corecloneCloneInst
}

/- Trait implementation: [derive::{core::marker::StructuralPartialEq for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 45:16-45:25 -/
@[reducible]
def core.marker.StructuralPartialEqStruct (T : Type) :
  core.marker.StructuralPartialEq (Struct T) := {
}

/- [derive::{core::cmp::PartialEq<derive::Struct<T>> for derive::Struct<T>}::eq]:
   Source: 'tests/src/derive.rs', lines 45:16-45:25 -/
def PartialEqStructStruct.eq
  {T : Type} (corecmpPartialEqInst : core.cmp.PartialEq T T) (self : Struct T)
  (other : Struct T) :
  Result Bool
  := do
  alloc.vec.partial_eq.PartialEqVec.eq corecmpPartialEqInst self.f other.f

/- Trait implementation: [derive::{core::cmp::PartialEq<derive::Struct<T>> for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 45:16-45:25 -/
@[reducible]
def core.cmp.PartialEqStructStruct {T : Type} (corecmpPartialEqInst :
  core.cmp.PartialEq T T) : core.cmp.PartialEq (Struct T) (Struct T) := {
  eq := PartialEqStructStruct.eq corecmpPartialEqInst
}

/- [derive::{core::cmp::Eq for derive::Struct<T>}::assert_receiver_is_total_eq]:
   Source: 'tests/src/derive.rs', lines 45:27-45:29 -/
def EqStruct.assert_receiver_is_total_eq
  {T : Type} (corecmpEqInst : core.cmp.Eq T) (self : Struct T) :
  Result Unit
  := do
  ok ()

/- Trait implementation: [derive::{core::cmp::Eq for derive::Struct<T>}]
   Source: 'tests/src/derive.rs', lines 45:27-45:29 -/
@[reducible]
def core.cmp.EqStruct {T : Type} (corecmpEqInst : core.cmp.Eq T) : core.cmp.Eq
  (Struct T) := {
  partialEqInst := core.cmp.PartialEqStructStruct corecmpEqInst.partialEqInst
  assert_receiver_is_total_eq := EqStruct.assert_receiver_is_total_eq
    corecmpEqInst
}

end derive
