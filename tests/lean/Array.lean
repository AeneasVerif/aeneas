-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [array]
import Base
open Primitives

namespace array

/- [array::AB] -/
inductive AB :=
| A : AB
| B : AB

/- [array::incr]: merged forward/backward function
   (there is a single backward function, and the forward function returns ()) -/
def incr (x : U32) : Result U32 :=
  x + 1#u32

/- [array::array_to_shared_slice_]: forward function -/
def array_to_shared_slice_
  (T : Type) (s : Array T 32#usize) : Result (Slice T) :=
  Array.to_slice T 32#usize s

/- [array::array_to_mut_slice_]: forward function -/
def array_to_mut_slice_ (T : Type) (s : Array T 32#usize) : Result (Slice T) :=
  Array.to_slice T 32#usize s

/- [array::array_to_mut_slice_]: backward function 0 -/
def array_to_mut_slice__back
  (T : Type) (s : Array T 32#usize) (ret0 : Slice T) :
  Result (Array T 32#usize)
  :=
  Array.from_slice T 32#usize s ret0

/- [array::array_len]: forward function -/
def array_len (T : Type) (s : Array T 32#usize) : Result Usize :=
  do
    let s0 ← Array.to_slice T 32#usize s
    let i := Slice.len T s0
    Result.ret i

/- [array::shared_array_len]: forward function -/
def shared_array_len (T : Type) (s : Array T 32#usize) : Result Usize :=
  do
    let s0 ← Array.to_slice T 32#usize s
    let i := Slice.len T s0
    Result.ret i

/- [array::shared_slice_len]: forward function -/
def shared_slice_len (T : Type) (s : Slice T) : Result Usize :=
  let i := Slice.len T s
  Result.ret i

/- [array::index_array_shared]: forward function -/
def index_array_shared
  (T : Type) (s : Array T 32#usize) (i : Usize) : Result T :=
  Array.index_usize T 32#usize s i

/- [array::index_array_u32]: forward function -/
def index_array_u32 (s : Array U32 32#usize) (i : Usize) : Result U32 :=
  Array.index_usize U32 32#usize s i

/- [array::index_array_copy]: forward function -/
def index_array_copy (x : Array U32 32#usize) : Result U32 :=
  Array.index_usize U32 32#usize x 0#usize

/- [array::index_mut_array]: forward function -/
def index_mut_array (T : Type) (s : Array T 32#usize) (i : Usize) : Result T :=
  Array.index_usize T 32#usize s i

/- [array::index_mut_array]: backward function 0 -/
def index_mut_array_back
  (T : Type) (s : Array T 32#usize) (i : Usize) (ret0 : T) :
  Result (Array T 32#usize)
  :=
  Array.update_usize T 32#usize s i ret0

/- [array::index_slice]: forward function -/
def index_slice (T : Type) (s : Slice T) (i : Usize) : Result T :=
  Slice.index_usize T s i

/- [array::index_mut_slice]: forward function -/
def index_mut_slice (T : Type) (s : Slice T) (i : Usize) : Result T :=
  Slice.index_usize T s i

/- [array::index_mut_slice]: backward function 0 -/
def index_mut_slice_back
  (T : Type) (s : Slice T) (i : Usize) (ret0 : T) : Result (Slice T) :=
  Slice.update_usize T s i ret0

/- [array::slice_subslice_shared_]: forward function -/
def slice_subslice_shared_
  (x : Slice U32) (y : Usize) (z : Usize) : Result (Slice U32) :=
  core.slice.index.Slice.index U32 (core.ops.range.Range Usize)
    (core.slice.index.SliceIndexRangeUsizeSliceTInst U32) x
    { start := y, end_ := z }

/- [array::slice_subslice_mut_]: forward function -/
def slice_subslice_mut_
  (x : Slice U32) (y : Usize) (z : Usize) : Result (Slice U32) :=
  core.slice.index.Slice.index_mut U32 (core.ops.range.Range Usize)
    (core.slice.index.SliceIndexRangeUsizeSliceTInst U32) x
    { start := y, end_ := z }

/- [array::slice_subslice_mut_]: backward function 0 -/
def slice_subslice_mut__back
  (x : Slice U32) (y : Usize) (z : Usize) (ret0 : Slice U32) :
  Result (Slice U32)
  :=
  core.slice.index.Slice.index_mut_back U32 (core.ops.range.Range Usize)
    (core.slice.index.SliceIndexRangeUsizeSliceTInst U32) x
    { start := y, end_ := z } ret0

/- [array::array_to_slice_shared_]: forward function -/
def array_to_slice_shared_ (x : Array U32 32#usize) : Result (Slice U32) :=
  Array.to_slice U32 32#usize x

/- [array::array_to_slice_mut_]: forward function -/
def array_to_slice_mut_ (x : Array U32 32#usize) : Result (Slice U32) :=
  Array.to_slice U32 32#usize x

/- [array::array_to_slice_mut_]: backward function 0 -/
def array_to_slice_mut__back
  (x : Array U32 32#usize) (ret0 : Slice U32) : Result (Array U32 32#usize) :=
  Array.from_slice U32 32#usize x ret0

/- [array::array_subslice_shared_]: forward function -/
def array_subslice_shared_
  (x : Array U32 32#usize) (y : Usize) (z : Usize) : Result (Slice U32) :=
  core.array.Array.index U32 (core.ops.range.Range Usize) 32#usize
    (core.ops.index.IndexSliceTIInst U32 (core.ops.range.Range Usize)
    (core.slice.index.SliceIndexRangeUsizeSliceTInst U32)) x
    { start := y, end_ := z }

/- [array::array_subslice_mut_]: forward function -/
def array_subslice_mut_
  (x : Array U32 32#usize) (y : Usize) (z : Usize) : Result (Slice U32) :=
  core.array.Array.index_mut U32 (core.ops.range.Range Usize) 32#usize
    (core.ops.index.IndexMutSliceTIInst U32 (core.ops.range.Range Usize)
    (core.slice.index.SliceIndexRangeUsizeSliceTInst U32)) x
    { start := y, end_ := z }

/- [array::array_subslice_mut_]: backward function 0 -/
def array_subslice_mut__back
  (x : Array U32 32#usize) (y : Usize) (z : Usize) (ret0 : Slice U32) :
  Result (Array U32 32#usize)
  :=
  core.array.Array.index_mut_back U32 (core.ops.range.Range Usize) 32#usize
    (core.ops.index.IndexMutSliceTIInst U32 (core.ops.range.Range Usize)
    (core.slice.index.SliceIndexRangeUsizeSliceTInst U32)) x
    { start := y, end_ := z } ret0

/- [array::index_slice_0]: forward function -/
def index_slice_0 (T : Type) (s : Slice T) : Result T :=
  Slice.index_usize T s 0#usize

/- [array::index_array_0]: forward function -/
def index_array_0 (T : Type) (s : Array T 32#usize) : Result T :=
  Array.index_usize T 32#usize s 0#usize

/- [array::index_index_array]: forward function -/
def index_index_array
  (s : Array (Array U32 32#usize) 32#usize) (i : Usize) (j : Usize) :
  Result U32
  :=
  do
    let a ← Array.index_usize (Array U32 32#usize) 32#usize s i
    Array.index_usize U32 32#usize a j

/- [array::update_update_array]: forward function -/
def update_update_array
  (s : Array (Array U32 32#usize) 32#usize) (i : Usize) (j : Usize) :
  Result Unit
  :=
  do
    let a ← Array.index_usize (Array U32 32#usize) 32#usize s i
    let a0 ← Array.update_usize U32 32#usize a j 0#u32
    let _ ← Array.update_usize (Array U32 32#usize) 32#usize s i a0
    Result.ret ()

/- [array::array_local_deep_copy]: forward function -/
def array_local_deep_copy (x : Array U32 32#usize) : Result Unit :=
  Result.ret ()

/- [array::take_array]: forward function -/
def take_array (a : Array U32 2#usize) : Result Unit :=
  Result.ret ()

/- [array::take_array_borrow]: forward function -/
def take_array_borrow (a : Array U32 2#usize) : Result Unit :=
  Result.ret ()

/- [array::take_slice]: forward function -/
def take_slice (s : Slice U32) : Result Unit :=
  Result.ret ()

/- [array::take_mut_slice]: merged forward/backward function
   (there is a single backward function, and the forward function returns ()) -/
def take_mut_slice (s : Slice U32) : Result (Slice U32) :=
  Result.ret s

/- [array::take_all]: forward function -/
def take_all : Result Unit :=
  do
    let _ ← take_array (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let _ ← take_array_borrow (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let s ←
      Array.to_slice U32 2#usize (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let _ ← take_slice s
    let s0 ←
      Array.to_slice U32 2#usize (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let s1 ← take_mut_slice s0
    let _ ←
      Array.from_slice U32 2#usize (Array.make U32 2#usize [ 0#u32, 0#u32 ]) s1
    Result.ret ()

/- [array::index_array]: forward function -/
def index_array (x : Array U32 2#usize) : Result U32 :=
  Array.index_usize U32 2#usize x 0#usize

/- [array::index_array_borrow]: forward function -/
def index_array_borrow (x : Array U32 2#usize) : Result U32 :=
  Array.index_usize U32 2#usize x 0#usize

/- [array::index_slice_u32_0]: forward function -/
def index_slice_u32_0 (x : Slice U32) : Result U32 :=
  Slice.index_usize U32 x 0#usize

/- [array::index_mut_slice_u32_0]: forward function -/
def index_mut_slice_u32_0 (x : Slice U32) : Result U32 :=
  Slice.index_usize U32 x 0#usize

/- [array::index_mut_slice_u32_0]: backward function 0 -/
def index_mut_slice_u32_0_back (x : Slice U32) : Result (Slice U32) :=
  do
    let _ ← Slice.index_usize U32 x 0#usize
    Result.ret x

/- [array::index_all]: forward function -/
def index_all : Result U32 :=
  do
    let i ← index_array (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let i0 ← index_array (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let i1 ← i + i0
    let i2 ← index_array_borrow (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let i3 ← i1 + i2
    let s ←
      Array.to_slice U32 2#usize (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let i4 ← index_slice_u32_0 s
    let i5 ← i3 + i4
    let s0 ←
      Array.to_slice U32 2#usize (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let i6 ← index_mut_slice_u32_0 s0
    let i7 ← i5 + i6
    let s1 ← index_mut_slice_u32_0_back s0
    let _ ←
      Array.from_slice U32 2#usize (Array.make U32 2#usize [ 0#u32, 0#u32 ]) s1
    Result.ret i7

/- [array::update_array]: forward function -/
def update_array (x : Array U32 2#usize) : Result Unit :=
  do
    let _ ← Array.update_usize U32 2#usize x 0#usize 1#u32
    Result.ret ()

/- [array::update_array_mut_borrow]: merged forward/backward function
   (there is a single backward function, and the forward function returns ()) -/
def update_array_mut_borrow
  (x : Array U32 2#usize) : Result (Array U32 2#usize) :=
  Array.update_usize U32 2#usize x 0#usize 1#u32

/- [array::update_mut_slice]: merged forward/backward function
   (there is a single backward function, and the forward function returns ()) -/
def update_mut_slice (x : Slice U32) : Result (Slice U32) :=
  Slice.update_usize U32 x 0#usize 1#u32

/- [array::update_all]: forward function -/
def update_all : Result Unit :=
  do
    let _ ← update_array (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let x ← update_array_mut_borrow (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let s ← Array.to_slice U32 2#usize x
    let s0 ← update_mut_slice s
    let _ ← Array.from_slice U32 2#usize x s0
    Result.ret ()

/- [array::range_all]: forward function -/
def range_all : Result Unit :=
  do
    let s ←
      core.array.Array.index_mut U32 (core.ops.range.Range Usize) 4#usize
        (core.ops.index.IndexMutSliceTIInst U32 (core.ops.range.Range Usize)
        (core.slice.index.SliceIndexRangeUsizeSliceTInst U32))
        (Array.make U32 4#usize [ 0#u32, 0#u32, 0#u32, 0#u32 ])
        { start := 1#usize, end_ := 3#usize }
    let s0 ← update_mut_slice s
    let _ ←
      core.array.Array.index_mut_back U32 (core.ops.range.Range Usize) 4#usize
        (core.ops.index.IndexMutSliceTIInst U32 (core.ops.range.Range Usize)
        (core.slice.index.SliceIndexRangeUsizeSliceTInst U32))
        (Array.make U32 4#usize [ 0#u32, 0#u32, 0#u32, 0#u32 ])
        { start := 1#usize, end_ := 3#usize } s0
    Result.ret ()

/- [array::deref_array_borrow]: forward function -/
def deref_array_borrow (x : Array U32 2#usize) : Result U32 :=
  Array.index_usize U32 2#usize x 0#usize

/- [array::deref_array_mut_borrow]: forward function -/
def deref_array_mut_borrow (x : Array U32 2#usize) : Result U32 :=
  Array.index_usize U32 2#usize x 0#usize

/- [array::deref_array_mut_borrow]: backward function 0 -/
def deref_array_mut_borrow_back
  (x : Array U32 2#usize) : Result (Array U32 2#usize) :=
  do
    let _ ← Array.index_usize U32 2#usize x 0#usize
    Result.ret x

/- [array::take_array_t]: forward function -/
def take_array_t (a : Array AB 2#usize) : Result Unit :=
  Result.ret ()

/- [array::non_copyable_array]: forward function -/
def non_copyable_array : Result Unit :=
  do
    let _ ← take_array_t (Array.make AB 2#usize [ AB.A, AB.B ])
    Result.ret ()

/- [array::sum]: loop 0: forward function -/
divergent def sum_loop (s : Slice U32) (sum0 : U32) (i : Usize) : Result U32 :=
  let i0 := Slice.len U32 s
  if i < i0
  then
    do
      let i1 ← Slice.index_usize U32 s i
      let sum1 ← sum0 + i1
      let i2 ← i + 1#usize
      sum_loop s sum1 i2
  else Result.ret sum0

/- [array::sum]: forward function -/
def sum (s : Slice U32) : Result U32 :=
  sum_loop s 0#u32 0#usize

/- [array::sum2]: loop 0: forward function -/
divergent def sum2_loop
  (s : Slice U32) (s2 : Slice U32) (sum0 : U32) (i : Usize) : Result U32 :=
  let i0 := Slice.len U32 s
  if i < i0
  then
    do
      let i1 ← Slice.index_usize U32 s i
      let i2 ← Slice.index_usize U32 s2 i
      let i3 ← i1 + i2
      let sum1 ← sum0 + i3
      let i4 ← i + 1#usize
      sum2_loop s s2 sum1 i4
  else Result.ret sum0

/- [array::sum2]: forward function -/
def sum2 (s : Slice U32) (s2 : Slice U32) : Result U32 :=
  let i := Slice.len U32 s
  let i0 := Slice.len U32 s2
  if not (i = i0)
  then Result.fail Error.panic
  else sum2_loop s s2 0#u32 0#usize

/- [array::f0]: forward function -/
def f0 : Result Unit :=
  do
    let s ←
      Array.to_slice U32 2#usize (Array.make U32 2#usize [ 1#u32, 2#u32 ])
    let s0 ← Slice.update_usize U32 s 0#usize 1#u32
    let _ ←
      Array.from_slice U32 2#usize (Array.make U32 2#usize [ 1#u32, 2#u32 ]) s0
    Result.ret ()

/- [array::f1]: forward function -/
def f1 : Result Unit :=
  do
    let _ ←
      Array.update_usize U32 2#usize (Array.make U32 2#usize [ 1#u32, 2#u32 ])
        0#usize 1#u32
    Result.ret ()

/- [array::f2]: forward function -/
def f2 (i : U32) : Result Unit :=
  Result.ret ()

/- [array::f4]: forward function -/
def f4 (x : Array U32 32#usize) (y : Usize) (z : Usize) : Result (Slice U32) :=
  core.array.Array.index U32 (core.ops.range.Range Usize) 32#usize
    (core.ops.index.IndexSliceTIInst U32 (core.ops.range.Range Usize)
    (core.slice.index.SliceIndexRangeUsizeSliceTInst U32)) x
    { start := y, end_ := z }

/- [array::f3]: forward function -/
def f3 : Result U32 :=
  do
    let i ←
      Array.index_usize U32 2#usize (Array.make U32 2#usize [ 1#u32, 2#u32 ])
        0#usize
    let _ ← f2 i
    let b := Array.repeat U32 32#usize 0#u32
    let s ←
      Array.to_slice U32 2#usize (Array.make U32 2#usize [ 1#u32, 2#u32 ])
    let s0 ← f4 b 16#usize 18#usize
    sum2 s s0

/- [array::SZ] -/
def sz_body : Result Usize := Result.ret 32#usize
def sz_c : Usize := eval_global sz_body (by simp)

/- [array::f5]: forward function -/
def f5 (x : Array U32 32#usize) : Result U32 :=
  Array.index_usize U32 32#usize x 0#usize

/- [array::ite]: forward function -/
def ite : Result Unit :=
  do
    let s ←
      Array.to_slice U32 2#usize (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let s0 ←
      Array.to_slice U32 2#usize (Array.make U32 2#usize [ 0#u32, 0#u32 ])
    let s1 ← index_mut_slice_u32_0_back s0
    let _ ←
      Array.from_slice U32 2#usize (Array.make U32 2#usize [ 0#u32, 0#u32 ]) s1
    let s2 ← index_mut_slice_u32_0_back s
    let _ ←
      Array.from_slice U32 2#usize (Array.make U32 2#usize [ 0#u32, 0#u32 ]) s2
    Result.ret ()

end array
