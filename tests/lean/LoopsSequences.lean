-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [loops_sequences]
import Aeneas
open Aeneas Aeneas.Std Result ControlFlow Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

/- You can set the `maxHeartbeats` value with the `-max-heartbeats` CLI option -/
set_option maxHeartbeats 1000000

namespace loops_sequences

/- [loops_sequences::Key]
   Source: 'tests/src/loops-sequences.rs', lines 3:0-6:1 -/
structure Key where
  seed : Array Std.U8 32#usize
  t : Array Std.U16 32#usize

/- [loops_sequences::{loops_sequences::Key}::t_mut]:
   Source: 'tests/src/loops-sequences.rs', lines 9:4-11:5 -/
def Key.t_mut
  (self : Key) :
  Result ((Array Std.U16 32#usize) × (Array Std.U16 32#usize → Key))
  := do
  let back := fun a => { self with t := a }
  ok (self.t, back)

/- [loops_sequences::shake_init]:
   Source: 'tests/src/loops-sequences.rs', lines 16:0-16:40 -/
def shake_init
  (_state : Array Std.U8 8#usize) : Result (Array Std.U8 8#usize) := do
  ok _state

/- [loops_sequences::shake_append]:
   Source: 'tests/src/loops-sequences.rs', lines 17:0-17:56 -/
def shake_append
  (_state : Array Std.U8 8#usize) (_data : Slice Std.U8) :
  Result (Array Std.U8 8#usize)
  := do
  ok _state

/- [loops_sequences::shake_state_copy]:
   Source: 'tests/src/loops-sequences.rs', lines 18:0-18:62 -/
def shake_state_copy
  (_src : Array Std.U8 8#usize) (_dst : Array Std.U8 8#usize) :
  Result (Array Std.U8 8#usize)
  := do
  ok _dst

/- [loops_sequences::shake_extract]:
   Source: 'tests/src/loops-sequences.rs', lines 19:0-19:54 -/
def shake_extract
  (_src : Array Std.U8 8#usize) (_dst : Slice Std.U8) :
  Result (Slice Std.U8)
  := do
  ok _dst

/- [loops_sequences::sample_cbd]:
   Source: 'tests/src/loops-sequences.rs', lines 21:0-21:51 -/
def sample_cbd
  (_src : Slice Std.U8) (_dst : Array Std.U16 32#usize) :
  Result (Array Std.U16 32#usize)
  := do
  ok _dst

/- [loops_sequences::key_expand]: loop 0:
   Source: 'tests/src/loops-sequences.rs', lines 29:4-36:5 -/
def key_expand_loop0
  (key : Key) (state_base : Array Std.U8 8#usize)
  (state_work : Array Std.U8 8#usize) (sample_buffer : Array Std.U8 1#usize)
  (i : Std.I32) :
  Result (Key × (Array Std.U8 8#usize) × (Array Std.U8 1#usize))
  := do
  loop
    (fun (key1, state_work1, sample_buffer1, i1) =>
      if i1 < 32#i32
      then
        do
        let i2 ← lift (IScalar.hcast .U8 i1)
        let sample_buffer2 ← Array.update sample_buffer1 0#usize i2
        let state_work2 ← shake_state_copy state_base state_work1
        let s ← lift (Array.to_slice sample_buffer2)
        let state_work3 ← shake_append state_work2 s
        let (s1, to_slice_mut_back) ←
          lift (Array.to_slice_mut sample_buffer2)
        let s2 ← shake_extract state_work3 s1
        let s3 ← lift (Array.to_slice state_work3)
        let (a, t_mut_back) ← Key.t_mut key1
        let a1 ← sample_cbd s3 a
        let i3 ← i1 + 1#i32
        let key2 := t_mut_back a1
        let sample_buffer3 := to_slice_mut_back s2
        ok (cont (key2, state_work3, sample_buffer3, i3))
      else ok (done (key1, state_work1, sample_buffer1)))
    (key, state_work, sample_buffer, i)

/- [loops_sequences::key_expand]: loop 1:
   Source: 'tests/src/loops-sequences.rs', lines 39:4-46:5 -/
def key_expand_loop1
  (key : Key) (state_base : Array Std.U8 8#usize)
  (state_work : Array Std.U8 8#usize) (sample_buffer : Array Std.U8 1#usize)
  (i : Std.I32) :
  Result (Key × (Array Std.U8 8#usize))
  := do
  loop
    (fun (key1, state_work1, sample_buffer1, i1) =>
      if i1 < 32#i32
      then
        do
        let i2 ← lift (IScalar.hcast .U8 i1)
        let sample_buffer2 ← Array.update sample_buffer1 0#usize i2
        let state_work2 ← shake_state_copy state_base state_work1
        let s ← lift (Array.to_slice sample_buffer2)
        let state_work3 ← shake_append state_work2 s
        let (s1, to_slice_mut_back) ←
          lift (Array.to_slice_mut sample_buffer2)
        let s2 ← shake_extract state_work3 s1
        let s3 ← lift (Array.to_slice state_work3)
        let (a, t_mut_back) ← Key.t_mut key1
        let a1 ← sample_cbd s3 a
        let i3 ← i1 + 1#i32
        let key2 := t_mut_back a1
        let sample_buffer3 := to_slice_mut_back s2
        ok (cont (key2, state_work3, sample_buffer3, i3))
      else ok (done (key1, state_work1)))
    (key, state_work, sample_buffer, i)

/- [loops_sequences::key_expand]:
   Source: 'tests/src/loops-sequences.rs', lines 23:0-47:1 -/
def key_expand
  (key : Key) (state_base : Array Std.U8 8#usize)
  (state_work : Array Std.U8 8#usize) :
  Result (Key × (Array Std.U8 8#usize) × (Array Std.U8 8#usize))
  := do
  let state_base1 ← shake_init state_base
  let s ← lift (Array.to_slice key.seed)
  let state_base2 ← shake_append state_base1 s
  let (key1, state_work1, sample_buffer) ←
    key_expand_loop0 key state_base2 state_work (Array.make 1#usize [ 0#u8 ])
      0#i32
  let (key2, state_work2) ←
    key_expand_loop1 key1 state_base2 state_work1 sample_buffer 0#i32
  ok (key2, state_base2, state_work2)

end loops_sequences
