-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [loops_issues]
import Aeneas
open Aeneas Aeneas.Std Result ControlFlow Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace loops_issues

/- [loops_issues::write]:
   Source: 'tests/src/loops-issues.rs', lines 5:0-5:28 -/
def write (a : Array Std.U8 4#usize) : Result (Array Std.U8 4#usize) := do
  ok a

/- [loops_issues::read]:
   Source: 'tests/src/loops-issues.rs', lines 8:0-8:23 -/
def read (a : Array Std.U8 4#usize) : Result Unit := do
  ok ()

/- [loops_issues::CARRAY]
   Source: 'tests/src/loops-issues.rs', lines 10:0-10:38 -/
@[global_simps, irreducible]
def CARRAY : Array Std.U16 4#usize := Array.repeat 4#usize 0#u16

/- [loops_issues::loop_access_array]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 15:4-18:5 -/
def loop_access_array_loop
  (k : Std.Usize) (start : Std.Usize) : Result Unit := do
  loop
    (fun start1 =>
      if start1 < 4#usize
      then
        do
        massert (k < 4#usize)
        let start2 ← start1 + 1#usize
        ok (cont start2)
      else ok (done ()))
    start

/- [loops_issues::loop_access_array]:
   Source: 'tests/src/loops-issues.rs', lines 13:0-19:1 -/
@[reducible]
def loop_access_array (k : Std.Usize) : Result Unit := do
  loop_access_array_loop k 0#usize

/- [loops_issues::loop_array_len]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 26:4-28:5 -/
def loop_array_len_loop (b : Bool) : Result Unit := do
  loop
    (fun b1 => if b1
               then ok (cont true)
               else ok (done ()))
    b

/- [loops_issues::loop_array_len]:
   Source: 'tests/src/loops-issues.rs', lines 22:0-29:1 -/
@[reducible]
def loop_array_len (b : Bool) : Result Unit := do
  loop_array_len_loop b

/- [loops_issues::loop_array_len_write]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 36:4-40:5 -/
def loop_array_len_write_loop
  (b0 : Bool) (b1 : Bool) (buf : Array Std.U8 4#usize) : Result Unit := do
  loop
    (fun (b01, b11, buf1) =>
      if b01
      then
        if b11
        then do
             let buf2 ← write buf1
             ok (cont (true, true, buf2))
        else ok (cont (true, false, buf1))
      else ok (done ()))
    (b0, b1, buf)

/- [loops_issues::loop_array_len_write]:
   Source: 'tests/src/loops-issues.rs', lines 32:0-41:1 -/
def loop_array_len_write (b0 : Bool) (b1 : Bool) : Result Unit := do
  let buf := Array.repeat 4#usize 0#u8
  loop_array_len_write_loop b0 b1 buf

/- [loops_issues::MAX_NROWS]
   Source: 'tests/src/loops-issues.rs', lines 43:0-43:27 -/
@[global_simps, irreducible] def MAX_NROWS : Std.Usize := 4#usize

/- [loops_issues::read_global_loop]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 48:4-48:14 -/
def read_global_loop_loop (b : Bool) : Result Unit := do
  loop
    (fun b1 => if b1
               then ok (cont true)
               else ok (done ()))
    b

/- [loops_issues::read_global_loop]:
   Source: 'tests/src/loops-issues.rs', lines 46:0-49:1 -/
def read_global_loop (b : Bool) (n_rows : Std.Usize) : Result Unit := do
  massert (n_rows <= MAX_NROWS)
  read_global_loop_loop b

/- [loops_issues::mut_loop_len]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 55:10-55:11 -/
def mut_loop_len_loop
  (b : Bool) (buf : Array Std.U8 4#usize) : Result Unit := do
  loop
    (fun b1 =>
      if b1
      then
        do
        let s ← (↑(Array.to_slice buf) : Result (Slice Std.U8))
        let i := Slice.len s
        if 0#usize <= i
        then ok (cont true)
        else fail panic
      else ok (done ()))
    b

/- [loops_issues::mut_loop_len]:
   Source: 'tests/src/loops-issues.rs', lines 52:0-58:1 -/
def mut_loop_len (i : Std.U32) (b : Bool) : Result Std.U32 := do
  let buf := Array.repeat 4#usize 0#u8
  mut_loop_len_loop b buf
  ok i

/- [loops_issues::test]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 65:4-71:5 -/
def test_loop
  (b0 : Bool) (b1 : Bool) (buf : Array Std.U8 4#usize) : Result Unit := do
  loop
    (fun (b01, buf1) =>
      if b01
      then
        do
        let buf2 ← if b1
                     then write buf1
                     else ok buf1
        read buf2
        ok (cont (true, buf2))
      else ok (done ()))
    (b0, buf)

/- [loops_issues::test]:
   Source: 'tests/src/loops-issues.rs', lines 61:0-72:1 -/
def test (b0 : Bool) (b1 : Bool) : Result Unit := do
  let buf := Array.repeat 4#usize 0#u8
  test_loop b0 b1 buf

end loops_issues
