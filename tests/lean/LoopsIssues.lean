-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [loops_issues]
import Aeneas
open Aeneas Aeneas.Std Result ControlFlow Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

/- You can set the `maxHeartbeats` value with the `-max-heartbeats` CLI option -/
set_option maxHeartbeats 1000000

/- You can remove the following line by using the CLI option `-all-computable`: -/
noncomputable section

namespace loops_issues

/- [core::iter::range::{core::iter::range::Step for i32}::backward_checked]:
   Source: '/rustc/library/core/src/iter/range.rs', lines 333:16-333:74
   Name pattern: [core::iter::range::{core::iter::range::Step<i32>}::backward_checked] -/
@[rust_fun
  "core::iter::range::{core::iter::range::Step<i32>}::backward_checked"]
axiom I32.Insts.CoreIterRangeStep.backward_checked
  : Std.I32 → Std.Usize → Result (Option Std.I32)

/- [core::iter::range::{core::iter::range::Step for i32}::forward_checked]:
   Source: '/rustc/library/core/src/iter/range.rs', lines 312:16-312:73
   Name pattern: [core::iter::range::{core::iter::range::Step<i32>}::forward_checked] -/
@[rust_fun
  "core::iter::range::{core::iter::range::Step<i32>}::forward_checked"]
axiom I32.Insts.CoreIterRangeStep.forward_checked
  : Std.I32 → Std.Usize → Result (Option Std.I32)

/- [core::iter::range::{core::iter::range::Step for i32}::steps_between]:
   Source: '/rustc/library/core/src/iter/range.rs', lines 297:16-297:84
   Name pattern: [core::iter::range::{core::iter::range::Step<i32>}::steps_between] -/
@[rust_fun "core::iter::range::{core::iter::range::Step<i32>}::steps_between"]
axiom I32.Insts.CoreIterRangeStep.steps_between
  : Std.I32 → Std.I32 → Result (Std.Usize × (Option Std.Usize))

/- Trait implementation: [core::iter::range::{core::iter::range::Step for i32}]
   Source: '/rustc/library/core/src/iter/range.rs', lines 292:12-292:37
   Name pattern: [core::iter::range::Step<i32>] -/
@[reducible, rust_trait_impl "core::iter::range::Step<i32>"]
def I32.Insts.CoreIterRangeStep : core.iter.range.Step Std.I32 := {
  cloneInst := core.clone.CloneI32
  partialOrdInst := core.cmp.PartialOrdI32
  steps_between := I32.Insts.CoreIterRangeStep.steps_between
  forward_checked := I32.Insts.CoreIterRangeStep.forward_checked
  backward_checked := I32.Insts.CoreIterRangeStep.backward_checked
}

/- [loops_issues::write]:
   Source: 'tests/src/loops-issues.rs', lines 5:0-5:28 -/
def write (a : Array Std.U8 4#usize) : Result (Array Std.U8 4#usize) := do
  ok a

/- [loops_issues::read]:
   Source: 'tests/src/loops-issues.rs', lines 8:0-8:23 -/
def read (a : Array Std.U8 4#usize) : Result Unit := do
  ok ()

/- [loops_issues::CARRAY]
   Source: 'tests/src/loops-issues.rs', lines 10:0-10:38 -/
@[global_simps, irreducible]
def CARRAY : Array Std.U16 4#usize := Array.repeat 4#usize 0#u16

/- [loops_issues::loop_access_array]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 15:4-18:5 -/
def loop_access_array_loop
  (k : Std.Usize) (start : Std.Usize) : Result Unit := do
  loop
    (fun start1 =>
      if start1 < 4#usize
      then
        do
        let _ ← Array.index_usize CARRAY k
        let start2 ← start1 + 1#usize
        ok (cont start2)
      else ok (done ()))
    start

/- [loops_issues::loop_access_array]:
   Source: 'tests/src/loops-issues.rs', lines 13:0-19:1 -/
@[reducible]
def loop_access_array (k : Std.Usize) : Result Unit := do
  loop_access_array_loop k 0#usize

/- [loops_issues::loop_array_len]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 26:4-28:5 -/
def loop_array_len_loop (b : Bool) : Result Unit := do
  loop
    (fun b1 => if b1
               then ok (cont true)
               else ok (done ()))
    b

/- [loops_issues::loop_array_len]:
   Source: 'tests/src/loops-issues.rs', lines 22:0-29:1 -/
@[reducible]
def loop_array_len (b : Bool) : Result Unit := do
  loop_array_len_loop b

/- [loops_issues::loop_array_len_write]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 36:4-40:5 -/
def loop_array_len_write_loop
  (b0 : Bool) (b1 : Bool) (buf : Array Std.U8 4#usize) : Result Unit := do
  loop
    (fun (b01, b11, buf1) =>
      if b01
      then
        if b11
        then do
             let buf2 ← write buf1
             ok (cont (true, true, buf2))
        else ok (cont (true, false, buf1))
      else ok (done ()))
    (b0, b1, buf)

/- [loops_issues::loop_array_len_write]:
   Source: 'tests/src/loops-issues.rs', lines 32:0-41:1 -/
def loop_array_len_write (b0 : Bool) (b1 : Bool) : Result Unit := do
  let buf := Array.repeat 4#usize 0#u8
  loop_array_len_write_loop b0 b1 buf

/- [loops_issues::MAX_NROWS]
   Source: 'tests/src/loops-issues.rs', lines 43:0-43:27 -/
@[global_simps, irreducible] def MAX_NROWS : Std.Usize := 4#usize

/- [loops_issues::read_global_loop]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 48:4-48:14 -/
def read_global_loop_loop (b : Bool) : Result Unit := do
  loop
    (fun b1 => if b1
               then ok (cont true)
               else ok (done ()))
    b

/- [loops_issues::read_global_loop]:
   Source: 'tests/src/loops-issues.rs', lines 46:0-49:1 -/
def read_global_loop (b : Bool) (n_rows : Std.Usize) : Result Unit := do
  massert (n_rows <= MAX_NROWS)
  read_global_loop_loop b

/- [loops_issues::mut_loop_len]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 55:10-55:11 -/
def mut_loop_len_loop
  (b : Bool) (buf : Array Std.U8 4#usize) : Result Unit := do
  loop
    (fun b1 =>
      if b1
      then
        do
        let s ← lift (Array.to_slice buf)
        let i := Slice.len s
        if 0#usize <= i
        then ok (cont true)
        else fail panic
      else ok (done ()))
    b

/- [loops_issues::mut_loop_len]:
   Source: 'tests/src/loops-issues.rs', lines 52:0-58:1 -/
def mut_loop_len (i : Std.U32) (b : Bool) : Result Std.U32 := do
  let buf := Array.repeat 4#usize 0#u8
  mut_loop_len_loop b buf
  ok i

/- [loops_issues::test]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 65:4-71:5 -/
def test_loop
  (b0 : Bool) (b1 : Bool) (buf : Array Std.U8 4#usize) : Result Unit := do
  loop
    (fun (b01, buf1) =>
      if b01
      then
        do
        let buf2 ← if b1
                     then write buf1
                     else ok buf1
        read buf2
        ok (cont (true, buf2))
      else ok (done ()))
    (b0, buf)

/- [loops_issues::test]:
   Source: 'tests/src/loops-issues.rs', lines 61:0-72:1 -/
def test (b0 : Bool) (b1 : Bool) : Result Unit := do
  let buf := Array.repeat 4#usize 0#u8
  test_loop b0 b1 buf

/- [loops_issues::WrapperU32]
   Source: 'tests/src/loops-issues.rs', lines 74:0-76:1 -/
structure WrapperU32 where
  x : Std.U32

/- [loops_issues::consume_u32]:
   Source: 'tests/src/loops-issues.rs', lines 78:0-78:27 -/
def consume_u32 (eta : Std.U32) : Result Unit := do
  ok ()

/- [loops_issues::loop_consume_u32]: loop 0:
   Source: 'tests/src/loops-issues.rs', lines 84:4-86:5 -/
def loop_consume_u32_loop
  (params : WrapperU32) (iter : core.ops.range.Range Std.I32) :
  Result Unit
  := do
  loop
    (fun iter1 =>
      do
      let (o, iter2) ←
        core.iter.range.IteratorRange.next I32.Insts.CoreIterRangeStep iter1
      match o with
      | none => ok (done ())
      | some _ => consume_u32 params.x
                  ok (cont iter2))
    iter

/- [loops_issues::loop_consume_u32]:
   Source: 'tests/src/loops-issues.rs', lines 81:0-87:1 -/
@[reducible]
def loop_consume_u32 (params : WrapperU32) : Result Unit := do
  loop_consume_u32_loop params { start := 0#i32, «end» := 32#i32 }

end loops_issues
