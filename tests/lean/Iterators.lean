-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [iterators]
import Aeneas
open Aeneas Aeneas.Std Result ControlFlow Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

/- You can set the `maxHeartbeats` value with the `-max-heartbeats` CLI option -/
set_option maxHeartbeats 1000000

namespace iterators

/- [iterators::iter_range]: loop 0:
   Source: 'tests/src/iterators.rs', lines 5:4-5:28 -/
def iter_range_loop (iter : core.ops.range.Range Std.Usize) : Result Unit := do
  loop
    (fun iter1 =>
      do
      let (o, iter2) ←
        core.iter.range.IteratorRange.next core.iter.range.StepUsize iter1
      match o with
      | none => ok (done ())
      | some _ => ok (cont iter2))
    iter

/- [iterators::iter_range]:
   Source: 'tests/src/iterators.rs', lines 4:0-6:1 -/
@[reducible]
def iter_range : Result Unit := do
  iter_range_loop { start := 0#usize, «end» := 32#usize }

/- [iterators::iter_range_step_by]: loop 0:
   Source: 'tests/src/iterators.rs', lines 9:4-9:33 -/
def iter_range_step_by_loop
  (iter : core.iter.adapters.step_by.StepBy (core.ops.range.Range Std.Usize)) :
  Result Unit
  := do
  loop
    (fun iter1 =>
      do
      let (o, iter2) ←
        core.iter.adapters.step_by.IteratorStepBy.next
          (core.iter.traits.iterator.IteratorRange core.iter.range.StepUsize)
          iter1
      match o with
      | none => ok (done ())
      | some _ => ok (cont iter2))
    iter

/- [iterators::iter_range_step_by]:
   Source: 'tests/src/iterators.rs', lines 8:0-10:1 -/
def iter_range_step_by (n : Std.Usize) : Result Unit := do
  let iter ←
    core.iter.range.IteratorRange.step_by core.iter.range.StepUsize
      { start := 0#usize, «end» := n } 2#usize
  iter_range_step_by_loop iter

/- [iterators::slice_iter_mut_while]: loop 1:
   Source: 'tests/src/iterators.rs', lines 15:8-15:18 -/
def slice_iter_mut_while_loop0_loop0 (b : Bool) : Result Unit := do
  loop
    (fun b1 => if b1
               then ok (cont true)
               else ok (done ()))
    b

/- [iterators::slice_iter_mut_while]: loop 0:
   Source: 'tests/src/iterators.rs', lines 14:4-16:5 -/
def slice_iter_mut_while_loop0
  (back : core.slice.iter.IterMut Std.U16 → core.slice.iter.IterMut Std.U16)
  (b : Bool) (it : core.slice.iter.IterMut Std.U16) :
  Result (core.slice.iter.IterMut Std.U16)
  := do
  loop
    (fun (back1, b1, it1) =>
      do
      let (o, it2, next_back) ← core.slice.iter.IteratorIterMut.next it1
      match o with
      | none => ok (done (let im := next_back it2 none
                          back1 im))
      | some _ =>
        slice_iter_mut_while_loop0_loop0 b1
        ok (cont (fun im => let im1 := next_back im o
                            back1 im1, false, it2)))
    (back, b, it)

/- [iterators::slice_iter_mut_while]:
   Source: 'tests/src/iterators.rs', lines 12:0-17:1 -/
def slice_iter_mut_while
  (b : Bool) (s : Slice Std.U16) : Result (Slice Std.U16) := do
  let (it, iter_mut_back) ← core.slice.Slice.iter_mut s
  let back ← slice_iter_mut_while_loop0 (fun im => im) b it
  ok (iter_mut_back back)

/- [iterators::slice_iter_while]: loop 1:
   Source: 'tests/src/iterators.rs', lines 22:8-22:18 -/
def slice_iter_while_loop0_loop0 (b : Bool) : Result Unit := do
  loop
    (fun b1 => if b1
               then ok (cont true)
               else ok (done ()))
    b

/- [iterators::slice_iter_while]: loop 0:
   Source: 'tests/src/iterators.rs', lines 21:4-23:5 -/
def slice_iter_while_loop0
  (b : Bool) (it : core.slice.iter.Iter Std.U16) : Result Unit := do
  loop
    (fun (b1, it1) =>
      do
      let (o, it2) ← core.slice.iter.IteratorSliceIter.next it1
      match o with
      | none => ok (done ())
      | some _ => slice_iter_while_loop0_loop0 b1
                  ok (cont (false, it2)))
    (b, it)

/- [iterators::slice_iter_while]:
   Source: 'tests/src/iterators.rs', lines 19:0-24:1 -/
def slice_iter_while (b : Bool) (s : Slice Std.U16) : Result Unit := do
  let it ← core.slice.Slice.iter s
  slice_iter_while_loop0 b it

/- [iterators::slice_iter_mut_while_early_return]: loop 1:
   Source: 'tests/src/iterators.rs', lines 29:8-29:18 -/
def slice_iter_mut_while_early_return_loop0_loop0
  (b : Bool) : Result Unit := do
  loop
    (fun b1 => if b1
               then ok (cont true)
               else ok (done ()))
    b

/- [iterators::slice_iter_mut_while_early_return]: loop 0:
   Source: 'tests/src/iterators.rs', lines 28:4-35:1 -/
def slice_iter_mut_while_early_return_loop0
  (back : core.slice.iter.IterMut Std.U16 → core.slice.iter.IterMut Std.U16)
  (b : Bool) (it : core.slice.iter.IterMut Std.U16) :
  Result (core.slice.iter.IterMut Std.U16)
  := do
  loop
    (fun (back1, b1, it1) =>
      do
      let (o, it2, next_back) ← core.slice.iter.IteratorIterMut.next it1
      match o with
      | none => ok (done (let im := next_back it2 none
                          back1 im))
      | some _ =>
        slice_iter_mut_while_early_return_loop0_loop0 b1
        ok (cont (fun im => let im1 := next_back im o
                            back1 im1, false, it2)))
    (back, b, it)

/- [iterators::slice_iter_mut_while_early_return]:
   Source: 'tests/src/iterators.rs', lines 26:0-35:1 -/
def slice_iter_mut_while_early_return
  (s : Array Std.U16 256#usize) (b : Bool) :
  Result (Array Std.U16 256#usize)
  := do
  let (s1, to_slice_mut_back) ← lift (Array.to_slice_mut s)
  let (it, iter_mut_back) ← core.slice.Slice.iter_mut s1
  let back ← slice_iter_mut_while_early_return_loop0 (fun im => im) b it
  let s2 := iter_mut_back back
  ok (to_slice_mut_back s2)

/- [iterators::slice_iter_mut_while_early_return_two_bools]: loop 1:
   Source: 'tests/src/iterators.rs', lines 40:8-40:19 -/
def slice_iter_mut_while_early_return_two_bools_loop0_loop0
  (b0 : Bool) : Result Unit := do
  loop
    (fun b01 => if b01
                then ok (cont true)
                else ok (done ()))
    b0

/- [iterators::slice_iter_mut_while_early_return_two_bools]: loop 0:
   Source: 'tests/src/iterators.rs', lines 39:4-46:1 -/
def slice_iter_mut_while_early_return_two_bools_loop0
  (back : core.slice.iter.IterMut Std.U16 → core.slice.iter.IterMut Std.U16)
  (b0 : Bool) (b1 : Bool) (it : core.slice.iter.IterMut Std.U16) :
  Result (core.slice.iter.IterMut Std.U16)
  := do
  loop
    (fun (back1, b01, b11, it1) =>
      do
      let (o, it2, next_back) ← core.slice.iter.IteratorIterMut.next it1
      match o with
      | none => ok (done (let im := next_back it2 none
                          back1 im))
      | some _ =>
        slice_iter_mut_while_early_return_two_bools_loop0_loop0 b01
        if b11
        then ok (done (let im := next_back it2 o
                       back1 im))
        else
          ok (cont (fun im => let im1 := next_back im o
                              back1 im1, false, false, it2)))
    (back, b0, b1, it)

/- [iterators::slice_iter_mut_while_early_return_two_bools]:
   Source: 'tests/src/iterators.rs', lines 37:0-46:1 -/
def slice_iter_mut_while_early_return_two_bools
  (s : Array Std.U16 256#usize) (b0 : Bool) (b1 : Bool) :
  Result (Array Std.U16 256#usize)
  := do
  let (s1, to_slice_mut_back) ← lift (Array.to_slice_mut s)
  let (it, iter_mut_back) ← core.slice.Slice.iter_mut s1
  let back ←
    slice_iter_mut_while_early_return_two_bools_loop0 (fun im => im) b0 b1 it
  let s2 := iter_mut_back back
  ok (to_slice_mut_back s2)

/- [iterators::slice_chunks_exact_iter]: loop 1:
   Source: 'tests/src/iterators.rs', lines 50:8-50:30 -/
def slice_chunks_exact_iter_loop0_loop0
  (iter : core.slice.iter.Iter Std.U128) : Result Unit := do
  loop
    (fun iter1 =>
      do
      let (o, iter2) ← core.slice.iter.IteratorSliceIter.next iter1
      match o with
      | none => ok (done ())
      | some _ => ok (cont iter2))
    iter

/- [iterators::slice_chunks_exact_iter]: loop 0:
   Source: 'tests/src/iterators.rs', lines 49:4-51:5 -/
def slice_chunks_exact_iter_loop0
  (key : Array Std.U128 128#usize) (iter : core.slice.iter.ChunksExact Std.U8)
  :
  Result Unit
  := do
  loop
    (fun iter1 =>
      do
      let (o, iter2) ← core.slice.iter.IteratorChunksExact.next iter1
      match o with
      | none => ok (done ())
      | some _ =>
        let s ← lift (Array.to_slice key)
        let iter3 ← core.slice.Slice.iter s
        slice_chunks_exact_iter_loop0_loop0 iter3
        ok (cont iter2))
    iter

/- [iterators::slice_chunks_exact_iter]:
   Source: 'tests/src/iterators.rs', lines 48:0-52:1 -/
def slice_chunks_exact_iter
  (key : Array Std.U128 128#usize) (data : Slice Std.U8) : Result Unit := do
  let iter ← core.slice.Slice.chunks_exact data 16#usize
  slice_chunks_exact_iter_loop0 key iter

/- [iterators::Key]
   Source: 'tests/src/iterators.rs', lines 54:0-54:24 -/
@[reducible]
def Key := Array Std.U128 128#usize

/- [iterators::key_iter_slice_iter]: loop 1:
   Source: 'tests/src/iterators.rs', lines 58:8-58:32 -/
def key_iter_slice_iter_loop0_loop0
  (iter : core.slice.iter.Iter Std.U128) : Result Unit := do
  loop
    (fun iter1 =>
      do
      let (o, iter2) ← core.slice.iter.IteratorSliceIter.next iter1
      match o with
      | none => ok (done ())
      | some _ => ok (cont iter2))
    iter

/- [iterators::key_iter_slice_iter]: loop 0:
   Source: 'tests/src/iterators.rs', lines 57:4-59:5 -/
def key_iter_slice_iter_loop0
  (key : Key) (iter : core.slice.iter.Iter Std.U8) : Result Unit := do
  loop
    (fun (key1, iter1) =>
      do
      let (o, iter2) ← core.slice.iter.IteratorSliceIter.next iter1
      match o with
      | none => ok (done ())
      | some _ =>
        let s ← lift (Array.to_slice key1)
        let iter3 ← core.slice.Slice.iter s
        key_iter_slice_iter_loop0_loop0 iter3
        ok (cont (key1, iter2)))
    (key, iter)

/- [iterators::key_iter_slice_iter]:
   Source: 'tests/src/iterators.rs', lines 56:0-60:1 -/
def key_iter_slice_iter (key : Key) (data : Slice Std.U8) : Result Unit := do
  let iter ← core.slice.Slice.iter data
  key_iter_slice_iter_loop0 key iter

end iterators
