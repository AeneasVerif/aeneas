-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [paper]
import Base.Primitives

structure OpaqueDefs where
  
  /- [paper::ref_incr] -/
  def ref_incr_fwd_back (x : Int32) : result Int32 :=
    Int32.checked_add x (Int32.ofNatCore 1 (by intlit))
  
  /- [paper::test_incr] -/
  def test_incr_fwd : result Unit :=
    do
      let x <- ref_incr_fwd_back (Int32.ofNatCore 0 (by intlit))
      if not (x = (Int32.ofNatCore 1 (by intlit)))
      then result.fail error.panic
      else result.ret ()
  
  /- Unit test for [paper::test_incr] -/
  #assert (test_incr_fwd = .ret ())
  
  /- [paper::choose] -/
  def choose_fwd (T : Type) (b : Bool) (x : T) (y : T) : result T :=
    if b
    then result.ret x
    else result.ret y
  
  /- [paper::choose] -/
  def choose_back
    (T : Type) (b : Bool) (x : T) (y : T) (ret0 : T) : result (T × T) :=
    if b
    then result.ret (ret0, y)
    else result.ret (x, ret0)
  
  /- [paper::test_choose] -/
  def test_choose_fwd : result Unit :=
    do
      let z <-
        choose_fwd Int32 true (Int32.ofNatCore 0 (by intlit))
          (Int32.ofNatCore 0 (by intlit))
      let z0 <- Int32.checked_add z (Int32.ofNatCore 1 (by intlit))
      if not (z0 = (Int32.ofNatCore 1 (by intlit)))
      then result.fail error.panic
      else
        do
          let (x, y) <-
            choose_back Int32 true (Int32.ofNatCore 0 (by intlit))
              (Int32.ofNatCore 0 (by intlit)) z0
          if not (x = (Int32.ofNatCore 1 (by intlit)))
          then result.fail error.panic
          else
            if not (y = (Int32.ofNatCore 0 (by intlit)))
            then result.fail error.panic
            else result.ret ()
  
  /- Unit test for [paper::test_choose] -/
  #assert (test_choose_fwd = .ret ())
  
  /- [paper::List] -/
  inductive list_t (T : Type) :=
  | ListCons : T -> list_t T -> list_t T
  | ListNil : list_t T
  
  /- [paper::list_nth_mut] -/
  def list_nth_mut_fwd (T : Type) (l : list_t T) (i : UInt32) : result T :=
    match l with
    | list_t.ListCons x tl =>
      if i = (UInt32.ofNatCore 0 (by intlit))
      then result.ret x
      else
        do
          let i0 <- UInt32.checked_sub i (UInt32.ofNatCore 1 (by intlit))
          list_nth_mut_fwd T tl i0
    | list_t.ListNil => result.fail error.panic
  
  /- [paper::list_nth_mut] -/
  def list_nth_mut_back
    (T : Type) (l : list_t T) (i : UInt32) (ret0 : T) : result (list_t T) :=
    match l with
    | list_t.ListCons x tl =>
      if i = (UInt32.ofNatCore 0 (by intlit))
      then result.ret (list_t.ListCons ret0 tl)
      else
        do
          let i0 <- UInt32.checked_sub i (UInt32.ofNatCore 1 (by intlit))
          let tl0 <- list_nth_mut_back T tl i0 ret0
          result.ret (list_t.ListCons x tl0)
    | list_t.ListNil => result.fail error.panic
  
  /- [paper::sum] -/
  def sum_fwd (l : list_t Int32) : result Int32 :=
    match l with
    | list_t.ListCons x tl => do
                                let i <- sum_fwd tl
                                Int32.checked_add x i
    | list_t.ListNil => result.ret (Int32.ofNatCore 0 (by intlit))
  
  /- [paper::test_nth] -/
  def test_nth_fwd : result Unit :=
    do
      let l := list_t.ListNil
      let l0 := list_t.ListCons (Int32.ofNatCore 3 (by intlit)) l
      let l1 := list_t.ListCons (Int32.ofNatCore 2 (by intlit)) l0
      let x <-
        list_nth_mut_fwd Int32 (list_t.ListCons (Int32.ofNatCore 1 (by intlit))
          l1) (UInt32.ofNatCore 2 (by intlit))
      let x0 <- Int32.checked_add x (Int32.ofNatCore 1 (by intlit))
      let l2 <-
        list_nth_mut_back Int32 (list_t.ListCons
          (Int32.ofNatCore 1 (by intlit)) l1) (UInt32.ofNatCore 2 (by intlit))
          x0
      let i <- sum_fwd l2
      if not (i = (Int32.ofNatCore 7 (by intlit)))
      then result.fail error.panic
      else result.ret ()
  
  /- Unit test for [paper::test_nth] -/
  #assert (test_nth_fwd = .ret ())
  
  /- [paper::call_choose] -/
  def call_choose_fwd (p : (UInt32 × UInt32)) : result UInt32 :=
    do
      let (px, py) := p
      let pz <- choose_fwd UInt32 true px py
      let pz0 <- UInt32.checked_add pz (UInt32.ofNatCore 1 (by intlit))
      let (px0, _) <- choose_back UInt32 true px py pz0
      result.ret px0
  
