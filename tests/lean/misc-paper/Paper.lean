-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [paper]
import Base.Primitives

/- [paper::ref_incr] -/
def ref_incr_fwd_back (x : I32) : Result I32 :=
  x + (I32.ofInt 1 (by intlit))

/- [paper::test_incr] -/
def test_incr_fwd : Result Unit :=
  do
    let x ‚üµ ref_incr_fwd_back (I32.ofInt 0 (by intlit))
    if ùíΩ: not (x = (I32.ofInt 1 (by intlit)))
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [paper::test_incr] -/
#assert (test_incr_fwd == .ret ())

/- [paper::choose] -/
def choose_fwd (T : Type) (b : Bool) (x : T) (y : T) : Result T :=
  if ùíΩ: b
  then Result.ret x
  else Result.ret y

/- [paper::choose] -/
def choose_back
  (T : Type) (b : Bool) (x : T) (y : T) (ret0 : T) : Result (T √ó T) :=
  if ùíΩ: b
  then Result.ret (ret0, y)
  else Result.ret (x, ret0)

/- [paper::test_choose] -/
def test_choose_fwd : Result Unit :=
  do
    let z ‚üµ
      choose_fwd I32 true (I32.ofInt 0 (by intlit)) (I32.ofInt 0 (by intlit))
    let z0 ‚üµ z + (I32.ofInt 1 (by intlit))
    if ùíΩ: not (z0 = (I32.ofInt 1 (by intlit)))
    then Result.fail Error.panic
    else
      do
        let (x, y) ‚üµ
          choose_back I32 true (I32.ofInt 0 (by intlit))
            (I32.ofInt 0 (by intlit)) z0
        if ùíΩ: not (x = (I32.ofInt 1 (by intlit)))
        then Result.fail Error.panic
        else
          if ùíΩ: not (y = (I32.ofInt 0 (by intlit)))
          then Result.fail Error.panic
          else Result.ret ()

/- Unit test for [paper::test_choose] -/
#assert (test_choose_fwd == .ret ())

/- [paper::List] -/
inductive list_t (T : Type) :=
| Cons : T -> list_t T -> list_t T
| Nil : list_t T

/- [paper::list_nth_mut] -/
def list_nth_mut_fwd (T : Type) (l : list_t T) (i : U32) : Result T :=
  match ùíΩ: l with
  | list_t.Cons x tl =>
    if ùíΩ: i = (U32.ofInt 0 (by intlit))
    then Result.ret x
    else
      do
        let i0 ‚üµ i - (U32.ofInt 1 (by intlit))
        let t ‚üµ list_nth_mut_fwd T tl i0
        Result.ret t
  | list_t.Nil => Result.fail Error.panic

/- [paper::list_nth_mut] -/
def list_nth_mut_back
  (T : Type) (l : list_t T) (i : U32) (ret0 : T) : Result (list_t T) :=
  match ùíΩ: l with
  | list_t.Cons x tl =>
    if ùíΩ: i = (U32.ofInt 0 (by intlit))
    then Result.ret (list_t.Cons ret0 tl)
    else
      do
        let i0 ‚üµ i - (U32.ofInt 1 (by intlit))
        let tl0 ‚üµ list_nth_mut_back T tl i0 ret0
        Result.ret (list_t.Cons x tl0)
  | list_t.Nil => Result.fail Error.panic

/- [paper::sum] -/
def sum_fwd (l : list_t I32) : Result I32 :=
  match ùíΩ: l with
  | list_t.Cons x tl => do
                          let i ‚üµ sum_fwd tl
                          x + i
  | list_t.Nil => Result.ret (I32.ofInt 0 (by intlit))

/- [paper::test_nth] -/
def test_nth_fwd : Result Unit :=
  do
    let l := list_t.Nil
    let l0 := list_t.Cons (I32.ofInt 3 (by intlit)) l
    let l1 := list_t.Cons (I32.ofInt 2 (by intlit)) l0
    let x ‚üµ
      list_nth_mut_fwd I32 (list_t.Cons (I32.ofInt 1 (by intlit)) l1)
        (U32.ofInt 2 (by intlit))
    let x0 ‚üµ x + (I32.ofInt 1 (by intlit))
    let l2 ‚üµ
      list_nth_mut_back I32 (list_t.Cons (I32.ofInt 1 (by intlit)) l1)
        (U32.ofInt 2 (by intlit)) x0
    let i ‚üµ sum_fwd l2
    if ùíΩ: not (i = (I32.ofInt 7 (by intlit)))
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [paper::test_nth] -/
#assert (test_nth_fwd == .ret ())

/- [paper::call_choose] -/
def call_choose_fwd (p : (U32 √ó U32)) : Result U32 :=
  do
    let (px, py) := p
    let pz ‚üµ choose_fwd U32 true px py
    let pz0 ‚üµ pz + (U32.ofInt 1 (by intlit))
    let (px0, _) ‚üµ choose_back U32 true px py pz0
    Result.ret px0

