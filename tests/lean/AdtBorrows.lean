-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [adt_borrows]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace adt_borrows

/- [adt_borrows::SharedWrapper]
   Source: 'tests/src/adt-borrows.rs', lines 7:0-7:35 -/
@[reducible] def SharedWrapper (T : Type) := T

/- [adt_borrows::{adt_borrows::SharedWrapper<'a, T>}::create]:
   Source: 'tests/src/adt-borrows.rs', lines 10:4-12:5 -/
def SharedWrapper.create {T : Type} (x : T) : Result (SharedWrapper T) :=
  ok x

/- [adt_borrows::{adt_borrows::SharedWrapper<'a, T>}::unwrap]:
   Source: 'tests/src/adt-borrows.rs', lines 14:4-16:5 -/
def SharedWrapper.unwrap {T : Type} (self : SharedWrapper T) : Result T :=
  ok self

/- [adt_borrows::use_shared_wrapper]:
   Source: 'tests/src/adt-borrows.rs', lines 19:0-24:1 -/
def use_shared_wrapper : Result Unit :=
  do
  let w ← SharedWrapper.create 0#i32
  let p ← SharedWrapper.unwrap w
  massert (0#i32 = p)

/- [adt_borrows::SharedWrapper1]
   Source: 'tests/src/adt-borrows.rs', lines 26:0-28:1 -/
structure SharedWrapper1 (T : Type) where
  x : T

/- [adt_borrows::{adt_borrows::SharedWrapper1<'a, T>}::create]:
   Source: 'tests/src/adt-borrows.rs', lines 31:4-33:5 -/
def SharedWrapper1.create {T : Type} (x : T) : Result (SharedWrapper1 T) :=
  ok { x }

/- [adt_borrows::{adt_borrows::SharedWrapper1<'a, T>}::unwrap]:
   Source: 'tests/src/adt-borrows.rs', lines 35:4-37:5 -/
def SharedWrapper1.unwrap {T : Type} (self : SharedWrapper1 T) : Result T :=
  ok self.x

/- [adt_borrows::use_shared_wrapper1]:
   Source: 'tests/src/adt-borrows.rs', lines 40:0-45:1 -/
def use_shared_wrapper1 : Result Unit :=
  do
  let w ← SharedWrapper1.create 0#i32
  let p ← SharedWrapper1.unwrap w
  massert (0#i32 = p)

/- [adt_borrows::SharedWrapper2]
   Source: 'tests/src/adt-borrows.rs', lines 47:0-50:1 -/
structure SharedWrapper2 (T : Type) where
  x : T
  y : T

/- [adt_borrows::{adt_borrows::SharedWrapper2<'a, 'b, T>}::create]:
   Source: 'tests/src/adt-borrows.rs', lines 53:4-55:5 -/
def SharedWrapper2.create
  {T : Type} (x : T) (y : T) : Result (SharedWrapper2 T) :=
  ok { x, y }

/- [adt_borrows::{adt_borrows::SharedWrapper2<'a, 'b, T>}::unwrap]:
   Source: 'tests/src/adt-borrows.rs', lines 57:4-59:5 -/
def SharedWrapper2.unwrap
  {T : Type} (self : SharedWrapper2 T) : Result (T × T) :=
  ok (self.x, self.y)

/- [adt_borrows::use_shared_wrapper2]:
   Source: 'tests/src/adt-borrows.rs', lines 62:0-69:1 -/
def use_shared_wrapper2 : Result Unit :=
  do
  let w ← SharedWrapper2.create 0#i32 1#i32
  let (px, py) ← SharedWrapper2.unwrap w
  massert (0#i32 = px)
  massert (1#i32 = py)

/- [adt_borrows::MutWrapper]
   Source: 'tests/src/adt-borrows.rs', lines 71:0-71:36 -/
@[reducible] def MutWrapper (T : Type) := T

/- [adt_borrows::{adt_borrows::MutWrapper<'a, T>}::create]:
   Source: 'tests/src/adt-borrows.rs', lines 74:4-76:5 -/
def MutWrapper.create
  {T : Type} (x : T) : Result ((MutWrapper T) × (MutWrapper T → T)) :=
  ok (x, fun ret => ret)

/- [adt_borrows::{adt_borrows::MutWrapper<'a, T>}::unwrap]:
   Source: 'tests/src/adt-borrows.rs', lines 78:4-80:5 -/
def MutWrapper.unwrap
  {T : Type} (self : MutWrapper T) : Result (T × (T → MutWrapper T)) :=
  let back := fun ret => ret
  ok (self, back)

/- [adt_borrows::{adt_borrows::MutWrapper<'a, T>}::id]:
   Source: 'tests/src/adt-borrows.rs', lines 82:4-84:5 -/
def MutWrapper.id
  {T : Type} (self : MutWrapper T) :
  Result ((MutWrapper T) × (MutWrapper T → MutWrapper T))
  :=
  let back := fun ret => ret
  ok (self, back)

/- [adt_borrows::use_mut_wrapper]:
   Source: 'tests/src/adt-borrows.rs', lines 87:0-93:1 -/
def use_mut_wrapper : Result Unit :=
  do
  let (w, create_back) ← MutWrapper.create 0#i32
  let (p, unwrap_back) ← MutWrapper.unwrap w
  let p1 ← p + 1#i32
  let x := create_back (unwrap_back p1)
  massert (x = 1#i32)

/- [adt_borrows::use_mut_wrapper_id]:
   Source: 'tests/src/adt-borrows.rs', lines 95:0-97:1 -/
def use_mut_wrapper_id
  {T : Type} (x : MutWrapper T) :
  Result ((MutWrapper T) × (MutWrapper T → MutWrapper T))
  :=
  do
  let (mw, id_back) ← MutWrapper.id x
  let back := fun ret => id_back ret
  ok (mw, back)

/- [adt_borrows::MutWrapper1]
   Source: 'tests/src/adt-borrows.rs', lines 99:0-101:1 -/
structure MutWrapper1 (T : Type) where
  x : T

/- [adt_borrows::{adt_borrows::MutWrapper1<'a, T>}::create]:
   Source: 'tests/src/adt-borrows.rs', lines 104:4-106:5 -/
def MutWrapper1.create
  {T : Type} (x : T) : Result ((MutWrapper1 T) × (MutWrapper1 T → T)) :=
  let back := fun ret => ret.x
  ok ({ x }, back)

/- [adt_borrows::{adt_borrows::MutWrapper1<'a, T>}::unwrap]:
   Source: 'tests/src/adt-borrows.rs', lines 108:4-110:5 -/
def MutWrapper1.unwrap
  {T : Type} (self : MutWrapper1 T) : Result (T × (T → MutWrapper1 T)) :=
  let back := fun ret => ({ x := ret } : MutWrapper1 T)
  ok (self.x, back)

/- [adt_borrows::{adt_borrows::MutWrapper1<'a, T>}::id]:
   Source: 'tests/src/adt-borrows.rs', lines 112:4-114:5 -/
def MutWrapper1.id
  {T : Type} (self : MutWrapper1 T) :
  Result ((MutWrapper1 T) × (MutWrapper1 T → MutWrapper1 T))
  :=
  ok (self, fun ret => ret)

/- [adt_borrows::use_mut_wrapper1]:
   Source: 'tests/src/adt-borrows.rs', lines 117:0-123:1 -/
def use_mut_wrapper1 : Result Unit :=
  do
  let (w, create_back) ← MutWrapper1.create 0#i32
  let (p, unwrap_back) ← MutWrapper1.unwrap w
  let p1 ← p + 1#i32
  let x := create_back (unwrap_back p1)
  massert (x = 1#i32)

/- [adt_borrows::use_mut_wrapper1_id]:
   Source: 'tests/src/adt-borrows.rs', lines 125:0-127:1 -/
def use_mut_wrapper1_id
  {T : Type} (x : MutWrapper1 T) :
  Result ((MutWrapper1 T) × (MutWrapper1 T → MutWrapper1 T))
  :=
  MutWrapper1.id x

/- [adt_borrows::MutWrapper2]
   Source: 'tests/src/adt-borrows.rs', lines 129:0-132:1 -/
structure MutWrapper2 (T : Type) where
  x : T
  y : T

/- [adt_borrows::{adt_borrows::MutWrapper2<'a, 'b, T>}::create]:
   Source: 'tests/src/adt-borrows.rs', lines 135:4-137:5 -/
def MutWrapper2.create
  {T : Type} (x : T) (y : T) :
  Result ((MutWrapper2 T) × (MutWrapper2 T → T) × (MutWrapper2 T → T))
  :=
  let back'a := fun ret => ret.x
  let back'b := fun ret => ret.y
  ok ({ x, y }, back'a, back'b)

/- [adt_borrows::{adt_borrows::MutWrapper2<'a, 'b, T>}::unwrap]:
   Source: 'tests/src/adt-borrows.rs', lines 139:4-141:5 -/
def MutWrapper2.unwrap
  {T : Type} (self : MutWrapper2 T) :
  Result ((T × T) × (T → MutWrapper2 T) × (T → MutWrapper2 T))
  :=
  let back'a := fun ret => { self with x := ret }
  let back'b := fun ret => { self with y := ret }
  ok ((self.x, self.y), back'a, back'b)

/- [adt_borrows::{adt_borrows::MutWrapper2<'a, 'b, T>}::id]:
   Source: 'tests/src/adt-borrows.rs', lines 143:4-145:5 -/
def MutWrapper2.id
  {T : Type} (self : MutWrapper2 T) :
  Result ((MutWrapper2 T) × (MutWrapper2 T → MutWrapper2 T) × (MutWrapper2
    T → MutWrapper2 T))
  :=
  let back'a := fun ret => { self with x := ret.x }
  let back'b := fun ret => { self with y := ret.y }
  ok (self, back'a, back'b)

/- [adt_borrows::use_mut_wrapper2]:
   Source: 'tests/src/adt-borrows.rs', lines 148:0-157:1 -/
def use_mut_wrapper2 : Result Unit :=
  do
  let (w, create_back, create_back1) ← MutWrapper2.create 0#i32 10#i32
  let (p, unwrap_back, unwrap_back1) ← MutWrapper2.unwrap w
  let (px, py) := p
  let px1 ← px + 1#i32
  let py1 ← py + 1#i32
  let x := create_back { w with x := (unwrap_back px1).x }
  massert (x = 1#i32)
  let y := create_back1 { w with y := (unwrap_back1 py1).y }
  massert (y = 11#i32)

/- [adt_borrows::use_mut_wrapper2_id]:
   Source: 'tests/src/adt-borrows.rs', lines 159:0-161:1 -/
def use_mut_wrapper2_id
  {T : Type} (x : MutWrapper2 T) :
  Result ((MutWrapper2 T) × (MutWrapper2 T → MutWrapper2 T) × (MutWrapper2
    T → MutWrapper2 T))
  :=
  do
  let (mw, id_back, id_back1) ← MutWrapper2.id x
  let back'a := fun ret => { x with x := (id_back { mw with x := ret.x }).x }
  let back'b := fun ret => { x with y := (id_back1 { mw with y := ret.y }).y }
  ok (mw, back'a, back'b)

/- [adt_borrows::array_shared_borrow]:
   Source: 'tests/src/adt-borrows.rs', lines 170:0-172:1 -/
def array_shared_borrow {N : Usize} (x : Array U32 N) : Result (Array U32 N) :=
  ok x

/- [adt_borrows::array_mut_borrow]:
   Source: 'tests/src/adt-borrows.rs', lines 174:0-176:1 -/
def array_mut_borrow
  {N : Usize} (x : Array U32 N) :
  Result ((Array U32 N) × (Array U32 N → Array U32 N))
  :=
  ok (x, fun ret => ret)

/- [adt_borrows::use_array_mut_borrow1]:
   Source: 'tests/src/adt-borrows.rs', lines 178:0-180:1 -/
def use_array_mut_borrow1
  {N : Usize} (x : Array U32 N) :
  Result ((Array U32 N) × (Array U32 N → Array U32 N))
  :=
  array_mut_borrow x

/- [adt_borrows::use_array_mut_borrow2]:
   Source: 'tests/src/adt-borrows.rs', lines 182:0-185:1 -/
def use_array_mut_borrow2
  {N : Usize} (x : Array U32 N) :
  Result ((Array U32 N) × (Array U32 N → Array U32 N))
  :=
  do
  let (x1, array_mut_borrow_back) ← array_mut_borrow x
  let (a, array_mut_borrow_back1) ← array_mut_borrow x1
  let back :=
    fun ret => let x2 := array_mut_borrow_back1 ret
               array_mut_borrow_back x2
  ok (a, back)

/- [adt_borrows::boxed_slice_shared_borrow]:
   Source: 'tests/src/adt-borrows.rs', lines 187:0-189:1 -/
def boxed_slice_shared_borrow (x : Slice U32) : Result (Slice U32) :=
  ok x

/- [adt_borrows::boxed_slice_mut_borrow]:
   Source: 'tests/src/adt-borrows.rs', lines 191:0-193:1 -/
def boxed_slice_mut_borrow
  (x : Slice U32) : Result ((Slice U32) × (Slice U32 → Slice U32)) :=
  ok (x, fun ret => ret)

/- [adt_borrows::use_boxed_slice_mut_borrow1]:
   Source: 'tests/src/adt-borrows.rs', lines 195:0-197:1 -/
def use_boxed_slice_mut_borrow1
  (x : Slice U32) : Result ((Slice U32) × (Slice U32 → Slice U32)) :=
  boxed_slice_mut_borrow x

/- [adt_borrows::use_boxed_slice_mut_borrow2]:
   Source: 'tests/src/adt-borrows.rs', lines 199:0-202:1 -/
def use_boxed_slice_mut_borrow2
  (x : Slice U32) : Result ((Slice U32) × (Slice U32 → Slice U32)) :=
  do
  let (x1, boxed_slice_mut_borrow_back) ← boxed_slice_mut_borrow x
  let (s, boxed_slice_mut_borrow_back1) ← boxed_slice_mut_borrow x1
  let back :=
    fun ret =>
      let s1 := boxed_slice_mut_borrow_back1 ret
      boxed_slice_mut_borrow_back s1
  ok (s, back)

/- [adt_borrows::SharedList]
   Source: 'tests/src/adt-borrows.rs', lines 207:0-210:1 -/
inductive SharedList (T : Type) where
| Nil : SharedList T
| Cons : T → SharedList T → SharedList T

/- [adt_borrows::{adt_borrows::SharedList<'a, T>}::push]:
   Source: 'tests/src/adt-borrows.rs', lines 214:4-216:5 -/
def SharedList.push
  {T : Type} (self : SharedList T) (x : T) : Result (SharedList T) :=
  ok (SharedList.Cons x self)

/- [adt_borrows::{adt_borrows::SharedList<'a, T>}::pop]:
   Source: 'tests/src/adt-borrows.rs', lines 218:4-224:5 -/
def SharedList.pop
  {T : Type} (self : SharedList T) : Result (T × (SharedList T)) :=
  match self with
  | SharedList.Nil => fail panic
  | SharedList.Cons hd tl => ok (hd, tl)

/- [adt_borrows::MutList]
   Source: 'tests/src/adt-borrows.rs', lines 227:0-230:1 -/
inductive MutList (T : Type) where
| Nil : MutList T
| Cons : T → MutList T → MutList T

/- [adt_borrows::{adt_borrows::MutList<'a, T>}::push]:
   Source: 'tests/src/adt-borrows.rs', lines 234:4-236:5 -/
def MutList.push
  {T : Type} (self : MutList T) (x : T) :
  Result ((MutList T) × (MutList T → ((MutList T) × T)))
  :=
  let back :=
    fun ret =>
      let (x1, ml) :=
        match ret with
        | MutList.Cons t ml1 => (t, ml1)
        | _ => (x, self)
      (ml, x1)
  ok (MutList.Cons x self, back)

/- [adt_borrows::{adt_borrows::MutList<'a, T>}::pop]:
   Source: 'tests/src/adt-borrows.rs', lines 238:4-244:5 -/
def MutList.pop
  {T : Type} (self : MutList T) :
  Result ((T × (MutList T)) × ((T × (MutList T)) → MutList T))
  :=
  match self with
  | MutList.Nil => fail panic
  | MutList.Cons hd tl =>
    let back := fun ret => let (t, ml) := ret
                           MutList.Cons t ml
    ok ((hd, tl), back)

/- [adt_borrows::wrap_shared_in_option]:
   Source: 'tests/src/adt-borrows.rs', lines 247:0-249:1 -/
def wrap_shared_in_option {T : Type} (x : T) : Result (Option T) :=
  ok (some x)

/- [adt_borrows::wrap_mut_in_option]:
   Source: 'tests/src/adt-borrows.rs', lines 251:0-253:1 -/
def wrap_mut_in_option
  {T : Type} (x : T) : Result ((Option T) × (Option T → T)) :=
  let back := fun ret => match ret with
                         | some t => t
                         | _ => x
  ok (some x, back)

end adt_borrows
