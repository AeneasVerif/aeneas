-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [adt_borrows]
import Base
open Primitives
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace adt_borrows

/- [adt_borrows::SharedWrapper]
   Source: 'tests/src/adt-borrows.rs', lines 7:0-7:35 -/
@[reducible] def SharedWrapper (T : Type) := T

/- [adt_borrows::{adt_borrows::SharedWrapper<'a, T>}::create]:
   Source: 'tests/src/adt-borrows.rs', lines 10:4-12:5 -/
def SharedWrapper.create {T : Type} (x : T) : Result (SharedWrapper T) :=
  Result.ok x

/- [adt_borrows::{adt_borrows::SharedWrapper<'a, T>}::unwrap]:
   Source: 'tests/src/adt-borrows.rs', lines 14:4-16:5 -/
def SharedWrapper.unwrap {T : Type} (self : SharedWrapper T) : Result T :=
  Result.ok self

/- [adt_borrows::use_shared_wrapper]:
   Source: 'tests/src/adt-borrows.rs', lines 19:0-24:1 -/
def use_shared_wrapper : Result Unit :=
  do
  let w ← SharedWrapper.create 0#i32
  let p ← SharedWrapper.unwrap w
  massert (0#i32 = p)

/- [adt_borrows::SharedWrapper1]
   Source: 'tests/src/adt-borrows.rs', lines 26:0-28:1 -/
structure SharedWrapper1 (T : Type) where
  x : T

/- [adt_borrows::{adt_borrows::SharedWrapper1<'a, T>}#1::create]:
   Source: 'tests/src/adt-borrows.rs', lines 31:4-33:5 -/
def SharedWrapper1.create {T : Type} (x : T) : Result (SharedWrapper1 T) :=
  Result.ok { x }

/- [adt_borrows::{adt_borrows::SharedWrapper1<'a, T>}#1::unwrap]:
   Source: 'tests/src/adt-borrows.rs', lines 35:4-37:5 -/
def SharedWrapper1.unwrap {T : Type} (self : SharedWrapper1 T) : Result T :=
  Result.ok self.x

/- [adt_borrows::use_shared_wrapper1]:
   Source: 'tests/src/adt-borrows.rs', lines 40:0-45:1 -/
def use_shared_wrapper1 : Result Unit :=
  do
  let w ← SharedWrapper1.create 0#i32
  let p ← SharedWrapper1.unwrap w
  massert (0#i32 = p)

/- [adt_borrows::SharedWrapper2]
   Source: 'tests/src/adt-borrows.rs', lines 47:0-50:1 -/
structure SharedWrapper2 (T : Type) where
  x : T
  y : T

/- [adt_borrows::{adt_borrows::SharedWrapper2<'a, 'b, T>}#2::create]:
   Source: 'tests/src/adt-borrows.rs', lines 53:4-55:5 -/
def SharedWrapper2.create
  {T : Type} (x : T) (y : T) : Result (SharedWrapper2 T) :=
  Result.ok { x, y }

/- [adt_borrows::{adt_borrows::SharedWrapper2<'a, 'b, T>}#2::unwrap]:
   Source: 'tests/src/adt-borrows.rs', lines 57:4-59:5 -/
def SharedWrapper2.unwrap
  {T : Type} (self : SharedWrapper2 T) : Result (T × T) :=
  Result.ok (self.x, self.y)

/- [adt_borrows::use_shared_wrapper2]:
   Source: 'tests/src/adt-borrows.rs', lines 62:0-69:1 -/
def use_shared_wrapper2 : Result Unit :=
  do
  let w ← SharedWrapper2.create 0#i32 1#i32
  let p ← SharedWrapper2.unwrap w
  let (px, py) := p
  massert (0#i32 = px)
  massert (1#i32 = py)

/- [adt_borrows::MutWrapper]
   Source: 'tests/src/adt-borrows.rs', lines 71:0-71:36 -/
@[reducible] def MutWrapper (T : Type) := T

/- [adt_borrows::{adt_borrows::MutWrapper<'a, T>}#3::create]:
   Source: 'tests/src/adt-borrows.rs', lines 74:4-76:5 -/
def MutWrapper.create
  {T : Type} (x : T) : Result ((MutWrapper T) × (MutWrapper T → T)) :=
  Result.ok (x, fun ret => ret)

/- [adt_borrows::{adt_borrows::MutWrapper<'a, T>}#3::unwrap]:
   Source: 'tests/src/adt-borrows.rs', lines 78:4-80:5 -/
def MutWrapper.unwrap
  {T : Type} (self : MutWrapper T) : Result (T × (T → MutWrapper T)) :=
  let back := fun ret => ret
  Result.ok (self, back)

/- [adt_borrows::use_mut_wrapper]:
   Source: 'tests/src/adt-borrows.rs', lines 83:0-89:1 -/
def use_mut_wrapper : Result Unit :=
  do
  let (w, create_back) ← MutWrapper.create 0#i32
  let (p, unwrap_back) ← MutWrapper.unwrap w
  let p1 ← p + 1#i32
  let x := create_back (unwrap_back p1)
  massert (x = 1#i32)

/- [adt_borrows::MutWrapper1]
   Source: 'tests/src/adt-borrows.rs', lines 91:0-93:1 -/
structure MutWrapper1 (T : Type) where
  x : T

/- [adt_borrows::{adt_borrows::MutWrapper1<'a, T>}#4::create]:
   Source: 'tests/src/adt-borrows.rs', lines 96:4-98:5 -/
def MutWrapper1.create
  {T : Type} (x : T) : Result ((MutWrapper1 T) × (MutWrapper1 T → T)) :=
  let back := fun ret => ret.x
  Result.ok ({ x }, back)

/- [adt_borrows::{adt_borrows::MutWrapper1<'a, T>}#4::unwrap]:
   Source: 'tests/src/adt-borrows.rs', lines 100:4-102:5 -/
def MutWrapper1.unwrap
  {T : Type} (self : MutWrapper1 T) : Result (T × (T → MutWrapper1 T)) :=
  let back := fun ret => { x := ret }
  Result.ok (self.x, back)

/- [adt_borrows::use_mut_wrapper1]:
   Source: 'tests/src/adt-borrows.rs', lines 105:0-111:1 -/
def use_mut_wrapper1 : Result Unit :=
  do
  let (w, create_back) ← MutWrapper1.create 0#i32
  let (p, unwrap_back) ← MutWrapper1.unwrap w
  let p1 ← p + 1#i32
  let x := create_back (unwrap_back p1)
  massert (x = 1#i32)

/- [adt_borrows::MutWrapper2]
   Source: 'tests/src/adt-borrows.rs', lines 113:0-116:1 -/
structure MutWrapper2 (T : Type) where
  x : T
  y : T

/- [adt_borrows::{adt_borrows::MutWrapper2<'a, 'b, T>}#5::create]:
   Source: 'tests/src/adt-borrows.rs', lines 119:4-121:5 -/
def MutWrapper2.create
  {T : Type} (x : T) (y : T) :
  Result ((MutWrapper2 T) × (MutWrapper2 T → T) × (MutWrapper2 T → T))
  :=
  let back'a := fun ret => ret.x
  let back'b := fun ret => ret.y
  Result.ok ({ x, y }, back'a, back'b)

/- [adt_borrows::{adt_borrows::MutWrapper2<'a, 'b, T>}#5::unwrap]:
   Source: 'tests/src/adt-borrows.rs', lines 123:4-125:5 -/
def MutWrapper2.unwrap
  {T : Type} (self : MutWrapper2 T) :
  Result ((T × T) × (T → MutWrapper2 T) × (T → MutWrapper2 T))
  :=
  let back'a := fun ret => { self with x := ret }
  let back'b := fun ret => { self with y := ret }
  Result.ok ((self.x, self.y), back'a, back'b)

/- [adt_borrows::use_mut_wrapper2]:
   Source: 'tests/src/adt-borrows.rs', lines 128:0-137:1 -/
def use_mut_wrapper2 : Result Unit :=
  do
  let (w, create_back, create_back1) ← MutWrapper2.create 0#i32 10#i32
  let (p, unwrap_back, unwrap_back1) ← MutWrapper2.unwrap w
  let (px, py) := p
  let px1 ← px + 1#i32
  let py1 ← py + 1#i32
  let x := create_back { w with x := (unwrap_back px1).x }
  massert (x = 1#i32)
  let y := create_back1 { w with y := (unwrap_back1 py1).y }
  massert (y = 11#i32)

/- [adt_borrows::array_shared_borrow]:
   Source: 'tests/src/adt-borrows.rs', lines 146:0-148:1 -/
def array_shared_borrow {N : Usize} (x : Array U32 N) : Result (Array U32 N) :=
  Result.ok x

/- [adt_borrows::array_mut_borrow]:
   Source: 'tests/src/adt-borrows.rs', lines 150:0-152:1 -/
def array_mut_borrow
  {N : Usize} (x : Array U32 N) :
  Result ((Array U32 N) × (Array U32 N → Array U32 N))
  :=
  Result.ok (x, fun ret => ret)

/- [adt_borrows::boxed_slice_shared_borrow]:
   Source: 'tests/src/adt-borrows.rs', lines 154:0-156:1 -/
def boxed_slice_shared_borrow (x : Slice U32) : Result (Slice U32) :=
  Result.ok x

/- [adt_borrows::boxed_slice_mut_borrow]:
   Source: 'tests/src/adt-borrows.rs', lines 158:0-160:1 -/
def boxed_slice_mut_borrow
  (x : Slice U32) : Result ((Slice U32) × (Slice U32 → Slice U32)) :=
  Result.ok (x, fun ret => ret)

/- [adt_borrows::SharedList]
   Source: 'tests/src/adt-borrows.rs', lines 165:0-168:1 -/
inductive SharedList (T : Type) :=
| Nil : SharedList T
| Cons : T → SharedList T → SharedList T

/- [adt_borrows::{adt_borrows::SharedList<'a, T>}#6::push]:
   Source: 'tests/src/adt-borrows.rs', lines 172:4-174:5 -/
def SharedList.push
  {T : Type} (self : SharedList T) (x : T) : Result (SharedList T) :=
  Result.ok (SharedList.Cons x self)

/- [adt_borrows::{adt_borrows::SharedList<'a, T>}#6::pop]:
   Source: 'tests/src/adt-borrows.rs', lines 176:4-182:5 -/
def SharedList.pop
  {T : Type} (self : SharedList T) : Result (T × (SharedList T)) :=
  match self with
  | SharedList.Nil => Result.fail .panic
  | SharedList.Cons hd tl => Result.ok (hd, tl)

/- [adt_borrows::MutList]
   Source: 'tests/src/adt-borrows.rs', lines 185:0-188:1 -/
inductive MutList (T : Type) :=
| Nil : MutList T
| Cons : T → MutList T → MutList T

/- [adt_borrows::{adt_borrows::MutList<'a, T>}#7::push]:
   Source: 'tests/src/adt-borrows.rs', lines 192:4-194:5 -/
def MutList.push
  {T : Type} (self : MutList T) (x : T) :
  Result ((MutList T) × (MutList T → ((MutList T) × T)))
  :=
  let back :=
    fun ret =>
      let (x1, ml) :=
        match ret with
        | MutList.Cons t ml1 => (t, ml1)
        | _ => (x, self)
      (ml, x1)
  Result.ok (MutList.Cons x self, back)

/- [adt_borrows::{adt_borrows::MutList<'a, T>}#7::pop]:
   Source: 'tests/src/adt-borrows.rs', lines 196:4-202:5 -/
def MutList.pop
  {T : Type} (self : MutList T) :
  Result ((T × (MutList T)) × ((T × (MutList T)) → MutList T))
  :=
  match self with
  | MutList.Nil => Result.fail .panic
  | MutList.Cons hd tl =>
    let back := fun ret => let (t, ml) := ret
                           MutList.Cons t ml
    Result.ok ((hd, tl), back)

/- [adt_borrows::wrap_shared_in_option]:
   Source: 'tests/src/adt-borrows.rs', lines 205:0-207:1 -/
def wrap_shared_in_option {T : Type} (x : T) : Result (Option T) :=
  Result.ok (some x)

/- [adt_borrows::wrap_mut_in_option]:
   Source: 'tests/src/adt-borrows.rs', lines 209:0-211:1 -/
def wrap_mut_in_option
  {T : Type} (x : T) : Result ((Option T) × (Option T → T)) :=
  let back := fun ret => match ret with
                         | some t => t
                         | _ => x
  Result.ok (some x, back)

/- [adt_borrows::List]
   Source: 'tests/src/adt-borrows.rs', lines 213:0-216:1 -/
inductive List (T : Type) :=
| Cons : T → List T → List T
| Nil : List T

/- [adt_borrows::nth_shared]: loop 0:
   Source: 'tests/src/adt-borrows.rs', lines 219:4-228:1 -/
divergent def nth_shared_loop
  {T : Type} (ls : List T) (i : U32) : Result (Option T) :=
  match ls with
  | List.Cons x tl =>
    if i = 0#u32
    then Result.ok (some x)
    else do
         let i1 ← i - 1#u32
         nth_shared_loop tl i1
  | List.Nil => Result.ok none

/- [adt_borrows::nth_shared]:
   Source: 'tests/src/adt-borrows.rs', lines 218:0-228:1 -/
@[reducible]
def nth_shared {T : Type} (ls : List T) (i : U32) : Result (Option T) :=
  nth_shared_loop ls i

/- [adt_borrows::nth_mut]: loop 0:
   Source: 'tests/src/adt-borrows.rs', lines 231:4-240:1 -/
divergent def nth_mut_loop
  {T : Type} (ls : List T) (i : U32) :
  Result ((Option T) × (Option T → List T))
  :=
  match ls with
  | List.Cons x tl =>
    if i = 0#u32
    then
      let back :=
        fun ret =>
          let t := match ret with
                   | some t1 => t1
                   | _ => x
          List.Cons t tl
      Result.ok (some x, back)
    else
      do
      let i1 ← i - 1#u32
      let (o, back) ← nth_mut_loop tl i1
      let back1 := fun ret => let tl1 := back ret
                              List.Cons x tl1
      Result.ok (o, back1)
  | List.Nil => let back := fun ret => List.Nil
                Result.ok (none, back)

/- [adt_borrows::nth_mut]:
   Source: 'tests/src/adt-borrows.rs', lines 230:0-240:1 -/
@[reducible]
def nth_mut
  {T : Type} (ls : List T) (i : U32) :
  Result ((Option T) × (Option T → List T))
  :=
  nth_mut_loop ls i

end adt_borrows
