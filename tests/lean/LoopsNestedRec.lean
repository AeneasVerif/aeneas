-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [loops_nested_rec]
import Aeneas
open Aeneas Aeneas.Std Result ControlFlow Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

/- You can set the `maxHeartbeats` value with the `-max-heartbeats` CLI option -/
set_option maxHeartbeats 1000000

namespace loops_nested_rec

/- [loops_nested_rec::iter]: loop 1:
   Source: 'tests/src/loops-nested-rec.rs', lines 8:8-10:9 -/
def iter_loop0_loop0 (n : Std.U32) (j : Std.U32) : Result Unit := do
  if j < n
  then let j1 ← j + 1#u32
       iter_loop0_loop0 n j1
  else ok ()
partial_fixpoint

/- [loops_nested_rec::iter]: loop 0:
   Source: 'tests/src/loops-nested-rec.rs', lines 6:4-12:5 -/
def iter_loop0 (m : Std.U32) (n : Std.U32) (i : Std.U32) : Result Unit := do
  if i < m
  then iter_loop0_loop0 n 0#u32
       let i1 ← i + 1#u32
       iter_loop0 m n i1
  else ok ()
partial_fixpoint

/- [loops_nested_rec::iter]:
   Source: 'tests/src/loops-nested-rec.rs', lines 4:0-13:1 -/
@[reducible]
def iter (m : Std.U32) (n : Std.U32) : Result Unit := do
  iter_loop0 m n 0#u32

/- [loops_nested_rec::sum]: loop 1:
   Source: 'tests/src/loops-nested-rec.rs', lines 20:8-23:9 -/
def sum_loop0_loop0
  (n : Std.U32) (s : Std.U32) (j : Std.U32) : Result Std.U32 := do
  if j < n
  then let s1 ← s + 1#u32
       let j1 ← j + 1#u32
       sum_loop0_loop0 n s1 j1
  else ok s
partial_fixpoint

/- [loops_nested_rec::sum]: loop 0:
   Source: 'tests/src/loops-nested-rec.rs', lines 18:4-25:5 -/
def sum_loop0
  (m : Std.U32) (n : Std.U32) (s : Std.U32) (i : Std.U32) :
  Result Std.U32
  := do
  if i < m
  then
    let s1 ← sum_loop0_loop0 n s 0#u32
    let i1 ← i + 1#u32
    sum_loop0 m n s1 i1
  else ok s
partial_fixpoint

/- [loops_nested_rec::sum]:
   Source: 'tests/src/loops-nested-rec.rs', lines 15:0-27:1 -/
@[reducible]
def sum (m : Std.U32) (n : Std.U32) : Result Std.U32 := do
  sum_loop0 m n 0#u32 0#u32

/- [loops_nested_rec::update_array]: loop 1:
   Source: 'tests/src/loops-nested-rec.rs', lines 38:8-41:9 -/
def update_array_loop0_loop0
  (out : Array Std.U8 4#usize) (j : Std.Usize) :
  Result (Array Std.U8 4#usize)
  := do
  if j < 4#usize
  then
    let a ← Array.update out j 1#u8
    let j1 ← j + 1#usize
    update_array_loop0_loop0 a j1
  else ok out
partial_fixpoint

/- [loops_nested_rec::update_array]: loop 0:
   Source: 'tests/src/loops-nested-rec.rs', lines 35:4-43:5 -/
def update_array_loop0
  (out : Array Std.U8 4#usize) (i : Std.Usize) : Result Unit := do
  if i < 4#usize
  then
    let a ← Array.update out i 0#u8
    let out1 ← update_array_loop0_loop0 a 0#usize
    let i1 ← i + 1#usize
    update_array_loop0 out1 i1
  else ok ()
partial_fixpoint

/- [loops_nested_rec::update_array]:
   Source: 'tests/src/loops-nested-rec.rs', lines 31:0-44:1 -/
def update_array : Result Unit := do
  let out := Array.repeat 4#usize 0#u8
  update_array_loop0 out 0#usize

/- [loops_nested_rec::FACTORS]
   Source: 'tests/src/loops-nested-rec.rs', lines 46:0-49:2 -/
@[global_simps, irreducible]
def FACTORS : Array Std.U16 32#usize :=
  Array.make 32#usize [
    2285#u16, 2571#u16, 2970#u16, 1812#u16, 1493#u16, 1422#u16, 287#u16,
    202#u16, 3158#u16, 622#u16, 1577#u16, 182#u16, 962#u16, 2127#u16, 1855#u16,
    1468#u16, 573#u16, 2004#u16, 264#u16, 383#u16, 2500#u16, 1458#u16,
    1727#u16, 3199#u16, 2648#u16, 1017#u16, 732#u16, 608#u16, 1787#u16,
    411#u16, 3124#u16, 1758#u16
    ]

/- [loops_nested_rec::mod_add]:
   Source: 'tests/src/loops-nested-rec.rs', lines 51:0-53:1 -/
def mod_add (a : Std.U32) (b : Std.U32) : Result Std.U32 := do
  let i ← a + b
  i % 3329#u32

/- [loops_nested_rec::mod_sub]:
   Source: 'tests/src/loops-nested-rec.rs', lines 55:0-57:1 -/
def mod_sub (a : Std.U32) (b : Std.U32) : Result Std.U32 := do
  let i ← a + 3329#u32
  let i1 ← b % 3329#u32
  let i2 ← i - i1
  i2 % 3329#u32

/- [loops_nested_rec::ntt_layer]: loop 1:
   Source: 'tests/src/loops-nested-rec.rs', lines 67:8-79:9 -/
def ntt_layer_loop0_loop0
  (a : Array Std.U16 256#usize) (len : Std.Usize) (start : Std.Usize)
  (factor : Std.U32) (j : Std.Usize) :
  Result (Array Std.U16 256#usize)
  := do
  if j < len
  then
    let i ← start + j
    let i1 ← Array.index_usize a i
    let c0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i2 ← i + len
    let i3 ← Array.index_usize a i2
    let c1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    let c1_factor ← c1 * factor
    let c11 ← mod_sub c0 c1_factor
    let c01 ← mod_add c0 c1_factor
    let i4 ← lift (UScalar.cast .U16 c01)
    let a1 ← Array.update a i i4
    let i5 ← i + len
    let i6 ← lift (UScalar.cast .U16 c11)
    let a2 ← Array.update a1 i5 i6
    let j1 ← j + 1#usize
    ntt_layer_loop0_loop0 a2 len start factor j1
  else ok a
partial_fixpoint

/- [loops_nested_rec::ntt_layer]: loop 0:
   Source: 'tests/src/loops-nested-rec.rs', lines 62:4-81:5 -/
def ntt_layer_loop0
  (a : Array Std.U16 256#usize) (k : Std.Usize) (len : Std.Usize)
  (start : Std.Usize) :
  Result (Array Std.U16 256#usize)
  := do
  if start < 256#usize
  then
    let i ← Array.index_usize FACTORS k
    let factor ← core.convert.IntoFrom.into core.convert.FromU32U16 i
    let k1 ← k + 1#usize
    let a1 ← ntt_layer_loop0_loop0 a len start factor 0#usize
    let i1 ← 2#usize * len
    let start1 ← start + i1
    ntt_layer_loop0 a1 k1 len start1
  else ok a
partial_fixpoint

/- [loops_nested_rec::ntt_layer]:
   Source: 'tests/src/loops-nested-rec.rs', lines 60:0-82:1 -/
@[reducible]
def ntt_layer
  (a : Array Std.U16 256#usize) (k : Std.Usize) (len : Std.Usize) :
  Result (Array Std.U16 256#usize)
  := do
  ntt_layer_loop0 a k len 0#usize

/- [loops_nested_rec::Key]
   Source: 'tests/src/loops-nested-rec.rs', lines 84:0-87:1 -/
structure Key where
  seed : Array Std.U8 32#usize
  atranspose : Array Std.U16 32#usize

/- [loops_nested_rec::{loops_nested_rec::Key}::atranspose_mut]:
   Source: 'tests/src/loops-nested-rec.rs', lines 90:4-92:5 -/
def Key.atranspose_mut
  (self : Key) :
  Result ((Array Std.U16 32#usize) × (Array Std.U16 32#usize → Key))
  := do
  let back := fun a => { self with atranspose := a }
  ok (self.atranspose, back)

/- [loops_nested_rec::shake_init]:
   Source: 'tests/src/loops-nested-rec.rs', lines 97:0-97:40 -/
def shake_init
  (_state : Array Std.U8 8#usize) : Result (Array Std.U8 8#usize) := do
  ok _state

/- [loops_nested_rec::shake_append]:
   Source: 'tests/src/loops-nested-rec.rs', lines 98:0-98:56 -/
def shake_append
  (_state : Array Std.U8 8#usize) (_data : Slice Std.U8) :
  Result (Array Std.U8 8#usize)
  := do
  ok _state

/- [loops_nested_rec::shake_state_copy]:
   Source: 'tests/src/loops-nested-rec.rs', lines 99:0-99:62 -/
def shake_state_copy
  (_src : Array Std.U8 8#usize) (_dst : Array Std.U8 8#usize) :
  Result (Array Std.U8 8#usize)
  := do
  ok _dst

/- [loops_nested_rec::sample_ntt]:
   Source: 'tests/src/loops-nested-rec.rs', lines 100:0-100:56 -/
def sample_ntt
  (_state : Array Std.U8 8#usize) (_dst : Std.U16) :
  Result ((Array Std.U8 8#usize) × Std.U16)
  := do
  ok (_state, _dst)

/- [loops_nested_rec::generate_matrix_inner]: loop 0:
   Source: 'tests/src/loops-nested-rec.rs', lines 105:4-109:5 -/
def generate_matrix_inner_loop
  (key : Key) (state : Array Std.U8 8#usize) (j : Std.Usize) :
  Result (Key × (Array Std.U8 8#usize))
  := do
  if j < 4#usize
  then
    let (a_transpose, atranspose_mut_back) ← Key.atranspose_mut key
    let (i, index_mut_back) ← Array.index_mut_usize a_transpose j
    let (state1, i1) ← sample_ntt state i
    let j1 ← j + 1#usize
    let a := index_mut_back i1
    let k := atranspose_mut_back a
    generate_matrix_inner_loop k state1 j1
  else ok (key, state)
partial_fixpoint

/- [loops_nested_rec::generate_matrix_inner]:
   Source: 'tests/src/loops-nested-rec.rs', lines 103:0-110:1 -/
@[reducible]
def generate_matrix_inner
  (key : Key) (state : Array Std.U8 8#usize) :
  Result (Key × (Array Std.U8 8#usize))
  := do
  generate_matrix_inner_loop key state 0#usize

/- [loops_nested_rec::generate_matrix]: loop 1:
   Source: 'tests/src/loops-nested-rec.rs', lines 124:8-132:9 -/
def generate_matrix_loop0_loop0
  (key : Key) (state_base : Array Std.U8 8#usize)
  (state_work : Array Std.U8 8#usize) (coordinates : Array Std.U8 2#usize)
  (i : Std.U8) (j : Std.U8) :
  Result (Key × (Array Std.U8 8#usize) × (Array Std.U8 2#usize))
  := do
  if j < 4#u8
  then
    let coordinates1 ← Array.update coordinates 0#usize j
    let state_work1 ← shake_state_copy state_base state_work
    let s ← lift (Array.to_slice coordinates1)
    let state_work2 ← shake_append state_work1 s
    let (a_transpose, atranspose_mut_back) ← Key.atranspose_mut key
    let i1 ← i * 4#u8
    let i2 ← i1 + j
    let i3 ← lift (UScalar.cast .Usize i2)
    let (i4, index_mut_back) ← Array.index_mut_usize a_transpose i3
    let (state_work3, i5) ← sample_ntt state_work2 i4
    let j1 ← j + 1#u8
    let a := index_mut_back i5
    let k := atranspose_mut_back a
    generate_matrix_loop0_loop0 k state_base state_work3 coordinates1 i j1
  else ok (key, state_work, coordinates)
partial_fixpoint

/- [loops_nested_rec::generate_matrix]: loop 0:
   Source: 'tests/src/loops-nested-rec.rs', lines 121:4-134:5 -/
def generate_matrix_loop0
  (key : Key) (state_base : Array Std.U8 8#usize)
  (state_work : Array Std.U8 8#usize) (coordinates : Array Std.U8 2#usize)
  (i : Std.U8) :
  Result (Key × (Array Std.U8 8#usize))
  := do
  if i < 4#u8
  then
    let a ← Array.update coordinates 1#usize i
    let (key1, state_work1, coordinates1) ←
      generate_matrix_loop0_loop0 key state_base state_work a i 0#u8
    let i1 ← i + 1#u8
    generate_matrix_loop0 key1 state_base state_work1 coordinates1 i1
  else ok (key, state_work)
partial_fixpoint

/- [loops_nested_rec::generate_matrix]:
   Source: 'tests/src/loops-nested-rec.rs', lines 113:0-135:1 -/
def generate_matrix
  (key : Key) (state_base : Array Std.U8 8#usize)
  (state_work : Array Std.U8 8#usize) :
  Result (Key × (Array Std.U8 8#usize) × (Array Std.U8 8#usize))
  := do
  let coordinates := Array.repeat 2#usize 0#u8
  let state_base1 ← shake_init state_base
  let s ← lift (Array.to_slice key.seed)
  let state_base2 ← shake_append state_base1 s
  let (key1, state_work1) ←
    generate_matrix_loop0 key state_base2 state_work coordinates 0#u8
  ok (key1, state_base2, state_work1)

/- [loops_nested_rec::mul_add_as_plus_e]: loop 1:
   Source: 'tests/src/loops-nested-rec.rs', lines 144:8-146:9 -/
def mul_add_as_plus_e_loop0_loop0
  (a_row_temp : alloc.vec.Vec Std.U8) (j : Std.Usize)
  (iter1 : core.ops.range.Range Std.Usize) :
  Result (alloc.vec.Vec Std.U8)
  := do
  let (o, iter2) ←
    core.iter.range.IteratorRange.next core.iter.range.StepUsize iter1
  match o with
  | none => ok a_row_temp
  | some _ =>
    let (_, index_mut_back) ←
      alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSlice Std.U8)
        a_row_temp j
    let a_row_temp1 := index_mut_back 0#u8
    mul_add_as_plus_e_loop0_loop0 a_row_temp1 j iter2
partial_fixpoint

/- [loops_nested_rec::mul_add_as_plus_e]: loop 0:
   Source: 'tests/src/loops-nested-rec.rs', lines 143:4-147:5 -/
def mul_add_as_plus_e_loop0
  (a_row_temp : alloc.vec.Vec Std.U8)
  (iter1 : core.iter.adapters.step_by.StepBy (core.ops.range.Range Std.Usize))
  :
  Result Unit
  := do
  let (o, iter2) ←
    core.iter.adapters.step_by.IteratorStepBy.next
      (core.iter.traits.iterator.IteratorRange core.iter.range.StepUsize) iter1
  match o with
  | none => ok ()
  | some j =>
    let a_row_temp1 ←
      mul_add_as_plus_e_loop0_loop0 a_row_temp j
        { start := 0#usize, «end» := 4#usize }
    mul_add_as_plus_e_loop0 a_row_temp1 iter2
partial_fixpoint

/- [loops_nested_rec::mul_add_as_plus_e]:
   Source: 'tests/src/loops-nested-rec.rs', lines 138:0-148:1 -/
def mul_add_as_plus_e
  (N : Std.Usize) (out : Slice Std.U16) (s : Slice Std.U16)
  (seed_a : Array Std.U8 16#usize) :
  Result (Slice Std.U16)
  := do
  let i ← 4#usize * N
  let i1 ← i * 2#usize
  let a_row_temp ← alloc.vec.from_elem core.clone.CloneU8 0#u8 i1
  let i2 ← i * 2#usize
  let _ ← alloc.vec.from_elem core.clone.CloneU8 0#u8 i2
  let iter1 ←
    core.iter.range.IteratorRange.step_by core.iter.range.StepUsize
      { start := 0#usize, «end» := N } 8#usize
  mul_add_as_plus_e_loop0 a_row_temp iter1
  ok out

end loops_nested_rec
