-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [paper]
import Base
open Primitives
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace paper

/- [paper::ref_incr]:
   Source: 'tests/src/paper.rs', lines 7:0-9:1 -/
def ref_incr (x : I32) : Result I32 :=
  x + 1#i32

/- [paper::test_incr]:
   Source: 'tests/src/paper.rs', lines 11:0-15:1 -/
def test_incr : Result Unit :=
  do
  let x ← ref_incr 0#i32
  if x = 1#i32
  then Result.ok ()
  else Result.fail .panic

/- Unit test for [paper::test_incr] -/
#assert (test_incr == Result.ok ())

/- [paper::choose]:
   Source: 'tests/src/paper.rs', lines 18:0-24:1 -/
def choose
  {T : Type} (b : Bool) (x : T) (y : T) : Result (T × (T → (T × T))) :=
  if b
  then let back := fun ret => (ret, y)
       Result.ok (x, back)
  else let back := fun ret => (x, ret)
       Result.ok (y, back)

/- [paper::test_choose]:
   Source: 'tests/src/paper.rs', lines 26:0-34:1 -/
def test_choose : Result Unit :=
  do
  let (z, choose_back) ← choose true 0#i32 0#i32
  let z1 ← z + 1#i32
  if z1 = 1#i32
  then
    let (x, y) := choose_back z1
    if x = 1#i32
    then if y = 0#i32
         then Result.ok ()
         else Result.fail .panic
    else Result.fail .panic
  else Result.fail .panic

/- Unit test for [paper::test_choose] -/
#assert (test_choose == Result.ok ())

/- [paper::List]
   Source: 'tests/src/paper.rs', lines 38:0-41:1 -/
inductive List (T : Type) :=
| Cons : T → List T → List T
| Nil : List T

/- [paper::list_nth_mut]:
   Source: 'tests/src/paper.rs', lines 45:0-58:1 -/
divergent def list_nth_mut
  {T : Type} (l : List T) (i : U32) : Result (T × (T → List T)) :=
  match l with
  | List.Cons x tl =>
    if i = 0#u32
    then let back := fun ret => List.Cons ret tl
         Result.ok (x, back)
    else
      do
      let i1 ← i - 1#u32
      let (t, list_nth_mut_back) ← list_nth_mut tl i1
      let back := fun ret => let tl1 := list_nth_mut_back ret
                             List.Cons x tl1
      Result.ok (t, back)
  | List.Nil => Result.fail .panic

/- [paper::sum]:
   Source: 'tests/src/paper.rs', lines 60:0-69:1 -/
divergent def sum (l : List I32) : Result I32 :=
  match l with
  | List.Cons x tl => do
                      let i ← sum tl
                      x + i
  | List.Nil => Result.ok 0#i32

/- [paper::test_nth]:
   Source: 'tests/src/paper.rs', lines 71:0-76:1 -/
def test_nth : Result Unit :=
  do
  let l := List.Cons 3#i32 List.Nil
  let l1 := List.Cons 2#i32 l
  let (x, list_nth_mut_back) ← list_nth_mut (List.Cons 1#i32 l1) 2#u32
  let x1 ← x + 1#i32
  let l2 := list_nth_mut_back x1
  let i ← sum l2
  if i = 7#i32
  then Result.ok ()
  else Result.fail .panic

/- Unit test for [paper::test_nth] -/
#assert (test_nth == Result.ok ())

/- [paper::call_choose]:
   Source: 'tests/src/paper.rs', lines 79:0-85:1 -/
def call_choose (p : (U32 × U32)) : Result U32 :=
  do
  let (px, py) := p
  let (pz, choose_back) ← choose true px py
  let pz1 ← pz + 1#u32
  let (px1, _) := choose_back pz1
  Result.ok px1

end paper
