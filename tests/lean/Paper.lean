-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [paper]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace paper

/- [paper::ref_incr]:
   Source: 'tests/src/paper.rs', lines 6:0-8:1 -/
def ref_incr (x : I32) : Result I32 := do
  x + 1#i32

/- [paper::test_incr]:
   Source: 'tests/src/paper.rs', lines 10:0-14:1 -/
def test_incr : Result Unit := do
  let x ← ref_incr 0#i32
  massert (x = 1#i32)

/- Unit test for [paper::test_incr] -/
#assert (test_incr == ok ())

/- [paper::choose]:
   Source: 'tests/src/paper.rs', lines 17:0-23:1 -/
def choose
  {T : Type} (b : Bool) (x : T) (y : T) : Result (T × (T → (T × T))) := do
  if b
  then let back := fun ret => (ret, y)
       ok (x, back)
  else let back := fun ret => (x, ret)
       ok (y, back)

/- [paper::test_choose]:
   Source: 'tests/src/paper.rs', lines 25:0-33:1 -/
def test_choose : Result Unit := do
  let (z, choose_back) ← choose true 0#i32 0#i32
  let z1 ← z + 1#i32
  massert (z1 = 1#i32)
  let (x, y) := choose_back z1
  massert (x = 1#i32)
  massert (y = 0#i32)

/- Unit test for [paper::test_choose] -/
#assert (test_choose == ok ())

/- [paper::List]
   Source: 'tests/src/paper.rs', lines 37:0-40:1 -/
inductive List (T : Type) where
| Cons : T → List T → List T
| Nil : List T

/- [paper::list_nth_mut]:
   Source: 'tests/src/paper.rs', lines 44:0-57:1 -/
def list_nth_mut
  {T : Type} (l : List T) (i : U32) : Result (T × (T → List T)) := do
  match l with
  | List.Cons x tl =>
    if i = 0#u32
    then let back := fun ret => List.Cons ret tl
         ok (x, back)
    else
      let i1 ← i - 1#u32
      let (x1, list_nth_mut_back) ← list_nth_mut tl i1
      let back := fun ret => let tl1 := list_nth_mut_back ret
                             List.Cons x tl1
      ok (x1, back)
  | List.Nil => fail panic
partial_fixpoint

/- [paper::sum]:
   Source: 'tests/src/paper.rs', lines 59:0-68:1 -/
def sum (l : List I32) : Result I32 := do
  match l with
  | List.Cons x tl => let i ← sum tl
                      x + i
  | List.Nil => ok 0#i32
partial_fixpoint

/- [paper::test_nth]:
   Source: 'tests/src/paper.rs', lines 70:0-75:1 -/
def test_nth : Result Unit := do
  let (x, list_nth_mut_back) ←
    list_nth_mut (List.Cons 1#i32 (List.Cons 2#i32 (List.Cons 3#i32 List.Nil)))
      2#u32
  let x1 ← x + 1#i32
  let l := list_nth_mut_back x1
  let i ← sum l
  massert (i = 7#i32)

/- Unit test for [paper::test_nth] -/
#assert (test_nth == ok ())

/- [paper::call_choose]:
   Source: 'tests/src/paper.rs', lines 78:0-84:1 -/
def call_choose (p : (U32 × U32)) : Result U32 := do
  let (px, py) := p
  let (pz, choose_back) ← choose true px py
  let pz1 ← pz + 1#u32
  let (px1, _) := choose_back pz1
  ok px1

end paper
