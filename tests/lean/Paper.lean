-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [paper]
import Base
open Primitives

/- [paper::ref_incr] -/
def ref_incr_fwd_back (x : I32) : Result I32 :=
  x + (I32.ofInt 1 (by intlit))

/- [paper::test_incr] -/
def test_incr_fwd : Result Unit :=
  do
    let x ← ref_incr_fwd_back (I32.ofInt 0 (by intlit))
    if not (x = (I32.ofInt 1 (by intlit)))
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [paper::test_incr] -/
#assert (test_incr_fwd == .ret ())

/- [paper::choose] -/
def choose_fwd (T : Type) (b : Bool) (x : T) (y : T) : Result T :=
  if b
  then Result.ret x
  else Result.ret y

/- [paper::choose] -/
def choose_back
  (T : Type) (b : Bool) (x : T) (y : T) (ret0 : T) : Result (T × T) :=
  if b
  then Result.ret (ret0, y)
  else Result.ret (x, ret0)

/- [paper::test_choose] -/
def test_choose_fwd : Result Unit :=
  do
    let z ←
      choose_fwd I32 true (I32.ofInt 0 (by intlit)) (I32.ofInt 0 (by intlit))
    let z0 ← z + (I32.ofInt 1 (by intlit))
    if not (z0 = (I32.ofInt 1 (by intlit)))
    then Result.fail Error.panic
    else
      do
        let (x, y) ←
          choose_back I32 true (I32.ofInt 0 (by intlit))
            (I32.ofInt 0 (by intlit)) z0
        if not (x = (I32.ofInt 1 (by intlit)))
        then Result.fail Error.panic
        else
          if not (y = (I32.ofInt 0 (by intlit)))
          then Result.fail Error.panic
          else Result.ret ()

/- Unit test for [paper::test_choose] -/
#assert (test_choose_fwd == .ret ())

/- [paper::List] -/
inductive list_t (T : Type) :=
| Cons : T -> list_t T -> list_t T
| Nil : list_t T

/- [paper::list_nth_mut] -/
divergent def list_nth_mut_fwd
  (T : Type) (l : list_t T) (i : U32) : Result T :=
  match h: l with
  | list_t.Cons x tl =>
    if i = (U32.ofInt 0 (by intlit))
    then Result.ret x
    else do
           let i0 ← i - (U32.ofInt 1 (by intlit))
           list_nth_mut_fwd T tl i0
  | list_t.Nil => Result.fail Error.panic

/- [paper::list_nth_mut] -/
divergent def list_nth_mut_back
  (T : Type) (l : list_t T) (i : U32) (ret0 : T) : Result (list_t T) :=
  match h: l with
  | list_t.Cons x tl =>
    if i = (U32.ofInt 0 (by intlit))
    then Result.ret (list_t.Cons ret0 tl)
    else
      do
        let i0 ← i - (U32.ofInt 1 (by intlit))
        let tl0 ← list_nth_mut_back T tl i0 ret0
        Result.ret (list_t.Cons x tl0)
  | list_t.Nil => Result.fail Error.panic

/- [paper::sum] -/
divergent def sum_fwd (l : list_t I32) : Result I32 :=
  match h: l with
  | list_t.Cons x tl => do
                          let i ← sum_fwd tl
                          x + i
  | list_t.Nil => Result.ret (I32.ofInt 0 (by intlit))

/- [paper::test_nth] -/
def test_nth_fwd : Result Unit :=
  do
    let l := list_t.Nil
    let l0 := list_t.Cons (I32.ofInt 3 (by intlit)) l
    let l1 := list_t.Cons (I32.ofInt 2 (by intlit)) l0
    let x ←
      list_nth_mut_fwd I32 (list_t.Cons (I32.ofInt 1 (by intlit)) l1)
        (U32.ofInt 2 (by intlit))
    let x0 ← x + (I32.ofInt 1 (by intlit))
    let l2 ←
      list_nth_mut_back I32 (list_t.Cons (I32.ofInt 1 (by intlit)) l1)
        (U32.ofInt 2 (by intlit)) x0
    let i ← sum_fwd l2
    if not (i = (I32.ofInt 7 (by intlit)))
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [paper::test_nth] -/
#assert (test_nth_fwd == .ret ())

/- [paper::call_choose] -/
def call_choose_fwd (p : (U32 × U32)) : Result U32 :=
  do
    let (px, py) := p
    let pz ← choose_fwd U32 true px py
    let pz0 ← pz + (U32.ofInt 1 (by intlit))
    let (px0, _) ← choose_back U32 true px py pz0
    Result.ret px0

