-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [no_nested_borrows]
import Base
open Primitives

namespace no_nested_borrows

/- [no_nested_borrows::Pair]
   Source: 'src/no_nested_borrows.rs', lines 4:0-4:23 -/
structure Pair (T1 T2 : Type) where
  x : T1
  y : T2

/- [no_nested_borrows::List]
   Source: 'src/no_nested_borrows.rs', lines 9:0-9:16 -/
inductive List (T : Type) :=
| Cons : T → List T → List T
| Nil : List T

/- [no_nested_borrows::One]
   Source: 'src/no_nested_borrows.rs', lines 20:0-20:16 -/
inductive One (T1 : Type) :=
| One : T1 → One T1

/- [no_nested_borrows::EmptyEnum]
   Source: 'src/no_nested_borrows.rs', lines 26:0-26:18 -/
inductive EmptyEnum :=
| Empty : EmptyEnum

/- [no_nested_borrows::Enum]
   Source: 'src/no_nested_borrows.rs', lines 32:0-32:13 -/
inductive Enum :=
| Variant1 : Enum
| Variant2 : Enum

/- [no_nested_borrows::EmptyStruct]
   Source: 'src/no_nested_borrows.rs', lines 39:0-39:22 -/
structure EmptyStruct where

/- [no_nested_borrows::Sum]
   Source: 'src/no_nested_borrows.rs', lines 41:0-41:20 -/
inductive Sum (T1 T2 : Type) :=
| Left : T1 → Sum T1 T2
| Right : T2 → Sum T1 T2

/- [no_nested_borrows::neg_test]: forward function
   Source: 'src/no_nested_borrows.rs', lines 48:0-48:30 -/
def neg_test (x : I32) : Result I32 :=
  - x

/- [no_nested_borrows::add_test]: forward function
   Source: 'src/no_nested_borrows.rs', lines 54:0-54:38 -/
def add_test (x : U32) (y : U32) : Result U32 :=
  x + y

/- [no_nested_borrows::subs_test]: forward function
   Source: 'src/no_nested_borrows.rs', lines 60:0-60:39 -/
def subs_test (x : U32) (y : U32) : Result U32 :=
  x - y

/- [no_nested_borrows::div_test]: forward function
   Source: 'src/no_nested_borrows.rs', lines 66:0-66:38 -/
def div_test (x : U32) (y : U32) : Result U32 :=
  x / y

/- [no_nested_borrows::div_test1]: forward function
   Source: 'src/no_nested_borrows.rs', lines 73:0-73:31 -/
def div_test1 (x : U32) : Result U32 :=
  x / 2#u32

/- [no_nested_borrows::rem_test]: forward function
   Source: 'src/no_nested_borrows.rs', lines 78:0-78:38 -/
def rem_test (x : U32) (y : U32) : Result U32 :=
  x % y

/- [no_nested_borrows::mul_test]: forward function
   Source: 'src/no_nested_borrows.rs', lines 82:0-82:38 -/
def mul_test (x : U32) (y : U32) : Result U32 :=
  x * y

/- [no_nested_borrows::CONST0]
   Source: 'src/no_nested_borrows.rs', lines 91:0-91:23 -/
def const0_body : Result Usize := 1#usize + 1#usize
def const0_c : Usize := eval_global const0_body (by simp)

/- [no_nested_borrows::CONST1]
   Source: 'src/no_nested_borrows.rs', lines 92:0-92:23 -/
def const1_body : Result Usize := 2#usize * 2#usize
def const1_c : Usize := eval_global const1_body (by simp)

/- [no_nested_borrows::cast_test]: forward function
   Source: 'src/no_nested_borrows.rs', lines 94:0-94:31 -/
def cast_test (x : U32) : Result I32 :=
  Scalar.cast .I32 x

/- [no_nested_borrows::test2]: forward function
   Source: 'src/no_nested_borrows.rs', lines 99:0-99:14 -/
def test2 : Result Unit :=
  do
    let _ ← 23#u32 + 44#u32
    Result.ret ()

/- Unit test for [no_nested_borrows::test2] -/
#assert (test2 == .ret ())

/- [no_nested_borrows::get_max]: forward function
   Source: 'src/no_nested_borrows.rs', lines 111:0-111:37 -/
def get_max (x : U32) (y : U32) : Result U32 :=
  if x >= y
  then Result.ret x
  else Result.ret y

/- [no_nested_borrows::test3]: forward function
   Source: 'src/no_nested_borrows.rs', lines 119:0-119:14 -/
def test3 : Result Unit :=
  do
    let x ← get_max 4#u32 3#u32
    let y ← get_max 10#u32 11#u32
    let z ← x + y
    if not (z = 15#u32)
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [no_nested_borrows::test3] -/
#assert (test3 == .ret ())

/- [no_nested_borrows::test_neg1]: forward function
   Source: 'src/no_nested_borrows.rs', lines 126:0-126:18 -/
def test_neg1 : Result Unit :=
  do
    let y ← - 3#i32
    if not (y = (-(3:Int))#i32)
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [no_nested_borrows::test_neg1] -/
#assert (test_neg1 == .ret ())

/- [no_nested_borrows::refs_test1]: forward function
   Source: 'src/no_nested_borrows.rs', lines 133:0-133:19 -/
def refs_test1 : Result Unit :=
  if not (1#i32 = 1#i32)
  then Result.fail Error.panic
  else Result.ret ()

/- Unit test for [no_nested_borrows::refs_test1] -/
#assert (refs_test1 == .ret ())

/- [no_nested_borrows::refs_test2]: forward function
   Source: 'src/no_nested_borrows.rs', lines 144:0-144:19 -/
def refs_test2 : Result Unit :=
  if not (2#i32 = 2#i32)
  then Result.fail Error.panic
  else
    if not (0#i32 = 0#i32)
    then Result.fail Error.panic
    else
      if not (2#i32 = 2#i32)
      then Result.fail Error.panic
      else
        if not (2#i32 = 2#i32)
        then Result.fail Error.panic
        else Result.ret ()

/- Unit test for [no_nested_borrows::refs_test2] -/
#assert (refs_test2 == .ret ())

/- [no_nested_borrows::test_list1]: forward function
   Source: 'src/no_nested_borrows.rs', lines 160:0-160:19 -/
def test_list1 : Result Unit :=
  Result.ret ()

/- Unit test for [no_nested_borrows::test_list1] -/
#assert (test_list1 == .ret ())

/- [no_nested_borrows::test_box1]: forward function
   Source: 'src/no_nested_borrows.rs', lines 165:0-165:18 -/
def test_box1 : Result Unit :=
  do
    let b := 0#i32
    let b0 ← alloc.boxed.Box.deref_mut_back I32 b 1#i32
    let x ← alloc.boxed.Box.deref I32 b0
    if not (x = 1#i32)
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [no_nested_borrows::test_box1] -/
#assert (test_box1 == .ret ())

/- [no_nested_borrows::copy_int]: forward function
   Source: 'src/no_nested_borrows.rs', lines 175:0-175:30 -/
def copy_int (x : I32) : Result I32 :=
  Result.ret x

/- [no_nested_borrows::test_unreachable]: forward function
   Source: 'src/no_nested_borrows.rs', lines 181:0-181:32 -/
def test_unreachable (b : Bool) : Result Unit :=
  if b
  then Result.fail Error.panic
  else Result.ret ()

/- [no_nested_borrows::test_panic]: forward function
   Source: 'src/no_nested_borrows.rs', lines 189:0-189:26 -/
def test_panic (b : Bool) : Result Unit :=
  if b
  then Result.fail Error.panic
  else Result.ret ()

/- [no_nested_borrows::test_copy_int]: forward function
   Source: 'src/no_nested_borrows.rs', lines 196:0-196:22 -/
def test_copy_int : Result Unit :=
  do
    let y ← copy_int 0#i32
    if not (0#i32 = y)
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [no_nested_borrows::test_copy_int] -/
#assert (test_copy_int == .ret ())

/- [no_nested_borrows::is_cons]: forward function
   Source: 'src/no_nested_borrows.rs', lines 203:0-203:38 -/
def is_cons (T : Type) (l : List T) : Result Bool :=
  match l with
  | List.Cons t l0 => Result.ret true
  | List.Nil => Result.ret false

/- [no_nested_borrows::test_is_cons]: forward function
   Source: 'src/no_nested_borrows.rs', lines 210:0-210:21 -/
def test_is_cons : Result Unit :=
  do
    let l := List.Nil
    let b ← is_cons I32 (List.Cons 0#i32 l)
    if not b
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [no_nested_borrows::test_is_cons] -/
#assert (test_is_cons == .ret ())

/- [no_nested_borrows::split_list]: forward function
   Source: 'src/no_nested_borrows.rs', lines 216:0-216:48 -/
def split_list (T : Type) (l : List T) : Result (T × (List T)) :=
  match l with
  | List.Cons hd tl => Result.ret (hd, tl)
  | List.Nil => Result.fail Error.panic

/- [no_nested_borrows::test_split_list]: forward function
   Source: 'src/no_nested_borrows.rs', lines 224:0-224:24 -/
def test_split_list : Result Unit :=
  do
    let l := List.Nil
    let p ← split_list I32 (List.Cons 0#i32 l)
    let (hd, _) := p
    if not (hd = 0#i32)
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [no_nested_borrows::test_split_list] -/
#assert (test_split_list == .ret ())

/- [no_nested_borrows::choose]: forward function
   Source: 'src/no_nested_borrows.rs', lines 231:0-231:70 -/
def choose (T : Type) (b : Bool) (x : T) (y : T) : Result T :=
  if b
  then Result.ret x
  else Result.ret y

/- [no_nested_borrows::choose]: backward function 0
   Source: 'src/no_nested_borrows.rs', lines 231:0-231:70 -/
def choose_back
  (T : Type) (b : Bool) (x : T) (y : T) (ret0 : T) : Result (T × T) :=
  if b
  then Result.ret (ret0, y)
  else Result.ret (x, ret0)

/- [no_nested_borrows::choose_test]: forward function
   Source: 'src/no_nested_borrows.rs', lines 239:0-239:20 -/
def choose_test : Result Unit :=
  do
    let z ← choose I32 true 0#i32 0#i32
    let z0 ← z + 1#i32
    if not (z0 = 1#i32)
    then Result.fail Error.panic
    else
      do
        let (x, y) ← choose_back I32 true 0#i32 0#i32 z0
        if not (x = 1#i32)
        then Result.fail Error.panic
        else if not (y = 0#i32)
             then Result.fail Error.panic
             else Result.ret ()

/- Unit test for [no_nested_borrows::choose_test] -/
#assert (choose_test == .ret ())

/- [no_nested_borrows::test_char]: forward function
   Source: 'src/no_nested_borrows.rs', lines 251:0-251:26 -/
def test_char : Result Char :=
  Result.ret 'a'

mutual

/- [no_nested_borrows::Tree]
   Source: 'src/no_nested_borrows.rs', lines 256:0-256:16 -/
inductive Tree (T : Type) :=
| Leaf : T → Tree T
| Node : T → NodeElem T → Tree T → Tree T

/- [no_nested_borrows::NodeElem]
   Source: 'src/no_nested_borrows.rs', lines 261:0-261:20 -/
inductive NodeElem (T : Type) :=
| Cons : Tree T → NodeElem T → NodeElem T
| Nil : NodeElem T

end

/- [no_nested_borrows::list_length]: forward function
   Source: 'src/no_nested_borrows.rs', lines 296:0-296:48 -/
divergent def list_length (T : Type) (l : List T) : Result U32 :=
  match l with
  | List.Cons t l1 => do
                        let i ← list_length T l1
                        1#u32 + i
  | List.Nil => Result.ret 0#u32

/- [no_nested_borrows::list_nth_shared]: forward function
   Source: 'src/no_nested_borrows.rs', lines 304:0-304:62 -/
divergent def list_nth_shared (T : Type) (l : List T) (i : U32) : Result T :=
  match l with
  | List.Cons x tl =>
    if i = 0#u32
    then Result.ret x
    else do
           let i0 ← i - 1#u32
           list_nth_shared T tl i0
  | List.Nil => Result.fail Error.panic

/- [no_nested_borrows::list_nth_mut]: forward function
   Source: 'src/no_nested_borrows.rs', lines 320:0-320:67 -/
divergent def list_nth_mut (T : Type) (l : List T) (i : U32) : Result T :=
  match l with
  | List.Cons x tl =>
    if i = 0#u32
    then Result.ret x
    else do
           let i0 ← i - 1#u32
           list_nth_mut T tl i0
  | List.Nil => Result.fail Error.panic

/- [no_nested_borrows::list_nth_mut]: backward function 0
   Source: 'src/no_nested_borrows.rs', lines 320:0-320:67 -/
divergent def list_nth_mut_back
  (T : Type) (l : List T) (i : U32) (ret0 : T) : Result (List T) :=
  match l with
  | List.Cons x tl =>
    if i = 0#u32
    then Result.ret (List.Cons ret0 tl)
    else
      do
        let i0 ← i - 1#u32
        let tl0 ← list_nth_mut_back T tl i0 ret0
        Result.ret (List.Cons x tl0)
  | List.Nil => Result.fail Error.panic

/- [no_nested_borrows::list_rev_aux]: forward function
   Source: 'src/no_nested_borrows.rs', lines 336:0-336:63 -/
divergent def list_rev_aux
  (T : Type) (li : List T) (lo : List T) : Result (List T) :=
  match li with
  | List.Cons hd tl => list_rev_aux T tl (List.Cons hd lo)
  | List.Nil => Result.ret lo

/- [no_nested_borrows::list_rev]: merged forward/backward function
   (there is a single backward function, and the forward function returns ())
   Source: 'src/no_nested_borrows.rs', lines 350:0-350:42 -/
def list_rev (T : Type) (l : List T) : Result (List T) :=
  let li := core.mem.replace (List T) l List.Nil
  list_rev_aux T li List.Nil

/- [no_nested_borrows::test_list_functions]: forward function
   Source: 'src/no_nested_borrows.rs', lines 355:0-355:28 -/
def test_list_functions : Result Unit :=
  do
    let l := List.Nil
    let l0 := List.Cons 2#i32 l
    let l1 := List.Cons 1#i32 l0
    let i ← list_length I32 (List.Cons 0#i32 l1)
    if not (i = 3#u32)
    then Result.fail Error.panic
    else
      do
        let i0 ← list_nth_shared I32 (List.Cons 0#i32 l1) 0#u32
        if not (i0 = 0#i32)
        then Result.fail Error.panic
        else
          do
            let i1 ← list_nth_shared I32 (List.Cons 0#i32 l1) 1#u32
            if not (i1 = 1#i32)
            then Result.fail Error.panic
            else
              do
                let i2 ← list_nth_shared I32 (List.Cons 0#i32 l1) 2#u32
                if not (i2 = 2#i32)
                then Result.fail Error.panic
                else
                  do
                    let ls ←
                      list_nth_mut_back I32 (List.Cons 0#i32 l1) 1#u32 3#i32
                    let i3 ← list_nth_shared I32 ls 0#u32
                    if not (i3 = 0#i32)
                    then Result.fail Error.panic
                    else
                      do
                        let i4 ← list_nth_shared I32 ls 1#u32
                        if not (i4 = 3#i32)
                        then Result.fail Error.panic
                        else
                          do
                            let i5 ← list_nth_shared I32 ls 2#u32
                            if not (i5 = 2#i32)
                            then Result.fail Error.panic
                            else Result.ret ()

/- Unit test for [no_nested_borrows::test_list_functions] -/
#assert (test_list_functions == .ret ())

/- [no_nested_borrows::id_mut_pair1]: forward function
   Source: 'src/no_nested_borrows.rs', lines 371:0-371:89 -/
def id_mut_pair1 (T1 T2 : Type) (x : T1) (y : T2) : Result (T1 × T2) :=
  Result.ret (x, y)

/- [no_nested_borrows::id_mut_pair1]: backward function 0
   Source: 'src/no_nested_borrows.rs', lines 371:0-371:89 -/
def id_mut_pair1_back
  (T1 T2 : Type) (x : T1) (y : T2) (ret0 : (T1 × T2)) : Result (T1 × T2) :=
  let (t, t0) := ret0
  Result.ret (t, t0)

/- [no_nested_borrows::id_mut_pair2]: forward function
   Source: 'src/no_nested_borrows.rs', lines 375:0-375:88 -/
def id_mut_pair2 (T1 T2 : Type) (p : (T1 × T2)) : Result (T1 × T2) :=
  let (t, t0) := p
  Result.ret (t, t0)

/- [no_nested_borrows::id_mut_pair2]: backward function 0
   Source: 'src/no_nested_borrows.rs', lines 375:0-375:88 -/
def id_mut_pair2_back
  (T1 T2 : Type) (p : (T1 × T2)) (ret0 : (T1 × T2)) : Result (T1 × T2) :=
  let (t, t0) := ret0
  Result.ret (t, t0)

/- [no_nested_borrows::id_mut_pair3]: forward function
   Source: 'src/no_nested_borrows.rs', lines 379:0-379:93 -/
def id_mut_pair3 (T1 T2 : Type) (x : T1) (y : T2) : Result (T1 × T2) :=
  Result.ret (x, y)

/- [no_nested_borrows::id_mut_pair3]: backward function 0
   Source: 'src/no_nested_borrows.rs', lines 379:0-379:93 -/
def id_mut_pair3_back'a
  (T1 T2 : Type) (x : T1) (y : T2) (ret0 : T1) : Result T1 :=
  Result.ret ret0

/- [no_nested_borrows::id_mut_pair3]: backward function 1
   Source: 'src/no_nested_borrows.rs', lines 379:0-379:93 -/
def id_mut_pair3_back'b
  (T1 T2 : Type) (x : T1) (y : T2) (ret0 : T2) : Result T2 :=
  Result.ret ret0

/- [no_nested_borrows::id_mut_pair4]: forward function
   Source: 'src/no_nested_borrows.rs', lines 383:0-383:92 -/
def id_mut_pair4 (T1 T2 : Type) (p : (T1 × T2)) : Result (T1 × T2) :=
  let (t, t0) := p
  Result.ret (t, t0)

/- [no_nested_borrows::id_mut_pair4]: backward function 0
   Source: 'src/no_nested_borrows.rs', lines 383:0-383:92 -/
def id_mut_pair4_back'a
  (T1 T2 : Type) (p : (T1 × T2)) (ret0 : T1) : Result T1 :=
  Result.ret ret0

/- [no_nested_borrows::id_mut_pair4]: backward function 1
   Source: 'src/no_nested_borrows.rs', lines 383:0-383:92 -/
def id_mut_pair4_back'b
  (T1 T2 : Type) (p : (T1 × T2)) (ret0 : T2) : Result T2 :=
  Result.ret ret0

/- [no_nested_borrows::StructWithTuple]
   Source: 'src/no_nested_borrows.rs', lines 390:0-390:34 -/
structure StructWithTuple (T1 T2 : Type) where
  p : (T1 × T2)

/- [no_nested_borrows::new_tuple1]: forward function
   Source: 'src/no_nested_borrows.rs', lines 394:0-394:48 -/
def new_tuple1 : Result (StructWithTuple U32 U32) :=
  Result.ret { p := (1#u32, 2#u32) }

/- [no_nested_borrows::new_tuple2]: forward function
   Source: 'src/no_nested_borrows.rs', lines 398:0-398:48 -/
def new_tuple2 : Result (StructWithTuple I16 I16) :=
  Result.ret { p := (1#i16, 2#i16) }

/- [no_nested_borrows::new_tuple3]: forward function
   Source: 'src/no_nested_borrows.rs', lines 402:0-402:48 -/
def new_tuple3 : Result (StructWithTuple U64 I64) :=
  Result.ret { p := (1#u64, 2#i64) }

/- [no_nested_borrows::StructWithPair]
   Source: 'src/no_nested_borrows.rs', lines 407:0-407:33 -/
structure StructWithPair (T1 T2 : Type) where
  p : Pair T1 T2

/- [no_nested_borrows::new_pair1]: forward function
   Source: 'src/no_nested_borrows.rs', lines 411:0-411:46 -/
def new_pair1 : Result (StructWithPair U32 U32) :=
  Result.ret { p := { x := 1#u32, y := 2#u32 } }

/- [no_nested_borrows::test_constants]: forward function
   Source: 'src/no_nested_borrows.rs', lines 419:0-419:23 -/
def test_constants : Result Unit :=
  do
    let swt ← new_tuple1
    let (i, _) := swt.p
    if not (i = 1#u32)
    then Result.fail Error.panic
    else
      do
        let swt0 ← new_tuple2
        let (i0, _) := swt0.p
        if not (i0 = 1#i16)
        then Result.fail Error.panic
        else
          do
            let swt1 ← new_tuple3
            let (i1, _) := swt1.p
            if not (i1 = 1#u64)
            then Result.fail Error.panic
            else
              do
                let swp ← new_pair1
                if not (swp.p.x = 1#u32)
                then Result.fail Error.panic
                else Result.ret ()

/- Unit test for [no_nested_borrows::test_constants] -/
#assert (test_constants == .ret ())

/- [no_nested_borrows::test_weird_borrows1]: forward function
   Source: 'src/no_nested_borrows.rs', lines 428:0-428:28 -/
def test_weird_borrows1 : Result Unit :=
  Result.ret ()

/- Unit test for [no_nested_borrows::test_weird_borrows1] -/
#assert (test_weird_borrows1 == .ret ())

/- [no_nested_borrows::test_mem_replace]: merged forward/backward function
   (there is a single backward function, and the forward function returns ())
   Source: 'src/no_nested_borrows.rs', lines 438:0-438:37 -/
def test_mem_replace (px : U32) : Result U32 :=
  let y := core.mem.replace U32 px 1#u32
  if not (y = 0#u32)
  then Result.fail Error.panic
  else Result.ret 2#u32

/- [no_nested_borrows::test_shared_borrow_bool1]: forward function
   Source: 'src/no_nested_borrows.rs', lines 445:0-445:47 -/
def test_shared_borrow_bool1 (b : Bool) : Result U32 :=
  if b
  then Result.ret 0#u32
  else Result.ret 1#u32

/- [no_nested_borrows::test_shared_borrow_bool2]: forward function
   Source: 'src/no_nested_borrows.rs', lines 458:0-458:40 -/
def test_shared_borrow_bool2 : Result U32 :=
  Result.ret 0#u32

/- [no_nested_borrows::test_shared_borrow_enum1]: forward function
   Source: 'src/no_nested_borrows.rs', lines 473:0-473:52 -/
def test_shared_borrow_enum1 (l : List U32) : Result U32 :=
  match l with
  | List.Cons i l0 => Result.ret 1#u32
  | List.Nil => Result.ret 0#u32

/- [no_nested_borrows::test_shared_borrow_enum2]: forward function
   Source: 'src/no_nested_borrows.rs', lines 485:0-485:40 -/
def test_shared_borrow_enum2 : Result U32 :=
  Result.ret 0#u32

end no_nested_borrows
