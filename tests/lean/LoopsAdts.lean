-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [loops_adts]
import Aeneas
open Aeneas Aeneas.Std Result ControlFlow Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

/- You can set the `maxHeartbeats` value with the `-max-heartbeats` CLI option -/
set_option maxHeartbeats 1000000

namespace loops_adts

/- [loops_adts::List]
   Source: 'tests/src/loops-adts.rs', lines 3:0-6:1 -/
@[discriminant isize]
inductive List (T : Type) where
| Cons : T → List T → List T
| Nil : List T

/- [loops_adts::nth_shared]: loop 0:
   Source: 'tests/src/loops-adts.rs', lines 9:4-18:1 -/
def nth_shared_loop
  {T : Type} (ls : List T) (i : Std.U32) : Result (Option T) := do
  match ls with
  | List.Cons x tl =>
    if i = 0#u32
    then ok (some x)
    else let i1 ← i - 1#u32
         nth_shared_loop tl i1
  | List.Nil => ok none
partial_fixpoint

/- [loops_adts::nth_shared]:
   Source: 'tests/src/loops-adts.rs', lines 8:0-18:1 -/
@[reducible]
def nth_shared {T : Type} (ls : List T) (i : Std.U32) : Result (Option T) := do
  nth_shared_loop ls i

/- [loops_adts::nth_mut]: loop 0:
   Source: 'tests/src/loops-adts.rs', lines 21:4-30:1 -/
def nth_mut_loop
  {T : Type} (ls : List T) (i : Std.U32) :
  Result ((Option T) × (Option T → List T))
  := do
  match ls with
  | List.Cons x tl =>
    if i = 0#u32
    then
      ok (some x,
        fun o => let t := match o with
                          | some t1 => t1
                          | _ => x
                 List.Cons t tl)
    else
      let i1 ← i - 1#u32
      let (o, back) ← nth_mut_loop tl i1
      let back1 := fun o1 => let l := back o1
                             List.Cons x l
      ok (o, back1)
  | List.Nil => ok (none, fun o => List.Nil)
partial_fixpoint

/- [loops_adts::nth_mut]:
   Source: 'tests/src/loops-adts.rs', lines 20:0-30:1 -/
@[reducible]
def nth_mut
  {T : Type} (ls : List T) (i : Std.U32) :
  Result ((Option T) × (Option T → List T))
  := do
  nth_mut_loop ls i

/- [loops_adts::update_array_mut_borrow]:
   Source: 'tests/src/loops-adts.rs', lines 32:0-34:1 -/
def update_array_mut_borrow
  (a : Array Std.U32 32#usize) :
  Result ((Array Std.U32 32#usize) × (Array Std.U32 32#usize → Array Std.U32
    32#usize))
  := do
  ok (a, fun a1 => a1)

/- [loops_adts::array_mut_borrow_loop1]: loop 0:
   Source: 'tests/src/loops-adts.rs', lines 37:4-39:5 -/
def array_mut_borrow_loop1_loop
  (back : Array Std.U32 32#usize → Array Std.U32 32#usize) (b : Bool)
  (a : Array Std.U32 32#usize) :
  Result (Array Std.U32 32#usize)
  := do
  loop
    (fun (back1, b1, a1) =>
      if b1
      then
        do
        let (a2, update_array_mut_borrow_back) ← update_array_mut_borrow a1
        ok (cont (fun a3 => let a4 := update_array_mut_borrow_back a3
                            back1 a4, true, a2))
      else ok (done (back1 a1)))
    (back, b, a)

/- [loops_adts::array_mut_borrow_loop1]:
   Source: 'tests/src/loops-adts.rs', lines 36:0-40:1 -/
@[reducible]
def array_mut_borrow_loop1
  (b : Bool) (a : Array Std.U32 32#usize) :
  Result (Array Std.U32 32#usize)
  := do
  array_mut_borrow_loop1_loop (fun a1 => a1) b a

/- [loops_adts::array_mut_borrow_loop2]: loop 0:
   Source: 'tests/src/loops-adts.rs', lines 43:4-45:5 -/
def array_mut_borrow_loop2_loop
  (back : Array Std.U32 32#usize → Array Std.U32 32#usize) (b : Bool)
  (a : Array Std.U32 32#usize) :
  Result ((Array Std.U32 32#usize) × (Array Std.U32 32#usize → Array Std.U32
    32#usize))
  := do
  loop
    (fun (back1, b1, a1) =>
      if b1
      then
        do
        let (a2, update_array_mut_borrow_back) ← update_array_mut_borrow a1
        ok (cont (fun a3 => let a4 := update_array_mut_borrow_back a3
                            back1 a4, true, a2))
      else ok (done (a1, back1)))
    (back, b, a)

/- [loops_adts::array_mut_borrow_loop2]:
   Source: 'tests/src/loops-adts.rs', lines 42:0-47:1 -/
@[reducible]
def array_mut_borrow_loop2
  (b : Bool) (a : Array Std.U32 32#usize) :
  Result ((Array Std.U32 32#usize) × (Array Std.U32 32#usize → Array Std.U32
    32#usize))
  := do
  array_mut_borrow_loop2_loop (fun a1 => a1) b a

/- [loops_adts::copy_shared_array]:
   Source: 'tests/src/loops-adts.rs', lines 49:0-51:1 -/
def copy_shared_array
  (a : Array Std.U32 32#usize) : Result (Array Std.U32 32#usize) := do
  ok a

/- [loops_adts::array_shared_borrow_loop1]: loop 0:
   Source: 'tests/src/loops-adts.rs', lines 54:4-56:5 -/
def array_shared_borrow_loop1_loop
  (b : Bool) (a : Array Std.U32 32#usize) : Result Unit := do
  loop
    (fun (b1, a1) =>
      if b1
      then do
           let a2 ← copy_shared_array a1
           ok (cont (true, a2))
      else ok (done ()))
    (b, a)

/- [loops_adts::array_shared_borrow_loop1]:
   Source: 'tests/src/loops-adts.rs', lines 53:0-57:1 -/
@[reducible]
def array_shared_borrow_loop1
  (b : Bool) (a : Array Std.U32 32#usize) : Result Unit := do
  array_shared_borrow_loop1_loop b a

/- [loops_adts::array_shared_borrow_loop2]: loop 0:
   Source: 'tests/src/loops-adts.rs', lines 60:4-62:5 -/
def array_shared_borrow_loop2_loop
  (b : Bool) (a : Array Std.U32 32#usize) :
  Result (Array Std.U32 32#usize)
  := do
  loop
    (fun (b1, a1) =>
      if b1
      then do
           let a2 ← copy_shared_array a1
           ok (cont (true, a2))
      else ok (done a1))
    (b, a)

/- [loops_adts::array_shared_borrow_loop2]:
   Source: 'tests/src/loops-adts.rs', lines 59:0-64:1 -/
@[reducible]
def array_shared_borrow_loop2
  (b : Bool) (a : Array Std.U32 32#usize) :
  Result (Array Std.U32 32#usize)
  := do
  array_shared_borrow_loop2_loop b a

end loops_adts
