-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [loops_nested]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace loops_nested

/- [loops_nested::iter]: loop 1:
   Source: 'tests/src/loops-nested.rs', lines 7:8-9:9 -/
def iter_loop1 (n : U32) (j : U32) : Result Unit :=
  if j < n
  then do
       let j1 ← j + 1#u32
       iter_loop1 n j1
  else ok ()
partial_fixpoint

/- [loops_nested::iter]: loop 0:
   Source: 'tests/src/loops-nested.rs', lines 5:4-11:5 -/
def iter_loop0 (m : U32) (n : U32) (i : U32) : Result Unit :=
  if i < m
  then do
       iter_loop1 n 0#u32
       let i1 ← i + 1#u32
       iter_loop0 m n i1
  else ok ()
partial_fixpoint

/- [loops_nested::iter]:
   Source: 'tests/src/loops-nested.rs', lines 3:0-12:1 -/
@[reducible] def iter (m : U32) (n : U32) : Result Unit :=
               iter_loop0 m n 0#u32

/- [loops_nested::sum]: loop 1:
   Source: 'tests/src/loops-nested.rs', lines 19:8-22:9 -/
def sum_loop1 (n : U32) (s : U32) (j : U32) : Result U32 :=
  if j < n
  then do
       let s1 ← s + 1#u32
       let j1 ← j + 1#u32
       sum_loop1 n s1 j1
  else ok s
partial_fixpoint

/- [loops_nested::sum]: loop 0:
   Source: 'tests/src/loops-nested.rs', lines 17:4-24:5 -/
def sum_loop0 (m : U32) (n : U32) (s : U32) (i : U32) : Result U32 :=
  if i < m
  then
    do
    let s1 ← sum_loop1 n s 0#u32
    let i1 ← i + 1#u32
    sum_loop0 m n s1 i1
  else ok s
partial_fixpoint

/- [loops_nested::sum]:
   Source: 'tests/src/loops-nested.rs', lines 14:0-26:1 -/
@[reducible]
def sum (m : U32) (n : U32) : Result U32 :=
  sum_loop0 m n 0#u32 0#u32

/- [loops_nested::update_array]: loop 1:
   Source: 'tests/src/loops-nested.rs', lines 37:8-40:9 -/
def update_array_loop1
  (out : Array U8 4#usize) (j : Usize) : Result (Array U8 4#usize) :=
  if j < 4#usize
  then
    do
    let out1 ← Array.update out j 1#u8
    let j1 ← j + 1#usize
    update_array_loop1 out1 j1
  else ok out
partial_fixpoint

/- [loops_nested::update_array]: loop 0:
   Source: 'tests/src/loops-nested.rs', lines 34:4-42:5 -/
def update_array_loop0 (out : Array U8 4#usize) (i : Usize) : Result Unit :=
  if i < 4#usize
  then
    do
    let out1 ← Array.update out i 0#u8
    let out2 ← update_array_loop1 out1 0#usize
    let i1 ← i + 1#usize
    update_array_loop0 out2 i1
  else ok ()
partial_fixpoint

/- [loops_nested::update_array]:
   Source: 'tests/src/loops-nested.rs', lines 30:0-43:1 -/
def update_array : Result Unit :=
  let out := Array.repeat 4#usize 0#u8
  update_array_loop0 out 0#usize

/- [loops_nested::FACTORS]
   Source: 'tests/src/loops-nested.rs', lines 45:0-50:2 -/
@[global_simps]
def FACTORS_body : Result (Array U16 32#usize) :=
  ok
    (Array.make 32#usize [
      2285#u16, 2571#u16, 2970#u16, 1812#u16, 1493#u16, 1422#u16, 287#u16,
      202#u16, 3158#u16, 622#u16, 1577#u16, 182#u16, 962#u16, 2127#u16,
      1855#u16, 1468#u16, 573#u16, 2004#u16, 264#u16, 383#u16, 2500#u16,
      1458#u16, 1727#u16, 3199#u16, 2648#u16, 1017#u16, 732#u16, 608#u16,
      1787#u16, 411#u16, 3124#u16, 1758#u16
      ])
@[global_simps, irreducible]
def FACTORS : Array U16 32#usize := eval_global FACTORS_body

/- [loops_nested::mod_add]:
   Source: 'tests/src/loops-nested.rs', lines 52:0-54:1 -/
def mod_add (a : U32) (b : U32) : Result U32 :=
  do
  let i ← a + b
  i % 3329#u32

/- [loops_nested::mod_sub]:
   Source: 'tests/src/loops-nested.rs', lines 56:0-58:1 -/
def mod_sub (a : U32) (b : U32) : Result U32 :=
  do
  let i ← a + 3329#u32
  let i1 ← b % 3329#u32
  let i2 ← i - i1
  i2 % 3329#u32

/- [loops_nested::ntt_layer]: loop 1:
   Source: 'tests/src/loops-nested.rs', lines 68:8-80:9 -/
def ntt_layer_loop1
  (len : Usize) (start : Usize) (factor : U32) (a : Array U16 256#usize)
  (j : Usize) :
  Result (Array U16 256#usize)
  :=
  if j < len
  then
    do
    let i ← start + j
    let i1 ← Array.index_usize a i
    let c0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i2 ← i + len
    let i3 ← Array.index_usize a i2
    let c1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    let c1_factor ← c1 * factor
    let c11 ← mod_sub c0 c1_factor
    let c01 ← mod_add c0 c1_factor
    let i4 ← (↑(UScalar.cast .U16 c01) : Result U16)
    let a1 ← Array.update a i i4
    let i5 ← i + len
    let i6 ← (↑(UScalar.cast .U16 c11) : Result U16)
    let a2 ← Array.update a1 i5 i6
    let j1 ← j + 1#usize
    ntt_layer_loop1 len start factor a2 j1
  else ok a
partial_fixpoint

/- [loops_nested::ntt_layer]: loop 0:
   Source: 'tests/src/loops-nested.rs', lines 63:4-82:5 -/
def ntt_layer_loop0
  (len : Usize) (a : Array U16 256#usize) (k : Usize) (start : Usize) :
  Result (Array U16 256#usize)
  :=
  if start < 256#usize
  then
    do
    let i ← Array.index_usize FACTORS k
    let factor ← core.convert.IntoFrom.into core.convert.FromU32U16 i
    let k1 ← k + 1#usize
    let a1 ← ntt_layer_loop1 len start factor a 0#usize
    let i1 ← 2#usize * len
    let start1 ← start + i1
    ntt_layer_loop0 len a1 k1 start1
  else ok a
partial_fixpoint

/- [loops_nested::ntt_layer]:
   Source: 'tests/src/loops-nested.rs', lines 61:0-83:1 -/
@[reducible]
def ntt_layer
  (a : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt_layer_loop0 len a k 0#usize

/- [loops_nested::Key]
   Source: 'tests/src/loops-nested.rs', lines 85:0-88:1 -/
structure Key where
  seed : Array U8 32#usize
  atranspose : Array U16 32#usize

/- [loops_nested::{loops_nested::Key}::atranspose_mut]:
   Source: 'tests/src/loops-nested.rs', lines 91:4-93:5 -/
def Key.atranspose_mut
  (self : Key) :
  Result ((Array U16 32#usize) × (Array U16 32#usize → Key))
  :=
  let back := fun ret => { self with atranspose := ret }
  ok (self.atranspose, back)

/- [loops_nested::shake_init]:
   Source: 'tests/src/loops-nested.rs', lines 98:0-98:40 -/
def shake_init (_state : Array U8 8#usize) : Result (Array U8 8#usize) :=
  ok _state

/- [loops_nested::shake_append]:
   Source: 'tests/src/loops-nested.rs', lines 99:0-99:56 -/
def shake_append
  (_state : Array U8 8#usize) (_data : Slice U8) : Result (Array U8 8#usize) :=
  ok _state

/- [loops_nested::shake_state_copy]:
   Source: 'tests/src/loops-nested.rs', lines 100:0-100:62 -/
def shake_state_copy
  (_src : Array U8 8#usize) (_dst : Array U8 8#usize) :
  Result (Array U8 8#usize)
  :=
  ok _dst

/- [loops_nested::sample_ntt]:
   Source: 'tests/src/loops-nested.rs', lines 101:0-101:56 -/
def sample_ntt
  (_state : Array U8 8#usize) (_dst : U16) :
  Result ((Array U8 8#usize) × U16)
  :=
  ok (_state, _dst)

/- [loops_nested::generate_matrix_inner]: loop 0:
   Source: 'tests/src/loops-nested.rs', lines 109:4-113:5 -/
def generate_matrix_inner_loop
  (key : Key) (state : Array U8 8#usize) (j : Usize) :
  Result (Key × (Array U8 8#usize))
  :=
  if j < 4#usize
  then
    do
    let (a_transpose, atranspose_mut_back) ← Key.atranspose_mut key
    let (i, index_mut_back) ← Array.index_mut_usize a_transpose j
    let (state1, i1) ← sample_ntt state i
    let j1 ← j + 1#usize
    let a_transpose1 := index_mut_back i1
    let key1 := atranspose_mut_back a_transpose1
    generate_matrix_inner_loop key1 state1 j1
  else ok (key, state)
partial_fixpoint

/- [loops_nested::generate_matrix_inner]:
   Source: 'tests/src/loops-nested.rs', lines 104:0-114:1 -/
@[reducible]
def generate_matrix_inner
  (key : Key) (state : Array U8 8#usize) :
  Result (Key × (Array U8 8#usize))
  :=
  generate_matrix_inner_loop key state 0#usize

/- [loops_nested::generate_matrix]: loop 1:
   Source: 'tests/src/loops-nested.rs', lines 132:8-140:9 -/
def generate_matrix_loop1
  (state_base : Array U8 8#usize) (i : U8) (key : Key)
  (state_work : Array U8 8#usize) (coordinates : Array U8 2#usize) (j : U8) :
  Result (Key × (Array U8 8#usize) × (Array U8 2#usize))
  :=
  if j < 4#u8
  then
    do
    let coordinates1 ← Array.update coordinates 0#usize j
    let state_work1 ← shake_state_copy state_base state_work
    let s ← (↑(Array.to_slice coordinates1) : Result (Slice U8))
    let state_work2 ← shake_append state_work1 s
    let (a_transpose, atranspose_mut_back) ← Key.atranspose_mut key
    let i1 ← i * 4#u8
    let i2 ← i1 + j
    let i3 ← (↑(UScalar.cast .Usize i2) : Result Usize)
    let (i4, index_mut_back) ← Array.index_mut_usize a_transpose i3
    let (state_work3, i5) ← sample_ntt state_work2 i4
    let j1 ← j + 1#u8
    let a_transpose1 := index_mut_back i5
    let key1 := atranspose_mut_back a_transpose1
    generate_matrix_loop1 state_base i key1 state_work3 coordinates1 j1
  else ok (key, state_work, coordinates)
partial_fixpoint

/- [loops_nested::generate_matrix]: loop 0:
   Source: 'tests/src/loops-nested.rs', lines 129:4-142:5 -/
def generate_matrix_loop0
  (state_base : Array U8 8#usize) (key : Key) (state_work : Array U8 8#usize)
  (coordinates : Array U8 2#usize) (i : U8) :
  Result (Key × (Array U8 8#usize))
  :=
  if i < 4#u8
  then
    do
    let coordinates1 ← Array.update coordinates 1#usize i
    let (key1, state_work1, coordinates2) ←
      generate_matrix_loop1 state_base i key state_work coordinates1 0#u8
    let i1 ← i + 1#u8
    generate_matrix_loop0 state_base key1 state_work1 coordinates2 i1
  else ok (key, state_work)
partial_fixpoint

/- [loops_nested::generate_matrix]:
   Source: 'tests/src/loops-nested.rs', lines 117:0-143:1 -/
def generate_matrix
  (key : Key) (state_base : Array U8 8#usize) (state_work : Array U8 8#usize) :
  Result (Key × (Array U8 8#usize) × (Array U8 8#usize))
  :=
  do
  let coordinates := Array.repeat 2#usize 0#u8
  let state_base1 ← shake_init state_base
  let s ← (↑(Array.to_slice key.seed) : Result (Slice U8))
  let state_base2 ← shake_append state_base1 s
  let (key1, state_work1) ←
    generate_matrix_loop0 state_base2 key state_work coordinates 0#u8
  ok (key1, state_base2, state_work1)

end loops_nested
