-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [no_nested_borrows]
import Base.Primitives

/- [no_nested_borrows::Pair] -/
structure pair_t (T1 T2 : Type) where
  pair_x : T1
  pair_y : T2

/- [no_nested_borrows::List] -/
inductive list_t (T : Type) :=
| Cons : T -> list_t T -> list_t T
| Nil : list_t T

/- [no_nested_borrows::One] -/
inductive one_t (T1 : Type) :=
| One : T1 -> one_t T1

/- [no_nested_borrows::EmptyEnum] -/
inductive empty_enum_t :=
| Empty : empty_enum_t

/- [no_nested_borrows::Enum] -/
inductive enum_t :=
| Variant1 : enum_t
| Variant2 : enum_t

/- [no_nested_borrows::EmptyStruct] -/
structure empty_struct_t where

/- [no_nested_borrows::Sum] -/
inductive sum_t (T1 T2 : Type) :=
| Left : T1 -> sum_t T1 T2
| Right : T2 -> sum_t T1 T2

/- [no_nested_borrows::neg_test] -/
def neg_test_fwd (x : I32) : Result I32 :=
  - x

/- [no_nested_borrows::add_test] -/
def add_test_fwd (x : U32) (y : U32) : Result U32 :=
  x + y

/- [no_nested_borrows::subs_test] -/
def subs_test_fwd (x : U32) (y : U32) : Result U32 :=
  x - y

/- [no_nested_borrows::div_test] -/
def div_test_fwd (x : U32) (y : U32) : Result U32 :=
  x / y

/- [no_nested_borrows::div_test1] -/
def div_test1_fwd (x : U32) : Result U32 :=
  x / (U32.ofInt 2 (by intlit))

/- [no_nested_borrows::rem_test] -/
def rem_test_fwd (x : U32) (y : U32) : Result U32 :=
  x % y

/- [no_nested_borrows::cast_test] -/
def cast_test_fwd (x : U32) : Result I32 :=
  Scalar.cast .I32 x

/- [no_nested_borrows::test2] -/
def test2_fwd : Result Unit :=
  do
    let _ ⟵ (U32.ofInt 23 (by intlit)) + (U32.ofInt 44 (by intlit))
    Result.ret ()

/- Unit test for [no_nested_borrows::test2] -/
#assert (test2_fwd == .ret ())

/- [no_nested_borrows::get_max] -/
def get_max_fwd (x : U32) (y : U32) : Result U32 :=
  if 𝒽: x >= y
  then Result.ret x
  else Result.ret y

/- [no_nested_borrows::test3] -/
def test3_fwd : Result Unit :=
  do
    let x ⟵ get_max_fwd (U32.ofInt 4 (by intlit)) (U32.ofInt 3 (by intlit))
    let y ⟵ get_max_fwd (U32.ofInt 10 (by intlit)) (U32.ofInt 11 (by intlit))
    let z ⟵ x + y
    if 𝒽: not (z = (U32.ofInt 15 (by intlit)))
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [no_nested_borrows::test3] -/
#assert (test3_fwd == .ret ())

/- [no_nested_borrows::test_neg1] -/
def test_neg1_fwd : Result Unit :=
  do
    let y ⟵ - (I32.ofInt 3 (by intlit))
    if 𝒽: not (y = (I32.ofInt (-(3:Int)) (by intlit)))
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [no_nested_borrows::test_neg1] -/
#assert (test_neg1_fwd == .ret ())

/- [no_nested_borrows::refs_test1] -/
def refs_test1_fwd : Result Unit :=
  if 𝒽: not ((I32.ofInt 1 (by intlit)) = (I32.ofInt 1 (by intlit)))
  then Result.fail Error.panic
  else Result.ret ()

/- Unit test for [no_nested_borrows::refs_test1] -/
#assert (refs_test1_fwd == .ret ())

/- [no_nested_borrows::refs_test2] -/
def refs_test2_fwd : Result Unit :=
  if 𝒽: not ((I32.ofInt 2 (by intlit)) = (I32.ofInt 2 (by intlit)))
  then Result.fail Error.panic
  else
    if 𝒽: not ((I32.ofInt 0 (by intlit)) = (I32.ofInt 0 (by intlit)))
    then Result.fail Error.panic
    else
      if 𝒽: not ((I32.ofInt 2 (by intlit)) = (I32.ofInt 2 (by intlit)))
      then Result.fail Error.panic
      else
        if 𝒽: not ((I32.ofInt 2 (by intlit)) = (I32.ofInt 2 (by intlit)))
        then Result.fail Error.panic
        else Result.ret ()

/- Unit test for [no_nested_borrows::refs_test2] -/
#assert (refs_test2_fwd == .ret ())

/- [no_nested_borrows::test_list1] -/
def test_list1_fwd : Result Unit :=
  Result.ret ()

/- Unit test for [no_nested_borrows::test_list1] -/
#assert (test_list1_fwd == .ret ())

/- [no_nested_borrows::test_box1] -/
def test_box1_fwd : Result Unit :=
  let b := (I32.ofInt 1 (by intlit))
  let x := b
  if 𝒽: not (x = (I32.ofInt 1 (by intlit)))
  then Result.fail Error.panic
  else Result.ret ()

/- Unit test for [no_nested_borrows::test_box1] -/
#assert (test_box1_fwd == .ret ())

/- [no_nested_borrows::copy_int] -/
def copy_int_fwd (x : I32) : Result I32 :=
  Result.ret x

/- [no_nested_borrows::test_unreachable] -/
def test_unreachable_fwd (b : Bool) : Result Unit :=
  if 𝒽: b
  then Result.fail Error.panic
  else Result.ret ()

/- [no_nested_borrows::test_panic] -/
def test_panic_fwd (b : Bool) : Result Unit :=
  if 𝒽: b
  then Result.fail Error.panic
  else Result.ret ()

/- [no_nested_borrows::test_copy_int] -/
def test_copy_int_fwd : Result Unit :=
  do
    let y ⟵ copy_int_fwd (I32.ofInt 0 (by intlit))
    if 𝒽: not ((I32.ofInt 0 (by intlit)) = y)
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [no_nested_borrows::test_copy_int] -/
#assert (test_copy_int_fwd == .ret ())

/- [no_nested_borrows::is_cons] -/
def is_cons_fwd (T : Type) (l : list_t T) : Result Bool :=
  match 𝒽: l with
  | list_t.Cons t l0 => Result.ret true
  | list_t.Nil => Result.ret false

/- [no_nested_borrows::test_is_cons] -/
def test_is_cons_fwd : Result Unit :=
  do
    let l := list_t.Nil
    let b ⟵ is_cons_fwd I32 (list_t.Cons (I32.ofInt 0 (by intlit)) l)
    if 𝒽: not b
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [no_nested_borrows::test_is_cons] -/
#assert (test_is_cons_fwd == .ret ())

/- [no_nested_borrows::split_list] -/
def split_list_fwd (T : Type) (l : list_t T) : Result (T × (list_t T)) :=
  match 𝒽: l with
  | list_t.Cons hd tl => Result.ret (hd, tl)
  | list_t.Nil => Result.fail Error.panic

/- [no_nested_borrows::test_split_list] -/
def test_split_list_fwd : Result Unit :=
  do
    let l := list_t.Nil
    let p ⟵ split_list_fwd I32 (list_t.Cons (I32.ofInt 0 (by intlit)) l)
    let (hd, _) := p
    if 𝒽: not (hd = (I32.ofInt 0 (by intlit)))
    then Result.fail Error.panic
    else Result.ret ()

/- Unit test for [no_nested_borrows::test_split_list] -/
#assert (test_split_list_fwd == .ret ())

/- [no_nested_borrows::choose] -/
def choose_fwd (T : Type) (b : Bool) (x : T) (y : T) : Result T :=
  if 𝒽: b
  then Result.ret x
  else Result.ret y

/- [no_nested_borrows::choose] -/
def choose_back
  (T : Type) (b : Bool) (x : T) (y : T) (ret0 : T) : Result (T × T) :=
  if 𝒽: b
  then Result.ret (ret0, y)
  else Result.ret (x, ret0)

/- [no_nested_borrows::choose_test] -/
def choose_test_fwd : Result Unit :=
  do
    let z ⟵
      choose_fwd I32 true (I32.ofInt 0 (by intlit)) (I32.ofInt 0 (by intlit))
    let z0 ⟵ z + (I32.ofInt 1 (by intlit))
    if 𝒽: not (z0 = (I32.ofInt 1 (by intlit)))
    then Result.fail Error.panic
    else
      do
        let (x, y) ⟵
          choose_back I32 true (I32.ofInt 0 (by intlit))
            (I32.ofInt 0 (by intlit)) z0
        if 𝒽: not (x = (I32.ofInt 1 (by intlit)))
        then Result.fail Error.panic
        else
          if 𝒽: not (y = (I32.ofInt 0 (by intlit)))
          then Result.fail Error.panic
          else Result.ret ()

/- Unit test for [no_nested_borrows::choose_test] -/
#assert (choose_test_fwd == .ret ())

/- [no_nested_borrows::test_char] -/
def test_char_fwd : Result Char :=
  Result.ret 'a'

/- [no_nested_borrows::NodeElem] -/
mutual inductive node_elem_t (T : Type) :=
| Cons : tree_t T -> node_elem_t T -> node_elem_t T
| Nil : node_elem_t T

/- [no_nested_borrows::Tree] -/
inductive tree_t (T : Type) :=
| Leaf : T -> tree_t T
| Node : T -> node_elem_t T -> tree_t T -> tree_t T
end

/- [no_nested_borrows::list_length] -/
def list_length_fwd (T : Type) (l : list_t T) : Result U32 :=
  match 𝒽: l with
  | list_t.Cons t l1 =>
    do
      let i ⟵ list_length_fwd T l1
      (U32.ofInt 1 (by intlit)) + i
  | list_t.Nil => Result.ret (U32.ofInt 0 (by intlit))

/- [no_nested_borrows::list_nth_shared] -/
def list_nth_shared_fwd (T : Type) (l : list_t T) (i : U32) : Result T :=
  match 𝒽: l with
  | list_t.Cons x tl =>
    if 𝒽: i = (U32.ofInt 0 (by intlit))
    then Result.ret x
    else
      do
        let i0 ⟵ i - (U32.ofInt 1 (by intlit))
        let t ⟵ list_nth_shared_fwd T tl i0
        Result.ret t
  | list_t.Nil => Result.fail Error.panic

/- [no_nested_borrows::list_nth_mut] -/
def list_nth_mut_fwd (T : Type) (l : list_t T) (i : U32) : Result T :=
  match 𝒽: l with
  | list_t.Cons x tl =>
    if 𝒽: i = (U32.ofInt 0 (by intlit))
    then Result.ret x
    else
      do
        let i0 ⟵ i - (U32.ofInt 1 (by intlit))
        let t ⟵ list_nth_mut_fwd T tl i0
        Result.ret t
  | list_t.Nil => Result.fail Error.panic

/- [no_nested_borrows::list_nth_mut] -/
def list_nth_mut_back
  (T : Type) (l : list_t T) (i : U32) (ret0 : T) : Result (list_t T) :=
  match 𝒽: l with
  | list_t.Cons x tl =>
    if 𝒽: i = (U32.ofInt 0 (by intlit))
    then Result.ret (list_t.Cons ret0 tl)
    else
      do
        let i0 ⟵ i - (U32.ofInt 1 (by intlit))
        let tl0 ⟵ list_nth_mut_back T tl i0 ret0
        Result.ret (list_t.Cons x tl0)
  | list_t.Nil => Result.fail Error.panic

/- [no_nested_borrows::list_rev_aux] -/
def list_rev_aux_fwd
  (T : Type) (li : list_t T) (lo : list_t T) : Result (list_t T) :=
  match 𝒽: li with
  | list_t.Cons hd tl =>
    do
      let l ⟵ list_rev_aux_fwd T tl (list_t.Cons hd lo)
      Result.ret l
  | list_t.Nil => Result.ret lo

/- [no_nested_borrows::list_rev] -/
def list_rev_fwd_back (T : Type) (l : list_t T) : Result (list_t T) :=
  let li := mem_replace_fwd (list_t T) l list_t.Nil
  list_rev_aux_fwd T li list_t.Nil

/- [no_nested_borrows::test_list_functions] -/
def test_list_functions_fwd : Result Unit :=
  do
    let l := list_t.Nil
    let l0 := list_t.Cons (I32.ofInt 2 (by intlit)) l
    let l1 := list_t.Cons (I32.ofInt 1 (by intlit)) l0
    let i ⟵ list_length_fwd I32 (list_t.Cons (I32.ofInt 0 (by intlit)) l1)
    if 𝒽: not (i = (U32.ofInt 3 (by intlit)))
    then Result.fail Error.panic
    else
      do
        let i0 ⟵
          list_nth_shared_fwd I32 (list_t.Cons (I32.ofInt 0 (by intlit)) l1)
            (U32.ofInt 0 (by intlit))
        if 𝒽: not (i0 = (I32.ofInt 0 (by intlit)))
        then Result.fail Error.panic
        else
          do
            let i1 ⟵
              list_nth_shared_fwd I32 (list_t.Cons (I32.ofInt 0 (by intlit))
                l1) (U32.ofInt 1 (by intlit))
            if 𝒽: not (i1 = (I32.ofInt 1 (by intlit)))
            then Result.fail Error.panic
            else
              do
                let i2 ⟵
                  list_nth_shared_fwd I32 (list_t.Cons
                    (I32.ofInt 0 (by intlit)) l1) (U32.ofInt 2 (by intlit))
                if 𝒽: not (i2 = (I32.ofInt 2 (by intlit)))
                then Result.fail Error.panic
                else
                  do
                    let ls ⟵
                      list_nth_mut_back I32 (list_t.Cons
                        (I32.ofInt 0 (by intlit)) l1) (U32.ofInt 1 (by intlit))
                        (I32.ofInt 3 (by intlit))
                    let i3 ⟵
                      list_nth_shared_fwd I32 ls (U32.ofInt 0 (by intlit))
                    if 𝒽: not (i3 = (I32.ofInt 0 (by intlit)))
                    then Result.fail Error.panic
                    else
                      do
                        let i4 ⟵
                          list_nth_shared_fwd I32 ls (U32.ofInt 1 (by intlit))
                        if 𝒽: not (i4 = (I32.ofInt 3 (by intlit)))
                        then Result.fail Error.panic
                        else
                          do
                            let i5 ⟵
                              list_nth_shared_fwd I32 ls
                                (U32.ofInt 2 (by intlit))
                            if 𝒽: not (i5 = (I32.ofInt 2 (by intlit)))
                            then Result.fail Error.panic
                            else Result.ret ()

/- Unit test for [no_nested_borrows::test_list_functions] -/
#assert (test_list_functions_fwd == .ret ())

/- [no_nested_borrows::id_mut_pair1] -/
def id_mut_pair1_fwd (T1 T2 : Type) (x : T1) (y : T2) : Result (T1 × T2) :=
  Result.ret (x, y)

/- [no_nested_borrows::id_mut_pair1] -/
def id_mut_pair1_back
  (T1 T2 : Type) (x : T1) (y : T2) (ret0 : (T1 × T2)) : Result (T1 × T2) :=
  let (t, t0) := ret0
  Result.ret (t, t0)

/- [no_nested_borrows::id_mut_pair2] -/
def id_mut_pair2_fwd (T1 T2 : Type) (p : (T1 × T2)) : Result (T1 × T2) :=
  let (t, t0) := p
  Result.ret (t, t0)

/- [no_nested_borrows::id_mut_pair2] -/
def id_mut_pair2_back
  (T1 T2 : Type) (p : (T1 × T2)) (ret0 : (T1 × T2)) : Result (T1 × T2) :=
  let (t, t0) := ret0
  Result.ret (t, t0)

/- [no_nested_borrows::id_mut_pair3] -/
def id_mut_pair3_fwd (T1 T2 : Type) (x : T1) (y : T2) : Result (T1 × T2) :=
  Result.ret (x, y)

/- [no_nested_borrows::id_mut_pair3] -/
def id_mut_pair3_back'a
  (T1 T2 : Type) (x : T1) (y : T2) (ret0 : T1) : Result T1 :=
  Result.ret ret0

/- [no_nested_borrows::id_mut_pair3] -/
def id_mut_pair3_back'b
  (T1 T2 : Type) (x : T1) (y : T2) (ret0 : T2) : Result T2 :=
  Result.ret ret0

/- [no_nested_borrows::id_mut_pair4] -/
def id_mut_pair4_fwd (T1 T2 : Type) (p : (T1 × T2)) : Result (T1 × T2) :=
  let (t, t0) := p
  Result.ret (t, t0)

/- [no_nested_borrows::id_mut_pair4] -/
def id_mut_pair4_back'a
  (T1 T2 : Type) (p : (T1 × T2)) (ret0 : T1) : Result T1 :=
  Result.ret ret0

/- [no_nested_borrows::id_mut_pair4] -/
def id_mut_pair4_back'b
  (T1 T2 : Type) (p : (T1 × T2)) (ret0 : T2) : Result T2 :=
  Result.ret ret0

/- [no_nested_borrows::StructWithTuple] -/
structure struct_with_tuple_t (T1 T2 : Type) where
  struct_with_tuple_p : (T1 × T2)

/- [no_nested_borrows::new_tuple1] -/
def new_tuple1_fwd : Result (struct_with_tuple_t U32 U32) :=
  Result.ret
  {
    struct_with_tuple_p :=
      ((U32.ofInt 1 (by intlit)), (U32.ofInt 2 (by intlit)))
  }

/- [no_nested_borrows::new_tuple2] -/
def new_tuple2_fwd : Result (struct_with_tuple_t I16 I16) :=
  Result.ret
  {
    struct_with_tuple_p :=
      ((I16.ofInt 1 (by intlit)), (I16.ofInt 2 (by intlit)))
  }

/- [no_nested_borrows::new_tuple3] -/
def new_tuple3_fwd : Result (struct_with_tuple_t U64 I64) :=
  Result.ret
  {
    struct_with_tuple_p :=
      ((U64.ofInt 1 (by intlit)), (I64.ofInt 2 (by intlit)))
  }

/- [no_nested_borrows::StructWithPair] -/
structure struct_with_pair_t (T1 T2 : Type) where
  struct_with_pair_p : pair_t T1 T2

/- [no_nested_borrows::new_pair1] -/
def new_pair1_fwd : Result (struct_with_pair_t U32 U32) :=
  Result.ret
  {
    struct_with_pair_p :=
      {
        pair_x := (U32.ofInt 1 (by intlit)),
        pair_y := (U32.ofInt 2 (by intlit))
      }
  }

/- [no_nested_borrows::test_constants] -/
def test_constants_fwd : Result Unit :=
  do
    let swt ⟵ new_tuple1_fwd
    let (i, _) := swt.struct_with_tuple_p
    if 𝒽: not (i = (U32.ofInt 1 (by intlit)))
    then Result.fail Error.panic
    else
      do
        let swt0 ⟵ new_tuple2_fwd
        let (i0, _) := swt0.struct_with_tuple_p
        if 𝒽: not (i0 = (I16.ofInt 1 (by intlit)))
        then Result.fail Error.panic
        else
          do
            let swt1 ⟵ new_tuple3_fwd
            let (i1, _) := swt1.struct_with_tuple_p
            if 𝒽: not (i1 = (U64.ofInt 1 (by intlit)))
            then Result.fail Error.panic
            else
              do
                let swp ⟵ new_pair1_fwd
                if 𝒽: not (swp.struct_with_pair_p.pair_x =
                  (U32.ofInt 1 (by intlit)))
                then Result.fail Error.panic
                else Result.ret ()

/- Unit test for [no_nested_borrows::test_constants] -/
#assert (test_constants_fwd == .ret ())

/- [no_nested_borrows::test_weird_borrows1] -/
def test_weird_borrows1_fwd : Result Unit :=
  Result.ret ()

/- Unit test for [no_nested_borrows::test_weird_borrows1] -/
#assert (test_weird_borrows1_fwd == .ret ())

/- [no_nested_borrows::test_mem_replace] -/
def test_mem_replace_fwd_back (px : U32) : Result U32 :=
  let y := mem_replace_fwd U32 px (U32.ofInt 1 (by intlit))
  if 𝒽: not (y = (U32.ofInt 0 (by intlit)))
  then Result.fail Error.panic
  else Result.ret (U32.ofInt 2 (by intlit))

/- [no_nested_borrows::test_shared_borrow_bool1] -/
def test_shared_borrow_bool1_fwd (b : Bool) : Result U32 :=
  if 𝒽: b
  then Result.ret (U32.ofInt 0 (by intlit))
  else Result.ret (U32.ofInt 1 (by intlit))

/- [no_nested_borrows::test_shared_borrow_bool2] -/
def test_shared_borrow_bool2_fwd : Result U32 :=
  Result.ret (U32.ofInt 0 (by intlit))

/- [no_nested_borrows::test_shared_borrow_enum1] -/
def test_shared_borrow_enum1_fwd (l : list_t U32) : Result U32 :=
  match 𝒽: l with
  | list_t.Cons i l0 => Result.ret (U32.ofInt 1 (by intlit))
  | list_t.Nil => Result.ret (U32.ofInt 0 (by intlit))

/- [no_nested_borrows::test_shared_borrow_enum2] -/
def test_shared_borrow_enum2_fwd : Result U32 :=
  Result.ret (U32.ofInt 0 (by intlit))

