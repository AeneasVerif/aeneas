-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [closures]
import Aeneas
open Aeneas Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace closures

/- [closures::call_fn_no_state::closure]
   Source: 'tests/src/closures.rs', lines 4:15-4:40 -/
@[reducible]
def call_fn_no_state.closure := Unit

/- [closures::call_fn_no_state::{core::ops::function::Fn<(u32), u32> for closures::call_fn_no_state::closure}::call]:
   Source: 'tests/src/closures.rs', lines 4:15-4:40 -/
def call_fn_no_state.FnclosureTupleU32U32.call
  (c : call_fn_no_state.closure) (tupled_args : Std.U32) : Result Std.U32 := do
  tupled_args + 1#u32

/- [closures::call_fn_no_state]:
   Source: 'tests/src/closures.rs', lines 3:0-6:1 -/
def call_fn_no_state (i : Std.U32) : Result Std.U32 := do
  call_fn_no_state.FnclosureTupleU32U32.call () i

/- [closures::call_fn_no_state::{core::ops::function::FnMut<(u32), u32> for closures::call_fn_no_state::closure}::call_mut]:
   Source: 'tests/src/closures.rs', lines 4:15-4:40 -/
def call_fn_no_state.FnMutclosureTupleU32U32.call_mut
  (state : call_fn_no_state.closure) (args : Std.U32) :
  Result (Std.U32 × call_fn_no_state.closure)
  := do
  let i ← call_fn_no_state.FnclosureTupleU32U32.call state args
  ok (i, state)

/- [closures::call_fn_no_state::{core::ops::function::FnOnce<(u32), u32> for closures::call_fn_no_state::closure}::call_once]:
   Source: 'tests/src/closures.rs', lines 4:15-4:40 -/
def call_fn_no_state.FnOnceclosureTupleU32U32.call_once
  (c : call_fn_no_state.closure) (i : Std.U32) : Result Std.U32 := do
  let (i1, _) ← call_fn_no_state.FnMutclosureTupleU32U32.call_mut c i
  ok i1

/- Trait implementation: [closures::call_fn_no_state::{core::ops::function::FnOnce<(u32), u32> for closures::call_fn_no_state::closure}]
   Source: 'tests/src/closures.rs', lines 4:15-4:40 -/
@[reducible]
def core.ops.function.FnOnceclosureTupleU32U32 : core.ops.function.FnOnce
  call_fn_no_state.closure Std.U32 Std.U32 := {
  call_once := call_fn_no_state.FnOnceclosureTupleU32U32.call_once
}

/- Trait implementation: [closures::call_fn_no_state::{core::ops::function::FnMut<(u32), u32> for closures::call_fn_no_state::closure}]
   Source: 'tests/src/closures.rs', lines 4:15-4:40 -/
@[reducible]
def core.ops.function.FnMutclosureTupleU32U32 : core.ops.function.FnMut
  call_fn_no_state.closure Std.U32 Std.U32 := {
  FnOnceInst := core.ops.function.FnOnceclosureTupleU32U32
  call_mut := call_fn_no_state.FnMutclosureTupleU32U32.call_mut
}

/- Trait implementation: [closures::call_fn_no_state::{core::ops::function::Fn<(u32), u32> for closures::call_fn_no_state::closure}]
   Source: 'tests/src/closures.rs', lines 4:15-4:40 -/
@[reducible]
def core.ops.function.FnclosureTupleU32U32 : core.ops.function.Fn
  call_fn_no_state.closure Std.U32 Std.U32 := {
  FnMutInst := core.ops.function.FnMutclosureTupleU32U32
  call := call_fn_no_state.FnclosureTupleU32U32.call
}

/- [closures::call_fn_shared::closure]
   Source: 'tests/src/closures.rs', lines 9:15-9:40 -/
@[reducible]
def call_fn_shared.closure := Slice Std.U8

/- [closures::call_fn_shared::{core::ops::function::Fn<(usize), u8> for closures::call_fn_shared::closure<0>}::call]:
   Source: 'tests/src/closures.rs', lines 9:15-9:40 -/
def call_fn_shared.FnclosureTupleUsizeU8.call
  (c : call_fn_shared.closure) (tupled_args : Std.Usize) : Result Std.U8 := do
  Slice.index_usize c tupled_args

/- [closures::call_fn_shared]:
   Source: 'tests/src/closures.rs', lines 8:0-11:1 -/
def call_fn_shared (a : Slice Std.U8) (i : Std.Usize) : Result Std.U8 := do
  call_fn_shared.FnclosureTupleUsizeU8.call a i

/- [closures::call_fn_shared::{core::ops::function::FnMut<(usize), u8> for closures::call_fn_shared::closure<0>}::call_mut]:
   Source: 'tests/src/closures.rs', lines 9:15-9:40 -/
def call_fn_shared.FnMutclosureTupleUsizeU8.call_mut
  (state : call_fn_shared.closure) (args : Std.Usize) :
  Result (Std.U8 × call_fn_shared.closure)
  := do
  let i ← call_fn_shared.FnclosureTupleUsizeU8.call state args
  ok (i, state)

/- [closures::call_fn_shared::{core::ops::function::FnOnce<(usize), u8> for closures::call_fn_shared::closure<0>}::call_once]:
   Source: 'tests/src/closures.rs', lines 9:15-9:40 -/
def call_fn_shared.FnOnceclosureTupleUsizeU8.call_once
  (c : call_fn_shared.closure) (i : Std.Usize) : Result Std.U8 := do
  let (i1, _) ← call_fn_shared.FnMutclosureTupleUsizeU8.call_mut c i
  ok i1

/- Trait implementation: [closures::call_fn_shared::{core::ops::function::FnOnce<(usize), u8> for closures::call_fn_shared::closure<0>}]
   Source: 'tests/src/closures.rs', lines 9:15-9:40 -/
@[reducible]
def core.ops.function.FnOnceclosureTupleUsizeU8 : core.ops.function.FnOnce
  call_fn_shared.closure Std.Usize Std.U8 := {
  call_once := call_fn_shared.FnOnceclosureTupleUsizeU8.call_once
}

/- Trait implementation: [closures::call_fn_shared::{core::ops::function::FnMut<(usize), u8> for closures::call_fn_shared::closure<0>}]
   Source: 'tests/src/closures.rs', lines 9:15-9:40 -/
@[reducible]
def core.ops.function.FnMutclosureTupleUsizeU8 : core.ops.function.FnMut
  call_fn_shared.closure Std.Usize Std.U8 := {
  FnOnceInst := core.ops.function.FnOnceclosureTupleUsizeU8
  call_mut := call_fn_shared.FnMutclosureTupleUsizeU8.call_mut
}

/- Trait implementation: [closures::call_fn_shared::{core::ops::function::Fn<(usize), u8> for closures::call_fn_shared::closure<0>}]
   Source: 'tests/src/closures.rs', lines 9:15-9:40 -/
@[reducible]
def core.ops.function.FnclosureTupleUsizeU8 : core.ops.function.Fn
  call_fn_shared.closure Std.Usize Std.U8 := {
  FnMutInst := core.ops.function.FnMutclosureTupleUsizeU8
  call := call_fn_shared.FnclosureTupleUsizeU8.call
}

end closures
