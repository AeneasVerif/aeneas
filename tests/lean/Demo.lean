-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [demo]
import Base
open Primitives

namespace demo

/- [demo::choose]: forward function -/
def choose (T : Type) (b : Bool) (x : T) (y : T) : Result T :=
  if b
  then Result.ret x
  else Result.ret y

/- [demo::choose]: backward function 0 -/
def choose_back
  (T : Type) (b : Bool) (x : T) (y : T) (ret0 : T) : Result (T × T) :=
  if b
  then Result.ret (ret0, y)
  else Result.ret (x, ret0)

/- [demo::mul2_add1]: forward function -/
def mul2_add1 (x : U32) : Result U32 :=
  do
    let i ← x + x
    i + 1#u32

/- [demo::use_mul2_add1]: forward function -/
def use_mul2_add1 (x : U32) (y : U32) : Result U32 :=
  do
    let i ← mul2_add1 x
    i + y

/- [demo::CList] -/
inductive CList (T : Type) :=
| CCons : T → CList T → CList T
| CNil : CList T

/- [demo::list_nth]: forward function -/
divergent def list_nth (T : Type) (l : CList T) (i : U32) : Result T :=
  match l with
  | CList.CCons x tl =>
    if i = 0#u32
    then Result.ret x
    else do
           let i0 ← i - 1#u32
           list_nth T tl i0
  | CList.CNil => Result.fail Error.panic

/- [demo::list_nth]: backward function 0 -/
divergent def list_nth_back
  (T : Type) (l : CList T) (i : U32) (ret0 : T) : Result (CList T) :=
  match l with
  | CList.CCons x tl =>
    if i = 0#u32
    then Result.ret (CList.CCons ret0 tl)
    else
      do
        let i0 ← i - 1#u32
        let tl0 ← list_nth_back T tl i0 ret0
        Result.ret (CList.CCons x tl0)
  | CList.CNil => Result.fail Error.panic

/- [demo::list_nth1]: loop 0: forward function -/
divergent def list_nth1_loop (T : Type) (l : CList T) (i : U32) : Result T :=
  match l with
  | CList.CCons x tl =>
    if i = 0#u32
    then Result.ret x
    else do
           let i0 ← i - 1#u32
           list_nth1_loop T tl i0
  | CList.CNil => Result.fail Error.panic

/- [demo::list_nth1]: forward function -/
def list_nth1 (T : Type) (l : CList T) (i : U32) : Result T :=
  list_nth1_loop T l i

/- [demo::list_nth1]: loop 0: backward function 0 -/
divergent def list_nth1_loop_back
  (T : Type) (l : CList T) (i : U32) (ret0 : T) : Result (CList T) :=
  match l with
  | CList.CCons x tl =>
    if i = 0#u32
    then Result.ret (CList.CCons ret0 tl)
    else
      do
        let i0 ← i - 1#u32
        let tl0 ← list_nth1_loop_back T tl i0 ret0
        Result.ret (CList.CCons x tl0)
  | CList.CNil => Result.fail Error.panic

/- [demo::list_nth1]: backward function 0 -/
def list_nth1_back
  (T : Type) (l : CList T) (i : U32) (ret0 : T) : Result (CList T) :=
  list_nth1_loop_back T l i ret0

/- Trait declaration: [demo::ToU32] -/
structure ToU32 (Self : Type) where
  to_u32 : Self → Result U32

/- [demo::u32::{0}::to_u32]: forward function -/
def u32.to_u32 (self : U32) : Result U32 :=
  Result.ret self

/- Trait implementation: [demo::u32::{0}] -/
def u32.ToU32Inst : ToU32 U32 := {
  to_u32 := u32.to_u32
}

/- [demo::Option::{1}::to_u32]: forward function -/
def Option.to_u32 (T : Type) (inst : ToU32 T) (self : Option T) : Result U32 :=
  match self with
  | Option.none => Result.ret 0#u32
  | Option.some x => inst.to_u32 x

/- Trait implementation: [demo::Option::{1}] -/
def Option.ToU32Inst (T : Type) (inst : ToU32 T) : ToU32 (Option T) := {
  to_u32 := Option.to_u32 T inst
}

/- [demo::option_u32_to_u32]: forward function -/
def option_u32_to_u32 (x : Option U32) : Result U32 :=
  Option.to_u32 U32 u32.ToU32Inst x

/- Trait declaration: [demo::Get] -/
structure Get (Self : Type) where
  Item : Type
  get : Self → Result Item
  get_back : Self → Item → Result Self

/- [demo::use_get]: forward function -/
def use_get
  (T : Type) (inst : Get T) (inst0 : ToU32 inst.Item) (x : T) : Result U32 :=
  do
    let i ← inst.get x
    inst0.to_u32 i

/- [demo::use_get]: backward function 0 -/
def use_get_back
  (T : Type) (inst : Get T) (inst0 : ToU32 inst.Item) (x : T) : Result T :=
  do
    let i ← inst.get x
    let _ ← inst0.to_u32 i
    inst.get_back x i

end demo
