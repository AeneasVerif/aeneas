-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [avl]: function definitions
import Base
import Avl.Types
open Primitives
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace avl

/- [avl::{(avl::Ord for i32)}::cmp]:
   Source: 'src/avl.rs', lines 7:4-7:43 -/
def OrdI32.cmp (self : I32) (other : I32) : Result Ordering :=
  if self < other
  then Result.ok Ordering.Less
  else
    if self = other
    then Result.ok Ordering.Equal
    else Result.ok Ordering.Greater

/- Trait implementation: [avl::{(avl::Ord for i32)}]
   Source: 'src/avl.rs', lines 6:0-6:16 -/
def OrdI32 : Ord I32 := {
  cmp := OrdI32.cmp
}

/- [avl::{avl::Node<T>#1}::rotate_left]:
   Source: 'src/avl.rs', lines 40:4-40:65 -/
def Node.rotate_left
  (T : Type) (root : Node T) (z : Node T) : Result (Node T) :=
  let (b, o) := core.mem.replace (Option (Node T)) z.left none
  let (x, root1) :=
    core.mem.replace (Node T) (Node.mk root.value root.left b
      root.balance_factor) (Node.mk z.value o z.right z.balance_factor)
  if root1.balance_factor = 0#i8
  then
    Result.ok (Node.mk root1.value (some (Node.mk x.value x.left x.right 1#i8))
      root1.right (-1)#i8)
  else
    Result.ok (Node.mk root1.value (some (Node.mk x.value x.left x.right 0#i8))
      root1.right 0#i8)

/- [avl::{avl::Node<T>#1}::rotate_right]:
   Source: 'src/avl.rs', lines 91:4-91:66 -/
def Node.rotate_right
  (T : Type) (root : Node T) (z : Node T) : Result (Node T) :=
  let (b, o) := core.mem.replace (Option (Node T)) z.right none
  let (x, root1) :=
    core.mem.replace (Node T) (Node.mk root.value b root.right
      root.balance_factor) (Node.mk z.value z.left o z.balance_factor)
  if root1.balance_factor = 0#i8
  then
    Result.ok (Node.mk root1.value root1.left (some (Node.mk x.value 
      x.left x.right (-1)#i8)) 1#i8)
  else
    Result.ok (Node.mk root1.value root1.left (some (Node.mk x.value 
      x.left x.right 0#i8)) 0#i8)

/- [avl::{avl::Node<T>#1}::rotate_left_right]:
   Source: 'src/avl.rs', lines 137:4-137:72 -/
def Node.rotate_left_right
  (T : Type) (root : Node T) (z : Node T) : Result (Node T) :=
  do
  let (o, _) := core.mem.replace (Option (Node T)) z.right none
  let y ← core.option.Option.unwrap (Node T) o
  let (a, o1) := core.mem.replace (Option (Node T)) y.left none
  let (b, o2) := core.mem.replace (Option (Node T)) y.right none
  let (x, root1) :=
    core.mem.replace (Node T) (Node.mk root.value b root.right
      root.balance_factor) (Node.mk y.value o1 o2 y.balance_factor)
  if root1.balance_factor = 0#i8
  then
    Result.ok (Node.mk root1.value (some (Node.mk z.value z.left a 0#i8)) (some
      (Node.mk x.value x.left x.right 0#i8)) 0#i8)
  else
    if root1.balance_factor < 0#i8
    then
      Result.ok (Node.mk root1.value (some (Node.mk z.value z.left a 0#i8))
        (some (Node.mk x.value x.left x.right 1#i8)) 0#i8)
    else
      Result.ok (Node.mk root1.value (some (Node.mk z.value z.left a (-1)#i8))
        (some (Node.mk x.value x.left x.right 0#i8)) 0#i8)

/- [avl::{avl::Node<T>#1}::rotate_right_left]:
   Source: 'src/avl.rs', lines 187:4-187:72 -/
def Node.rotate_right_left
  (T : Type) (root : Node T) (z : Node T) : Result (Node T) :=
  do
  let (o, _) := core.mem.replace (Option (Node T)) z.left none
  let y ← core.option.Option.unwrap (Node T) o
  let (b, o1) := core.mem.replace (Option (Node T)) y.left none
  let (a, o2) := core.mem.replace (Option (Node T)) y.right none
  let (x, root1) :=
    core.mem.replace (Node T) (Node.mk root.value root.left b
      root.balance_factor) (Node.mk y.value o1 o2 y.balance_factor)
  if root1.balance_factor = 0#i8
  then
    Result.ok (Node.mk root1.value (some (Node.mk x.value x.left x.right 0#i8))
      (some (Node.mk z.value a z.right 0#i8)) 0#i8)
  else
    if root1.balance_factor > 0#i8
    then
      Result.ok (Node.mk root1.value (some (Node.mk x.value x.left x.right
        (-1)#i8)) (some (Node.mk z.value a z.right 0#i8)) 0#i8)
    else
      Result.ok (Node.mk root1.value (some (Node.mk x.value x.left x.right
        0#i8)) (some (Node.mk z.value a z.right 1#i8)) 0#i8)

/- [avl::{avl::Node<T>#2}::insert_in_left]:
   Source: 'src/avl.rs', lines 239:4-239:64 -/
mutual divergent def Node.insert_in_left
  (T : Type) (OrdInst : Ord T) (node : Node T) (value : T) :
  Result (Bool × (Node T))
  :=
  do
  let (b, o) ← Tree.insert_in_opt_node T OrdInst node.left value
  if b
  then
    do
    let i ← node.balance_factor - 1#i8
    if i = (-2)#i8
    then
      do
      let (o1, o2) := core.mem.replace (Option (Node T)) o none
      let left ← core.option.Option.unwrap (Node T) o1
      if left.balance_factor <= 0#i8
      then
        do
        let node1 ←
          Node.rotate_right T (Node.mk node.value o2 node.right i) left
        Result.ok (false, node1)
      else
        do
        let node1 ←
          Node.rotate_left_right T (Node.mk node.value o2 node.right i) left
        Result.ok (false, node1)
    else Result.ok (i != 0#i8, Node.mk node.value o node.right i)
  else Result.ok (false, Node.mk node.value o node.right node.balance_factor)

/- [avl::{avl::Tree<T>#3}::insert_in_opt_node]:
   Source: 'src/avl.rs', lines 353:4-353:76 -/
divergent def Tree.insert_in_opt_node
  (T : Type) (OrdInst : Ord T) (node : Option (Node T)) (value : T) :
  Result (Bool × (Option (Node T)))
  :=
  match node with
  | none => let n := Node.mk value none none 0#i8
            Result.ok (true, some n)
  | some node1 =>
    do
    let (b, node2) ← Node.insert T OrdInst node1 value
    Result.ok (b, some node2)

/- [avl::{avl::Node<T>#2}::insert_in_right]:
   Source: 'src/avl.rs', lines 275:4-275:65 -/
divergent def Node.insert_in_right
  (T : Type) (OrdInst : Ord T) (node : Node T) (value : T) :
  Result (Bool × (Node T))
  :=
  do
  let (b, o) ← Tree.insert_in_opt_node T OrdInst node.right value
  if b
  then
    do
    let i ← node.balance_factor + 1#i8
    if i = 2#i8
    then
      do
      let (o1, o2) := core.mem.replace (Option (Node T)) o none
      let right ← core.option.Option.unwrap (Node T) o1
      if right.balance_factor >= 0#i8
      then
        do
        let node1 ←
          Node.rotate_left T (Node.mk node.value node.left o2 i) right
        Result.ok (false, node1)
      else
        do
        let node1 ←
          Node.rotate_right_left T (Node.mk node.value node.left o2 i) right
        Result.ok (false, node1)
    else Result.ok (i != 0#i8, Node.mk node.value node.left o i)
  else Result.ok (false, Node.mk node.value node.left o node.balance_factor)

/- [avl::{avl::Node<T>#2}::insert]:
   Source: 'src/avl.rs', lines 315:4-315:56 -/
divergent def Node.insert
  (T : Type) (OrdInst : Ord T) (node : Node T) (value : T) :
  Result (Bool × (Node T))
  :=
  do
  let ordering ← OrdInst.cmp value node.value
  match ordering with
  | Ordering.Less => Node.insert_in_left T OrdInst node value
  | Ordering.Equal => Result.ok (false, node)
  | Ordering.Greater => Node.insert_in_right T OrdInst node value

end

/- [avl::{avl::Tree<T>#3}::new]:
   Source: 'src/avl.rs', lines 335:4-335:24 -/
def Tree.new (T : Type) (OrdInst : Ord T) : Result (Tree T) :=
  Result.ok { root := none }

/- [avl::{avl::Tree<T>#3}::find]: loop 0:
   Source: 'src/avl.rs', lines 339:4-351:5 -/
divergent def Tree.find_loop
  (T : Type) (OrdInst : Ord T) (value : T) (current_tree : Option (Node T)) :
  Result Bool
  :=
  match current_tree with
  | none => Result.ok false
  | some current_node =>
    do
    let o ← OrdInst.cmp current_node.value value
    match o with
    | Ordering.Less => Tree.find_loop T OrdInst value current_node.right
    | Ordering.Equal => Result.ok true
    | Ordering.Greater => Tree.find_loop T OrdInst value current_node.left

/- [avl::{avl::Tree<T>#3}::find]:
   Source: 'src/avl.rs', lines 339:4-339:40 -/
def Tree.find
  (T : Type) (OrdInst : Ord T) (self : Tree T) (value : T) : Result Bool :=
  Tree.find_loop T OrdInst value self.root

/- [avl::{avl::Tree<T>#3}::insert]:
   Source: 'src/avl.rs', lines 371:4-371:46 -/
def Tree.insert
  (T : Type) (OrdInst : Ord T) (self : Tree T) (value : T) :
  Result (Bool × (Tree T))
  :=
  do
  let (b, o) ← Tree.insert_in_opt_node T OrdInst self.root value
  Result.ok (b, { root := o })

end avl
