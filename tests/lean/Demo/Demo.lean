-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [demo]
import Base
open Primitives
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace demo

/- [demo::choose]:
   Source: 'tests/src/demo.rs', lines 7:0-13:1 -/
def choose
  {T : Type} (b : Bool) (x : T) (y : T) : Result (T × (T → (T × T))) :=
  if b
  then let back := fun ret => (ret, y)
       Result.ok (x, back)
  else let back := fun ret => (x, ret)
       Result.ok (y, back)

/- [demo::mul2_add1]:
   Source: 'tests/src/demo.rs', lines 15:0-17:1 -/
def mul2_add1 (x : U32) : Result U32 :=
  do
  let i ← x + x
  i + 1#u32

/- [demo::use_mul2_add1]:
   Source: 'tests/src/demo.rs', lines 19:0-21:1 -/
def use_mul2_add1 (x : U32) (y : U32) : Result U32 :=
  do
  let i ← mul2_add1 x
  i + y

/- [demo::incr]:
   Source: 'tests/src/demo.rs', lines 23:0-25:1 -/
def incr (x : U32) : Result U32 :=
  x + 1#u32

/- [demo::use_incr]:
   Source: 'tests/src/demo.rs', lines 27:0-32:1 -/
def use_incr : Result Unit :=
  do
  let x ← incr 0#u32
  let x1 ← incr x
  let _ ← incr x1
  Result.ok ()

/- [demo::CList]
   Source: 'tests/src/demo.rs', lines 36:0-39:1 -/
inductive CList (T : Type) where
| CCons : T → CList T → CList T
| CNil : CList T

/- [demo::list_nth]:
   Source: 'tests/src/demo.rs', lines 41:0-54:1 -/
divergent def list_nth {T : Type} (l : CList T) (i : U32) : Result T :=
  match l with
  | CList.CCons x tl =>
    if i = 0#u32
    then Result.ok x
    else do
         let i1 ← i - 1#u32
         list_nth tl i1
  | CList.CNil => Result.fail .panic

/- [demo::list_nth1]: loop 0:
   Source: 'tests/src/demo.rs', lines 57:4-65:1 -/
divergent def list_nth1_loop {T : Type} (l : CList T) (i : U32) : Result T :=
  match l with
  | CList.CCons x tl =>
    if i = 0#u32
    then Result.ok x
    else do
         let i1 ← i - 1#u32
         list_nth1_loop tl i1
  | CList.CNil => Result.fail .panic

/- [demo::list_nth1]:
   Source: 'tests/src/demo.rs', lines 56:0-65:1 -/
@[reducible]
def list_nth1 {T : Type} (l : CList T) (i : U32) : Result T :=
  list_nth1_loop l i

/- [demo::list_nth_mut]:
   Source: 'tests/src/demo.rs', lines 67:0-80:1 -/
divergent def list_nth_mut
  {T : Type} (l : CList T) (i : U32) : Result (T × (T → CList T)) :=
  match l with
  | CList.CCons x tl =>
    if i = 0#u32
    then let back := fun ret => CList.CCons ret tl
         Result.ok (x, back)
    else
      do
      let i1 ← i - 1#u32
      let (t, list_nth_mut_back) ← list_nth_mut tl i1
      let back := fun ret => let tl1 := list_nth_mut_back ret
                             CList.CCons x tl1
      Result.ok (t, back)
  | CList.CNil => Result.fail .panic

/- [demo::i32_id]:
   Source: 'tests/src/demo.rs', lines 82:0-88:1 -/
divergent def i32_id (i : I32) : Result I32 :=
  if i = 0#i32
  then Result.ok 0#i32
  else do
       let i1 ← i - 1#i32
       let i2 ← i32_id i1
       i2 + 1#i32

/- [demo::list_tail]:
   Source: 'tests/src/demo.rs', lines 90:0-95:1 -/
divergent def list_tail
  {T : Type} (l : CList T) : Result ((CList T) × (CList T → CList T)) :=
  match l with
  | CList.CCons t tl =>
    do
    let (c, list_tail_back) ← list_tail tl
    let back := fun ret => let tl1 := list_tail_back ret
                           CList.CCons t tl1
    Result.ok (c, back)
  | CList.CNil => Result.ok (CList.CNil, fun ret => ret)

/- Trait declaration: [demo::Counter]
   Source: 'tests/src/demo.rs', lines 99:0-101:1 -/
structure Counter (Self : Type) where
  incr : Self → Result (Usize × Self)

/- [demo::{demo::Counter for usize}::incr]:
   Source: 'tests/src/demo.rs', lines 104:4-108:5 -/
def CounterUsize.incr (self : Usize) : Result (Usize × Usize) :=
  do
  let self1 ← self + 1#usize
  Result.ok (self, self1)

/- Trait implementation: [demo::{demo::Counter for usize}]
   Source: 'tests/src/demo.rs', lines 103:0-109:1 -/
@[reducible]
def CounterUsize : Counter Usize := {
  incr := CounterUsize.incr
}

/- [demo::use_counter]:
   Source: 'tests/src/demo.rs', lines 111:0-113:1 -/
def use_counter
  {T : Type} (CounterInst : Counter T) (cnt : T) : Result (Usize × T) :=
  CounterInst.incr cnt

end demo
