import Mathlib.Tactic.Basic
import Mathlib.Tactic.Attr.Register
import Mathlib.Data.Int.Cast.Basic
import Mathlib.Order.Basic
import Aeneas.ZModify.Init
import Aeneas.Arith.Lemmas
import Aeneas.Std.Scalar

/-!
# `zmodify` tactic

The `zmodify` tactic is used to shift propositions about, e.g., `Nat`, to `ZMod`.
This tactic is adapted from `zify`.
-/

namespace Aeneas.ZModify

open Lean
open Lean.Meta
open Lean.Parser.Tactic
open Lean.Elab.Tactic
open Arith Std

syntax (name := zmodify) "zmodify" (simpArgs)? (location)? : tactic

macro_rules
| `(tactic| zmodify $[[$simpArgs,*]]? $[at $location]?) =>
  let args := simpArgs.map (·.getElems) |>.getD #[]
  `(tactic|
    simp -decide (maxDischargeDepth := 1) only [zmodify_simps, push_cast, $args,*] $[at $location]?)

/-- The `Simp.Context` generated by `zmodify`. -/
def mkZModifyContext (simpArgs : Option (Syntax.TSepArray `Lean.Parser.Tactic.simpStar ",")) :
    TacticM MkSimpContextResult := do
  let args := simpArgs.map (·.getElems) |>.getD #[]
  mkSimpContext
    (← `(tactic| simp -decide (maxDischargeDepth := 1) only [zmodify_simps, push_cast, $args,*])) false

attribute [zmodify_simps] Nat.eq_mod_iff_eq_ZMod Int.eq_mod_iff_eq_ZMod div_to_ZMod
attribute [zmodify_simps] Nat.reduceGcd

@[zmodify_simps]
theorem Nat.eq_mod_zero_iff_eq_ZMod (n : ℕ) (a : Nat) : a % n = 0 ↔ (a : ZMod n) = 0 := by
  have : 0 = 0 % n := by simp only [Nat.zero_mod]
  rw [this]
  simp only [Nat.eq_mod_iff_eq_ZMod, Nat.cast_zero]

@[zmodify_simps]
theorem Nat.eq_zero_mod_iff_eq_ZMod (n : ℕ) (a : Nat) : 0 = a % n ↔ 0 = (a : ZMod n) := by
  have : 0 = 0 % n := by simp only [Nat.zero_mod]
  rw [this]
  simp only [Nat.eq_mod_iff_eq_ZMod, Nat.cast_zero]

@[zmodify_simps]
theorem Int.eq_zero_mod_iff_eq_ZMod (n : ℕ) (a : ℤ) : 0 = a % n ↔ 0 = (a : ZMod n) := by
  have : (0 : Int) = 0 % n := by simp only [EuclideanDomain.zero_mod]
  rw [this]
  simp only [Int.eq_mod_iff_eq_ZMod, Int.cast_zero]

@[zmodify_simps]
theorem Int.eq_mod_zero_iff_eq_ZMod (n : ℕ) (a : ℤ) : a % n = 0 ↔ (a : ZMod n) = 0 := by
  have : (0 : Int) = 0 % n := by simp only [EuclideanDomain.zero_mod]
  rw [this]
  simp only [Int.eq_mod_iff_eq_ZMod, Int.cast_zero]

end Aeneas.ZModify
