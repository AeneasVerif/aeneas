import Mathlib.Tactic.Basic
import Mathlib.Tactic.Attr.Register
import Mathlib.Data.Int.Cast.Basic
import Mathlib.Order.Basic
import Aeneas.Bvify.Init
import Aeneas.Arith.Lemmas
import Aeneas.Std.Scalar
import Aeneas.Std.PrimitivesLemmas

/-!
# `bvify` tactic

The `bvify` tactic is used to shift propositions about, e.g., `Nat`, to `BitVec`.
This tactic is adapted from `zify`.
-/

namespace Aeneas.Bvify

open Lean Lean.Meta Lean.Parser.Tactic Lean.Elab.Tactic
open Arith Std

attribute [bvify_simps] ge_iff_le gt_iff_lt decide_eq_true_eq massert_ok

attribute [bvify_simps]
  UScalar.BitVec_ofNat_val_eq
  U8.BitVec_ofNat_val_eq U16.BitVec_ofNat_val_eq U32.BitVec_ofNat_val_eq
  U64.BitVec_ofNat_val_eq U128.BitVec_ofNat_val_eq Usize.BitVec_ofNat_val_eq
  U8.lt_succ_max U16.lt_succ_max U32.lt_succ_max U64.lt_succ_max U128.lt_succ_max
  U8.le_max U16.le_max U32.le_max U64.le_max U128.le_max

attribute [bvify_simps]
  U8.eq_equiv_bv_eq U16.eq_equiv_bv_eq U32.eq_equiv_bv_eq U64.eq_equiv_bv_eq U128.eq_equiv_bv_eq Usize.eq_equiv_bv_eq
  I8.eq_equiv_bv_eq I16.eq_equiv_bv_eq I32.eq_equiv_bv_eq I64.eq_equiv_bv_eq I128.eq_equiv_bv_eq Isize.eq_equiv_bv_eq
  U8.wrapping_add_bv_eq U16.wrapping_add_bv_eq U32.wrapping_add_bv_eq U64.wrapping_add_bv_eq U128.wrapping_add_bv_eq Usize.wrapping_add_bv_eq
  I8.wrapping_add_bv_eq I16.wrapping_add_bv_eq I32.wrapping_add_bv_eq I64.wrapping_add_bv_eq I128.wrapping_add_bv_eq Isize.wrapping_add_bv_eq
  U8.wrapping_sub_bv_eq U16.wrapping_sub_bv_eq U32.wrapping_sub_bv_eq U64.wrapping_sub_bv_eq U128.wrapping_sub_bv_eq Usize.wrapping_sub_bv_eq
  I8.wrapping_sub_bv_eq I16.wrapping_sub_bv_eq I32.wrapping_sub_bv_eq I64.wrapping_sub_bv_eq I128.wrapping_sub_bv_eq Isize.wrapping_sub_bv_eq
  UScalarTy.U8_numBits_eq UScalarTy.U16_numBits_eq UScalarTy.U32_numBits_eq UScalarTy.U64_numBits_eq UScalarTy.U128_numBits_eq UScalarTy.Usize_numBits_eq
  IScalarTy.I8_numBits_eq IScalarTy.I16_numBits_eq IScalarTy.I32_numBits_eq IScalarTy.I64_numBits_eq IScalarTy.I128_numBits_eq IScalarTy.Isize_numBits_eq
  U8.ofNat_bv U16.ofNat_bv U32.ofNat_bv U64.ofNat_bv U128.ofNat_bv Usize.ofNat_bv
  I8.ofInt_bv I16.ofInt_bv I32.ofInt_bv I64.ofInt_bv I128.ofInt_bv Isize.ofInt_bv
  UScalar.ofNat_val_eq IScalar.toNat IScalar.ofInt_val_eq
  UScalar.bv_and UScalar.bv_or IScalar.bv_and IScalar.bv_or

/-!
Some theorems which automatically lift comparisons between machine scalars, without needing the bitwise to be provided by the user.
-/

attribute [bvify_simps] UScalar.eq_equiv_bv_eq IScalar.eq_equiv_bv_eq
                        gt_iff_lt ge_iff_le

@[bvify_simps]
theorem UScalar.lt_equiv_bv_lt {ty : UScalarTy} (x y : UScalar ty) : x < y ↔ x.bv < y.bv := by rfl

@[bvify_simps]
theorem UScalar.le_equiv_bv_le {ty : UScalarTy} (x y : UScalar ty) : x ≤ y ↔ x.bv ≤ y.bv := by rfl

syntax (name := bvify) "bvify" num (simpArgs)? (location)? : tactic

macro_rules
| `(tactic| bvify $n $[[$simpArgs,*]]? $[at $location]?) =>
  let args := simpArgs.map (·.getElems) |>.getD #[]
  `(tactic|
    simp -decide (maxDischargeDepth := 1) only [
      Int.reduceToNat, Nat.reducePow, Nat.reduceLT,
      Nat.lt_iff_BitVec_ofNat_lt $n, Nat.le_iff_BitVec_ofNat_le $n,
      bvify_simps, push_cast, $args,*] $[at $location]?)

def bvifyTacSimp (loc : Utils.Location) (additionalAsms : List FVarId := []): TacticM Unit := do
  let simpTheorems ← bvifySimpExt.getTheorems
  let simprocs := [``Nat.reducePow, ``Nat.reduceLT]
  Utils.simpAt true {maxDischargeDepth := 1, failIfUnchanged := false} simprocs [simpTheorems] [] [] additionalAsms loc

def bvifyTac (n : Expr) (loc : Utils.Location) : TacticM Unit := do
  Elab.Tactic.focus do
  let addThm (thName : Name) : TacticM FVarId := do
    let thm ← mkAppM thName #[n]
    let thm ← Utils.addDeclTac (← Utils.mkFreshAnonPropUserName) thm (← inferType thm) (asLet := false)
    pure thm.fvarId!
  let lt_iff ← addThm ``Nat.lt_iff_BitVec_ofNat_lt
  let le_iff ← addThm ``Nat.le_iff_BitVec_ofNat_le
  let eq_iff ← addThm ``Nat.eq_iff_BitVec_ofNat_eq
  withMainContext do
  bvifyTacSimp loc [lt_iff, le_iff, eq_iff]
  allGoals do Utils.clearFvarIds #[lt_iff, le_iff, eq_iff]

elab "bvify'" n:term : tactic => do
  bvifyTac (← Elab.Term.elabTerm n (Expr.const ``Nat [])) Utils.Location.wildcard

/-- The `Simp.Context` generated by `bvify`. -/
def mkBvifyContext (simpArgs : Option (Syntax.TSepArray `Lean.Parser.Tactic.simpStar ",")) :
    TacticM MkSimpContextResult := do
  let args := simpArgs.map (·.getElems) |>.getD #[]
  mkSimpContext
    (← `(tactic| simp -decide (maxDischargeDepth := 1) only [bvify_simps, push_cast, $args,*])) false

/-- A variant of `applySimpResultToProp` that cannot close the goal, but does not need a meta
variable and returns a tuple of a proof and the corresponding simplified proposition. -/
def applySimpResultToProp' (proof : Expr) (prop : Expr) (r : Simp.Result) : MetaM (Expr × Expr) :=
  do
  match r.proof? with
  | some eqProof => return (← mkExpectedTypeHint (← mkEqMP eqProof proof) r.expr, r.expr)
  | none =>
    if r.expr != prop then
      return (← mkExpectedTypeHint proof r.expr, r.expr)
    else
      return (proof, r.expr)

/-- Translate a proof and the proposition into a natified form. -/
def bvifyProof (simpArgs : Option (Syntax.TSepArray `Lean.Parser.Tactic.simpStar ","))
    (proof : Expr) (prop : Expr) : TacticM (Expr × Expr) := do
  let ctx_result ← mkBvifyContext simpArgs
  let (r, _) ← simp prop ctx_result.ctx
  applySimpResultToProp' proof prop r

example (x y : U8) (h : x.val < y.val) : x.bv < y.bv := by
  bvify 8 at h
  apply h

example (x y : U8) (h : x.val < y.val) : x.bv < y.bv := by
  bvify' 8
  apply h

example (x : U8) (h : x.val < 32) : x.bv < 32#8 := by
  bvify 8 at h
  apply h

example (x : U8) (h : x.val < 32) : x.bv < 32#8 := by
  bvify' 8
  apply h

example (a : U32) (h : a.val = 3329) : a.bv = 3329#32 := by
  bvify' 32
  apply h

end Aeneas.Bvify
